// Autogenerated by Thrift Compiler (0.22.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(dead_code)]
#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![allow(clippy::too_many_arguments, clippy::type_complexity, clippy::vec_box, clippy::wrong_self_convention)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use thrift::OrderedFloat;
use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSerializable, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

use crate::cadence_thrift::shared;

//
// WorkflowService service client
//

/// WorkflowService API is exposed to provide support for long running applications.  Application is expected to call
/// StartWorkflowExecution to create an instance for each instance of long running workflow.  Such applications are expected
/// to have a worker which regularly polls for DecisionTask and ActivityTask from the WorkflowService.  For each
/// DecisionTask, application is expected to process the history of events for that session and respond back with next
/// decisions.  For each ActivityTask, application is expected to execute the actual logic for that task and respond back
/// with completion or failure.  Worker is expected to regularly heartbeat while activity task is running.
/// 
pub trait TWorkflowServiceSyncClient {
  /// RegisterDomain creates a new domain which can be used as a container for all resources.  Domain is a top level
  /// entity within Cadence, used as a container for all resources like workflow executions, tasklists, etc.  Domain
  /// acts as a sandbox and provides isolation for all resources within the domain.  All resources belongs to exactly one
  /// domain.
  /// 
  fn register_domain(&mut self, register_request: shared::RegisterDomainRequest) -> thrift::Result<()>;
  /// DescribeDomain returns the information and configuration for a registered domain.
  /// 
  fn describe_domain(&mut self, describe_request: shared::DescribeDomainRequest) -> thrift::Result<shared::DescribeDomainResponse>;
  /// ListDomains returns the information and configuration for all domains.
  /// 
  fn list_domains(&mut self, list_request: shared::ListDomainsRequest) -> thrift::Result<shared::ListDomainsResponse>;
  /// UpdateDomain is used to update the information and configuration for a registered domain.
  /// 
  fn update_domain(&mut self, update_request: shared::UpdateDomainRequest) -> thrift::Result<shared::UpdateDomainResponse>;
  /// FailoverDomain is used to failover a registered domain to different cluster.
  /// 
  fn failover_domain(&mut self, failover_request: shared::FailoverDomainRequest) -> thrift::Result<shared::FailoverDomainResponse>;
  /// DeprecateDomain us used to update status of a registered domain to DEPRECATED.  Once the domain is deprecated
  /// it cannot be used to start new workflow executions.  Existing workflow executions will continue to run on
  /// deprecated domains.
  /// 
  fn deprecate_domain(&mut self, deprecate_request: shared::DeprecateDomainRequest) -> thrift::Result<()>;
  /// DeleteDomain permanently removes a domain record. This operation:
  /// - Requires domain to be in DEPRECATED status
  /// - Cannot be performed on domains with running workflows
  /// - Is irreversible and removes all domain data
  /// - Requires proper permissions and security token
  /// 
  fn delete_domain(&mut self, delete_request: shared::DeleteDomainRequest) -> thrift::Result<()>;
  /// ListFailoverHistory returns the history of failover events for a domain.
  /// 
  fn list_failover_history(&mut self, list_request: shared::ListFailoverHistoryRequest) -> thrift::Result<shared::ListFailoverHistoryResponse>;
  /// RestartWorkflowExecution restarts a previous workflow
  /// If the workflow is currently running it will terminate and restart
  /// 
  fn restart_workflow_execution(&mut self, restart_request: shared::RestartWorkflowExecutionRequest) -> thrift::Result<shared::RestartWorkflowExecutionResponse>;
  /// DiagnoseWorkflowExecution diagnoses a previous workflow execution
  /// 
  fn diagnose_workflow_execution(&mut self, diagnose_request: shared::DiagnoseWorkflowExecutionRequest) -> thrift::Result<shared::DiagnoseWorkflowExecutionResponse>;
  /// StartWorkflowExecution starts a new long running workflow instance.  It will create the instance with
  /// 'WorkflowExecutionStarted' event in history and also schedule the first DecisionTask for the worker to make the
  /// first decision for this instance.  It will return 'WorkflowExecutionAlreadyStartedError', if an instance already
  /// exists with same workflowId.
  /// 
  fn start_workflow_execution(&mut self, start_request: shared::StartWorkflowExecutionRequest) -> thrift::Result<shared::StartWorkflowExecutionResponse>;
  /// StartWorkflowExecutionAsync starts a new long running workflow instance asynchronously. It will push a StartWorkflowExecutionRequest to a queue
  /// and immediately return a response. The request will be processed by a separate consumer eventually.
  /// 
  fn start_workflow_execution_async(&mut self, start_request: shared::StartWorkflowExecutionAsyncRequest) -> thrift::Result<shared::StartWorkflowExecutionAsyncResponse>;
  /// Returns the history of specified workflow execution.  It fails with 'EntityNotExistError' if speficied workflow
  /// execution in unknown to the service.
  /// 
  fn get_workflow_execution_history(&mut self, get_request: shared::GetWorkflowExecutionHistoryRequest) -> thrift::Result<shared::GetWorkflowExecutionHistoryResponse>;
  /// PollForDecisionTask is called by application worker to process DecisionTask from a specific taskList.  A
  /// DecisionTask is dispatched to callers for active workflow executions, with pending decisions.
  /// Application is then expected to call 'RespondDecisionTaskCompleted' API when it is done processing the DecisionTask.
  /// It will also create a 'DecisionTaskStarted' event in the history for that session before handing off DecisionTask to
  /// application worker.
  /// 
  fn poll_for_decision_task(&mut self, poll_request: shared::PollForDecisionTaskRequest) -> thrift::Result<shared::PollForDecisionTaskResponse>;
  /// RespondDecisionTaskCompleted is called by application worker to complete a DecisionTask handed as a result of
  /// 'PollForDecisionTask' API call.  Completing a DecisionTask will result in new events for the workflow execution and
  /// potentially new ActivityTask being created for corresponding decisions.  It will also create a DecisionTaskCompleted
  /// event in the history for that session.  Use the 'taskToken' provided as response of PollForDecisionTask API call
  /// for completing the DecisionTask.
  /// The response could contain a new decision task if there is one or if the request asking for one.
  /// 
  fn respond_decision_task_completed(&mut self, complete_request: shared::RespondDecisionTaskCompletedRequest) -> thrift::Result<shared::RespondDecisionTaskCompletedResponse>;
  /// RespondDecisionTaskFailed is called by application worker to indicate failure.  This results in
  /// DecisionTaskFailedEvent written to the history and a new DecisionTask created.  This API can be used by client to
  /// either clear sticky tasklist or report any panics during DecisionTask processing.  Cadence will only append first
  /// DecisionTaskFailed event to the history of workflow execution for consecutive failures.
  /// 
  fn respond_decision_task_failed(&mut self, failed_request: shared::RespondDecisionTaskFailedRequest) -> thrift::Result<()>;
  /// PollForActivityTask is called by application worker to process ActivityTask from a specific taskList.  ActivityTask
  /// is dispatched to callers whenever a ScheduleTask decision is made for a workflow execution.
  /// Application is expected to call 'RespondActivityTaskCompleted' or 'RespondActivityTaskFailed' once it is done
  /// processing the task.
  /// Application also needs to call 'RecordActivityTaskHeartbeat' API within 'heartbeatTimeoutSeconds' interval to
  /// prevent the task from getting timed out.  An event 'ActivityTaskStarted' event is also written to workflow execution
  /// history before the ActivityTask is dispatched to application worker.
  /// 
  fn poll_for_activity_task(&mut self, poll_request: shared::PollForActivityTaskRequest) -> thrift::Result<shared::PollForActivityTaskResponse>;
  /// RecordActivityTaskHeartbeat is called by application worker while it is processing an ActivityTask.  If worker fails
  /// to heartbeat within 'heartbeatTimeoutSeconds' interval for the ActivityTask, then it will be marked as timedout and
  /// 'ActivityTaskTimedOut' event will be written to the workflow history.  Calling 'RecordActivityTaskHeartbeat' will
  /// fail with 'EntityNotExistsError' in such situations.  Use the 'taskToken' provided as response of
  /// PollForActivityTask API call for heartbeating.
  /// 
  fn record_activity_task_heartbeat(&mut self, heartbeat_request: shared::RecordActivityTaskHeartbeatRequest) -> thrift::Result<shared::RecordActivityTaskHeartbeatResponse>;
  /// RecordActivityTaskHeartbeatByID is called by application worker while it is processing an ActivityTask.  If worker fails
  /// to heartbeat within 'heartbeatTimeoutSeconds' interval for the ActivityTask, then it will be marked as timedout and
  /// 'ActivityTaskTimedOut' event will be written to the workflow history.  Calling 'RecordActivityTaskHeartbeatByID' will
  /// fail with 'EntityNotExistsError' in such situations.  Instead of using 'taskToken' like in RecordActivityTaskHeartbeat,
  /// use Domain, WorkflowID and ActivityID
  /// 
  fn record_activity_task_heartbeat_by_i_d(&mut self, heartbeat_request: shared::RecordActivityTaskHeartbeatByIDRequest) -> thrift::Result<shared::RecordActivityTaskHeartbeatResponse>;
  /// RespondActivityTaskCompleted is called by application worker when it is done processing an ActivityTask.  It will
  /// result in a new 'ActivityTaskCompleted' event being written to the workflow history and a new DecisionTask
  /// created for the workflow so new decisions could be made.  Use the 'taskToken' provided as response of
  /// PollForActivityTask API call for completion. It fails with 'EntityNotExistsError' if the taskToken is not valid
  /// anymore due to activity timeout.
  /// 
  fn respond_activity_task_completed(&mut self, complete_request: shared::RespondActivityTaskCompletedRequest) -> thrift::Result<()>;
  /// RespondActivityTaskCompletedByID is called by application worker when it is done processing an ActivityTask.
  /// It will result in a new 'ActivityTaskCompleted' event being written to the workflow history and a new DecisionTask
  /// created for the workflow so new decisions could be made.  Similar to RespondActivityTaskCompleted but use Domain,
  /// WorkflowID and ActivityID instead of 'taskToken' for completion. It fails with 'EntityNotExistsError'
  /// if the these IDs are not valid anymore due to activity timeout.
  /// 
  fn respond_activity_task_completed_by_i_d(&mut self, complete_request: shared::RespondActivityTaskCompletedByIDRequest) -> thrift::Result<()>;
  /// RespondActivityTaskFailed is called by application worker when it is done processing an ActivityTask.  It will
  /// result in a new 'ActivityTaskFailed' event being written to the workflow history and a new DecisionTask
  /// created for the workflow instance so new decisions could be made.  Use the 'taskToken' provided as response of
  /// PollForActivityTask API call for completion. It fails with 'EntityNotExistsError' if the taskToken is not valid
  /// anymore due to activity timeout.
  /// 
  fn respond_activity_task_failed(&mut self, fail_request: shared::RespondActivityTaskFailedRequest) -> thrift::Result<()>;
  /// RespondActivityTaskFailedByID is called by application worker when it is done processing an ActivityTask.
  /// It will result in a new 'ActivityTaskFailed' event being written to the workflow history and a new DecisionTask
  /// created for the workflow instance so new decisions could be made.  Similar to RespondActivityTaskFailed but use
  /// Domain, WorkflowID and ActivityID instead of 'taskToken' for completion. It fails with 'EntityNotExistsError'
  /// if the these IDs are not valid anymore due to activity timeout.
  /// 
  fn respond_activity_task_failed_by_i_d(&mut self, fail_request: shared::RespondActivityTaskFailedByIDRequest) -> thrift::Result<()>;
  /// RespondActivityTaskCanceled is called by application worker when it is successfully canceled an ActivityTask.  It will
  /// result in a new 'ActivityTaskCanceled' event being written to the workflow history and a new DecisionTask
  /// created for the workflow instance so new decisions could be made.  Use the 'taskToken' provided as response of
  /// PollForActivityTask API call for completion. It fails with 'EntityNotExistsError' if the taskToken is not valid
  /// anymore due to activity timeout.
  /// 
  fn respond_activity_task_canceled(&mut self, canceled_request: shared::RespondActivityTaskCanceledRequest) -> thrift::Result<()>;
  /// RespondActivityTaskCanceledByID is called by application worker when it is successfully canceled an ActivityTask.
  /// It will result in a new 'ActivityTaskCanceled' event being written to the workflow history and a new DecisionTask
  /// created for the workflow instance so new decisions could be made.  Similar to RespondActivityTaskCanceled but use
  /// Domain, WorkflowID and ActivityID instead of 'taskToken' for completion. It fails with 'EntityNotExistsError'
  /// if the these IDs are not valid anymore due to activity timeout.
  /// 
  fn respond_activity_task_canceled_by_i_d(&mut self, canceled_request: shared::RespondActivityTaskCanceledByIDRequest) -> thrift::Result<()>;
  /// RequestCancelWorkflowExecution is called by application worker when it wants to request cancellation of a workflow instance.
  /// It will result in a new 'WorkflowExecutionCancelRequested' event being written to the workflow history and a new DecisionTask
  /// created for the workflow instance so new decisions could be made. It fails with 'EntityNotExistsError' if the workflow is not valid
  /// anymore due to completion or doesn't exist.
  /// 
  fn request_cancel_workflow_execution(&mut self, cancel_request: shared::RequestCancelWorkflowExecutionRequest) -> thrift::Result<()>;
  /// SignalWorkflowExecution is used to send a signal event to running workflow execution.  This results in
  /// WorkflowExecutionSignaled event recorded in the history and a decision task being created for the execution.
  /// 
  fn signal_workflow_execution(&mut self, signal_request: shared::SignalWorkflowExecutionRequest) -> thrift::Result<()>;
  /// SignalWithStartWorkflowExecution is used to ensure sending signal to a workflow.
  /// If the workflow is running, this results in WorkflowExecutionSignaled event being recorded in the history
  /// and a decision task being created for the execution.
  /// If the workflow is not running or not found, this results in WorkflowExecutionStarted and WorkflowExecutionSignaled
  /// events being recorded in history, and a decision task being created for the execution
  /// 
  fn signal_with_start_workflow_execution(&mut self, signal_with_start_request: shared::SignalWithStartWorkflowExecutionRequest) -> thrift::Result<shared::StartWorkflowExecutionResponse>;
  /// SignalWithStartWorkflowExecutionAsync is used to ensure sending signal to a workflow asynchronously.  It will push a SignalWithStartWorkflowExecutionRequest to a queue
  /// and immediately return a response. The request will be processed by a separate consumer eventually.
  /// 
  fn signal_with_start_workflow_execution_async(&mut self, signal_with_start_request: shared::SignalWithStartWorkflowExecutionAsyncRequest) -> thrift::Result<shared::SignalWithStartWorkflowExecutionAsyncResponse>;
  /// ResetWorkflowExecution reset an existing workflow execution to DecisionTaskCompleted event(exclusive).
  /// And it will immediately terminating the current execution instance.
  /// 
  fn reset_workflow_execution(&mut self, reset_request: shared::ResetWorkflowExecutionRequest) -> thrift::Result<shared::ResetWorkflowExecutionResponse>;
  /// TerminateWorkflowExecution terminates an existing workflow execution by recording WorkflowExecutionTerminated event
  /// in the history and immediately terminating the execution instance.
  /// 
  fn terminate_workflow_execution(&mut self, terminate_request: shared::TerminateWorkflowExecutionRequest) -> thrift::Result<()>;
  /// ListOpenWorkflowExecutions is a visibility API to list the open executions in a specific domain.
  /// 
  fn list_open_workflow_executions(&mut self, list_request: shared::ListOpenWorkflowExecutionsRequest) -> thrift::Result<shared::ListOpenWorkflowExecutionsResponse>;
  /// ListClosedWorkflowExecutions is a visibility API to list the closed executions in a specific domain.
  /// 
  fn list_closed_workflow_executions(&mut self, list_request: shared::ListClosedWorkflowExecutionsRequest) -> thrift::Result<shared::ListClosedWorkflowExecutionsResponse>;
  /// ListWorkflowExecutions is a visibility API to list workflow executions in a specific domain.
  /// 
  fn list_workflow_executions(&mut self, list_request: shared::ListWorkflowExecutionsRequest) -> thrift::Result<shared::ListWorkflowExecutionsResponse>;
  /// ListArchivedWorkflowExecutions is a visibility API to list archived workflow executions in a specific domain.
  /// 
  fn list_archived_workflow_executions(&mut self, list_request: shared::ListArchivedWorkflowExecutionsRequest) -> thrift::Result<shared::ListArchivedWorkflowExecutionsResponse>;
  /// ScanWorkflowExecutions is a visibility API to list large amount of workflow executions in a specific domain without order.
  /// 
  fn scan_workflow_executions(&mut self, list_request: shared::ListWorkflowExecutionsRequest) -> thrift::Result<shared::ListWorkflowExecutionsResponse>;
  /// CountWorkflowExecutions is a visibility API to count of workflow executions in a specific domain.
  /// 
  fn count_workflow_executions(&mut self, count_request: shared::CountWorkflowExecutionsRequest) -> thrift::Result<shared::CountWorkflowExecutionsResponse>;
  /// GetSearchAttributes is a visibility API to get all legal keys that could be used in list APIs
  /// 
  fn get_search_attributes(&mut self) -> thrift::Result<shared::GetSearchAttributesResponse>;
  /// RespondQueryTaskCompleted is called by application worker to complete a QueryTask (which is a DecisionTask for query)
  /// as a result of 'PollForDecisionTask' API call. Completing a QueryTask will unblock the client call to 'QueryWorkflow'
  /// API and return the query result to client as a response to 'QueryWorkflow' API call.
  /// 
  fn respond_query_task_completed(&mut self, complete_request: shared::RespondQueryTaskCompletedRequest) -> thrift::Result<()>;
  /// Reset the sticky tasklist related information in mutable state of a given workflow.
  /// Things cleared are:
  /// 1. StickyTaskList
  /// 2. StickyScheduleToStartTimeout
  /// 3. ClientLibraryVersion
  /// 4. ClientFeatureVersion
  /// 5. ClientImpl
  /// 
  fn reset_sticky_task_list(&mut self, reset_request: shared::ResetStickyTaskListRequest) -> thrift::Result<shared::ResetStickyTaskListResponse>;
  /// QueryWorkflow returns query result for a specified workflow execution
  /// 
  fn query_workflow(&mut self, query_request: shared::QueryWorkflowRequest) -> thrift::Result<shared::QueryWorkflowResponse>;
  /// DescribeWorkflowExecution returns information about the specified workflow execution.
  /// 
  fn describe_workflow_execution(&mut self, describe_request: shared::DescribeWorkflowExecutionRequest) -> thrift::Result<shared::DescribeWorkflowExecutionResponse>;
  /// DescribeTaskList returns information about the target tasklist, right now this API returns the
  /// pollers which polled this tasklist in last few minutes.
  /// 
  fn describe_task_list(&mut self, request: shared::DescribeTaskListRequest) -> thrift::Result<shared::DescribeTaskListResponse>;
  /// GetClusterInfo returns information about cadence cluster
  /// 
  fn get_cluster_info(&mut self) -> thrift::Result<shared::ClusterInfo>;
  /// GetTaskListsByDomain returns the list of all the task lists for a domainName.
  /// 
  fn get_task_lists_by_domain(&mut self, request: shared::GetTaskListsByDomainRequest) -> thrift::Result<shared::GetTaskListsByDomainResponse>;
  /// ReapplyEvents applies stale events to the current workflow and current run
  /// 
  fn list_task_list_partitions(&mut self, request: shared::ListTaskListPartitionsRequest) -> thrift::Result<shared::ListTaskListPartitionsResponse>;
  /// RefreshWorkflowTasks refreshes all tasks of a workflow
  /// 
  fn refresh_workflow_tasks(&mut self, request: shared::RefreshWorkflowTasksRequest) -> thrift::Result<()>;
}

pub trait TWorkflowServiceSyncClientMarker {}

pub struct WorkflowServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  _i_prot: IP,
  _o_prot: OP,
  _sequence_number: i32,
}

impl <IP, OP> WorkflowServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  pub fn new(input_protocol: IP, output_protocol: OP) -> WorkflowServiceSyncClient<IP, OP> {
    WorkflowServiceSyncClient { _i_prot: input_protocol, _o_prot: output_protocol, _sequence_number: 0 }
  }
}

impl <IP, OP> TThriftClient for WorkflowServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  fn i_prot_mut(&mut self) -> &mut dyn TInputProtocol { &mut self._i_prot }
  fn o_prot_mut(&mut self) -> &mut dyn TOutputProtocol { &mut self._o_prot }
  fn sequence_number(&self) -> i32 { self._sequence_number }
  fn increment_sequence_number(&mut self) -> i32 { self._sequence_number += 1; self._sequence_number }
}

impl <IP, OP> TWorkflowServiceSyncClientMarker for WorkflowServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {}

impl <C: TThriftClient + TWorkflowServiceSyncClientMarker> TWorkflowServiceSyncClient for C {
  fn register_domain(&mut self, register_request: shared::RegisterDomainRequest) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("RegisterDomain", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServiceRegisterDomainArgs { register_request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("RegisterDomain", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServiceRegisterDomainResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn describe_domain(&mut self, describe_request: shared::DescribeDomainRequest) -> thrift::Result<shared::DescribeDomainResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("DescribeDomain", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServiceDescribeDomainArgs { describe_request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("DescribeDomain", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServiceDescribeDomainResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn list_domains(&mut self, list_request: shared::ListDomainsRequest) -> thrift::Result<shared::ListDomainsResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("ListDomains", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServiceListDomainsArgs { list_request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("ListDomains", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServiceListDomainsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_domain(&mut self, update_request: shared::UpdateDomainRequest) -> thrift::Result<shared::UpdateDomainResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("UpdateDomain", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServiceUpdateDomainArgs { update_request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("UpdateDomain", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServiceUpdateDomainResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn failover_domain(&mut self, failover_request: shared::FailoverDomainRequest) -> thrift::Result<shared::FailoverDomainResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("FailoverDomain", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServiceFailoverDomainArgs { failover_request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("FailoverDomain", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServiceFailoverDomainResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn deprecate_domain(&mut self, deprecate_request: shared::DeprecateDomainRequest) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("DeprecateDomain", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServiceDeprecateDomainArgs { deprecate_request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("DeprecateDomain", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServiceDeprecateDomainResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn delete_domain(&mut self, delete_request: shared::DeleteDomainRequest) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("DeleteDomain", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServiceDeleteDomainArgs { delete_request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("DeleteDomain", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServiceDeleteDomainResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn list_failover_history(&mut self, list_request: shared::ListFailoverHistoryRequest) -> thrift::Result<shared::ListFailoverHistoryResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("ListFailoverHistory", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServiceListFailoverHistoryArgs { list_request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("ListFailoverHistory", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServiceListFailoverHistoryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn restart_workflow_execution(&mut self, restart_request: shared::RestartWorkflowExecutionRequest) -> thrift::Result<shared::RestartWorkflowExecutionResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("RestartWorkflowExecution", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServiceRestartWorkflowExecutionArgs { restart_request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("RestartWorkflowExecution", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServiceRestartWorkflowExecutionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn diagnose_workflow_execution(&mut self, diagnose_request: shared::DiagnoseWorkflowExecutionRequest) -> thrift::Result<shared::DiagnoseWorkflowExecutionResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("DiagnoseWorkflowExecution", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServiceDiagnoseWorkflowExecutionArgs { diagnose_request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("DiagnoseWorkflowExecution", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServiceDiagnoseWorkflowExecutionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn start_workflow_execution(&mut self, start_request: shared::StartWorkflowExecutionRequest) -> thrift::Result<shared::StartWorkflowExecutionResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("StartWorkflowExecution", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServiceStartWorkflowExecutionArgs { start_request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("StartWorkflowExecution", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServiceStartWorkflowExecutionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn start_workflow_execution_async(&mut self, start_request: shared::StartWorkflowExecutionAsyncRequest) -> thrift::Result<shared::StartWorkflowExecutionAsyncResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("StartWorkflowExecutionAsync", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServiceStartWorkflowExecutionAsyncArgs { start_request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("StartWorkflowExecutionAsync", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServiceStartWorkflowExecutionAsyncResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_workflow_execution_history(&mut self, get_request: shared::GetWorkflowExecutionHistoryRequest) -> thrift::Result<shared::GetWorkflowExecutionHistoryResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GetWorkflowExecutionHistory", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServiceGetWorkflowExecutionHistoryArgs { get_request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GetWorkflowExecutionHistory", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServiceGetWorkflowExecutionHistoryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn poll_for_decision_task(&mut self, poll_request: shared::PollForDecisionTaskRequest) -> thrift::Result<shared::PollForDecisionTaskResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PollForDecisionTask", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServicePollForDecisionTaskArgs { poll_request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PollForDecisionTask", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServicePollForDecisionTaskResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn respond_decision_task_completed(&mut self, complete_request: shared::RespondDecisionTaskCompletedRequest) -> thrift::Result<shared::RespondDecisionTaskCompletedResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("RespondDecisionTaskCompleted", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServiceRespondDecisionTaskCompletedArgs { complete_request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("RespondDecisionTaskCompleted", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServiceRespondDecisionTaskCompletedResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn respond_decision_task_failed(&mut self, failed_request: shared::RespondDecisionTaskFailedRequest) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("RespondDecisionTaskFailed", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServiceRespondDecisionTaskFailedArgs { failed_request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("RespondDecisionTaskFailed", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServiceRespondDecisionTaskFailedResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn poll_for_activity_task(&mut self, poll_request: shared::PollForActivityTaskRequest) -> thrift::Result<shared::PollForActivityTaskResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PollForActivityTask", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServicePollForActivityTaskArgs { poll_request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PollForActivityTask", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServicePollForActivityTaskResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn record_activity_task_heartbeat(&mut self, heartbeat_request: shared::RecordActivityTaskHeartbeatRequest) -> thrift::Result<shared::RecordActivityTaskHeartbeatResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("RecordActivityTaskHeartbeat", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServiceRecordActivityTaskHeartbeatArgs { heartbeat_request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("RecordActivityTaskHeartbeat", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServiceRecordActivityTaskHeartbeatResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn record_activity_task_heartbeat_by_i_d(&mut self, heartbeat_request: shared::RecordActivityTaskHeartbeatByIDRequest) -> thrift::Result<shared::RecordActivityTaskHeartbeatResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("RecordActivityTaskHeartbeatByID", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServiceRecordActivityTaskHeartbeatByIDArgs { heartbeat_request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("RecordActivityTaskHeartbeatByID", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServiceRecordActivityTaskHeartbeatByIDResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn respond_activity_task_completed(&mut self, complete_request: shared::RespondActivityTaskCompletedRequest) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("RespondActivityTaskCompleted", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServiceRespondActivityTaskCompletedArgs { complete_request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("RespondActivityTaskCompleted", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServiceRespondActivityTaskCompletedResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn respond_activity_task_completed_by_i_d(&mut self, complete_request: shared::RespondActivityTaskCompletedByIDRequest) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("RespondActivityTaskCompletedByID", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServiceRespondActivityTaskCompletedByIDArgs { complete_request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("RespondActivityTaskCompletedByID", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServiceRespondActivityTaskCompletedByIDResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn respond_activity_task_failed(&mut self, fail_request: shared::RespondActivityTaskFailedRequest) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("RespondActivityTaskFailed", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServiceRespondActivityTaskFailedArgs { fail_request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("RespondActivityTaskFailed", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServiceRespondActivityTaskFailedResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn respond_activity_task_failed_by_i_d(&mut self, fail_request: shared::RespondActivityTaskFailedByIDRequest) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("RespondActivityTaskFailedByID", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServiceRespondActivityTaskFailedByIDArgs { fail_request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("RespondActivityTaskFailedByID", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServiceRespondActivityTaskFailedByIDResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn respond_activity_task_canceled(&mut self, canceled_request: shared::RespondActivityTaskCanceledRequest) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("RespondActivityTaskCanceled", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServiceRespondActivityTaskCanceledArgs { canceled_request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("RespondActivityTaskCanceled", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServiceRespondActivityTaskCanceledResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn respond_activity_task_canceled_by_i_d(&mut self, canceled_request: shared::RespondActivityTaskCanceledByIDRequest) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("RespondActivityTaskCanceledByID", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServiceRespondActivityTaskCanceledByIDArgs { canceled_request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("RespondActivityTaskCanceledByID", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServiceRespondActivityTaskCanceledByIDResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn request_cancel_workflow_execution(&mut self, cancel_request: shared::RequestCancelWorkflowExecutionRequest) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("RequestCancelWorkflowExecution", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServiceRequestCancelWorkflowExecutionArgs { cancel_request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("RequestCancelWorkflowExecution", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServiceRequestCancelWorkflowExecutionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn signal_workflow_execution(&mut self, signal_request: shared::SignalWorkflowExecutionRequest) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SignalWorkflowExecution", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServiceSignalWorkflowExecutionArgs { signal_request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SignalWorkflowExecution", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServiceSignalWorkflowExecutionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn signal_with_start_workflow_execution(&mut self, signal_with_start_request: shared::SignalWithStartWorkflowExecutionRequest) -> thrift::Result<shared::StartWorkflowExecutionResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SignalWithStartWorkflowExecution", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServiceSignalWithStartWorkflowExecutionArgs { signal_with_start_request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SignalWithStartWorkflowExecution", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServiceSignalWithStartWorkflowExecutionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn signal_with_start_workflow_execution_async(&mut self, signal_with_start_request: shared::SignalWithStartWorkflowExecutionAsyncRequest) -> thrift::Result<shared::SignalWithStartWorkflowExecutionAsyncResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SignalWithStartWorkflowExecutionAsync", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServiceSignalWithStartWorkflowExecutionAsyncArgs { signal_with_start_request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SignalWithStartWorkflowExecutionAsync", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServiceSignalWithStartWorkflowExecutionAsyncResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn reset_workflow_execution(&mut self, reset_request: shared::ResetWorkflowExecutionRequest) -> thrift::Result<shared::ResetWorkflowExecutionResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("ResetWorkflowExecution", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServiceResetWorkflowExecutionArgs { reset_request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("ResetWorkflowExecution", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServiceResetWorkflowExecutionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn terminate_workflow_execution(&mut self, terminate_request: shared::TerminateWorkflowExecutionRequest) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("TerminateWorkflowExecution", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServiceTerminateWorkflowExecutionArgs { terminate_request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("TerminateWorkflowExecution", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServiceTerminateWorkflowExecutionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn list_open_workflow_executions(&mut self, list_request: shared::ListOpenWorkflowExecutionsRequest) -> thrift::Result<shared::ListOpenWorkflowExecutionsResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("ListOpenWorkflowExecutions", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServiceListOpenWorkflowExecutionsArgs { list_request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("ListOpenWorkflowExecutions", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServiceListOpenWorkflowExecutionsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn list_closed_workflow_executions(&mut self, list_request: shared::ListClosedWorkflowExecutionsRequest) -> thrift::Result<shared::ListClosedWorkflowExecutionsResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("ListClosedWorkflowExecutions", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServiceListClosedWorkflowExecutionsArgs { list_request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("ListClosedWorkflowExecutions", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServiceListClosedWorkflowExecutionsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn list_workflow_executions(&mut self, list_request: shared::ListWorkflowExecutionsRequest) -> thrift::Result<shared::ListWorkflowExecutionsResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("ListWorkflowExecutions", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServiceListWorkflowExecutionsArgs { list_request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("ListWorkflowExecutions", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServiceListWorkflowExecutionsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn list_archived_workflow_executions(&mut self, list_request: shared::ListArchivedWorkflowExecutionsRequest) -> thrift::Result<shared::ListArchivedWorkflowExecutionsResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("ListArchivedWorkflowExecutions", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServiceListArchivedWorkflowExecutionsArgs { list_request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("ListArchivedWorkflowExecutions", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServiceListArchivedWorkflowExecutionsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn scan_workflow_executions(&mut self, list_request: shared::ListWorkflowExecutionsRequest) -> thrift::Result<shared::ListWorkflowExecutionsResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("ScanWorkflowExecutions", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServiceScanWorkflowExecutionsArgs { list_request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("ScanWorkflowExecutions", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServiceScanWorkflowExecutionsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn count_workflow_executions(&mut self, count_request: shared::CountWorkflowExecutionsRequest) -> thrift::Result<shared::CountWorkflowExecutionsResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("CountWorkflowExecutions", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServiceCountWorkflowExecutionsArgs { count_request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("CountWorkflowExecutions", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServiceCountWorkflowExecutionsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_search_attributes(&mut self) -> thrift::Result<shared::GetSearchAttributesResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GetSearchAttributes", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServiceGetSearchAttributesArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GetSearchAttributes", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServiceGetSearchAttributesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn respond_query_task_completed(&mut self, complete_request: shared::RespondQueryTaskCompletedRequest) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("RespondQueryTaskCompleted", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServiceRespondQueryTaskCompletedArgs { complete_request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("RespondQueryTaskCompleted", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServiceRespondQueryTaskCompletedResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn reset_sticky_task_list(&mut self, reset_request: shared::ResetStickyTaskListRequest) -> thrift::Result<shared::ResetStickyTaskListResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("ResetStickyTaskList", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServiceResetStickyTaskListArgs { reset_request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("ResetStickyTaskList", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServiceResetStickyTaskListResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn query_workflow(&mut self, query_request: shared::QueryWorkflowRequest) -> thrift::Result<shared::QueryWorkflowResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("QueryWorkflow", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServiceQueryWorkflowArgs { query_request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("QueryWorkflow", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServiceQueryWorkflowResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn describe_workflow_execution(&mut self, describe_request: shared::DescribeWorkflowExecutionRequest) -> thrift::Result<shared::DescribeWorkflowExecutionResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("DescribeWorkflowExecution", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServiceDescribeWorkflowExecutionArgs { describe_request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("DescribeWorkflowExecution", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServiceDescribeWorkflowExecutionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn describe_task_list(&mut self, request: shared::DescribeTaskListRequest) -> thrift::Result<shared::DescribeTaskListResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("DescribeTaskList", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServiceDescribeTaskListArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("DescribeTaskList", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServiceDescribeTaskListResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_cluster_info(&mut self) -> thrift::Result<shared::ClusterInfo> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GetClusterInfo", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServiceGetClusterInfoArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GetClusterInfo", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServiceGetClusterInfoResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_task_lists_by_domain(&mut self, request: shared::GetTaskListsByDomainRequest) -> thrift::Result<shared::GetTaskListsByDomainResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GetTaskListsByDomain", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServiceGetTaskListsByDomainArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GetTaskListsByDomain", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServiceGetTaskListsByDomainResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn list_task_list_partitions(&mut self, request: shared::ListTaskListPartitionsRequest) -> thrift::Result<shared::ListTaskListPartitionsResponse> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("ListTaskListPartitions", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServiceListTaskListPartitionsArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("ListTaskListPartitions", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServiceListTaskListPartitionsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn refresh_workflow_tasks(&mut self, request: shared::RefreshWorkflowTasksRequest) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("RefreshWorkflowTasks", TMessageType::Call, self.sequence_number());
        let call_args = WorkflowServiceRefreshWorkflowTasksArgs { request };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("RefreshWorkflowTasks", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = WorkflowServiceRefreshWorkflowTasksResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
}

//
// WorkflowService service processor
//

/// WorkflowService API is exposed to provide support for long running applications.  Application is expected to call
/// StartWorkflowExecution to create an instance for each instance of long running workflow.  Such applications are expected
/// to have a worker which regularly polls for DecisionTask and ActivityTask from the WorkflowService.  For each
/// DecisionTask, application is expected to process the history of events for that session and respond back with next
/// decisions.  For each ActivityTask, application is expected to execute the actual logic for that task and respond back
/// with completion or failure.  Worker is expected to regularly heartbeat while activity task is running.
/// 
pub trait WorkflowServiceSyncHandler {
  /// RegisterDomain creates a new domain which can be used as a container for all resources.  Domain is a top level
  /// entity within Cadence, used as a container for all resources like workflow executions, tasklists, etc.  Domain
  /// acts as a sandbox and provides isolation for all resources within the domain.  All resources belongs to exactly one
  /// domain.
  /// 
  fn handle_register_domain(&self, register_request: shared::RegisterDomainRequest) -> thrift::Result<()>;
  /// DescribeDomain returns the information and configuration for a registered domain.
  /// 
  fn handle_describe_domain(&self, describe_request: shared::DescribeDomainRequest) -> thrift::Result<shared::DescribeDomainResponse>;
  /// ListDomains returns the information and configuration for all domains.
  /// 
  fn handle_list_domains(&self, list_request: shared::ListDomainsRequest) -> thrift::Result<shared::ListDomainsResponse>;
  /// UpdateDomain is used to update the information and configuration for a registered domain.
  /// 
  fn handle_update_domain(&self, update_request: shared::UpdateDomainRequest) -> thrift::Result<shared::UpdateDomainResponse>;
  /// FailoverDomain is used to failover a registered domain to different cluster.
  /// 
  fn handle_failover_domain(&self, failover_request: shared::FailoverDomainRequest) -> thrift::Result<shared::FailoverDomainResponse>;
  /// DeprecateDomain us used to update status of a registered domain to DEPRECATED.  Once the domain is deprecated
  /// it cannot be used to start new workflow executions.  Existing workflow executions will continue to run on
  /// deprecated domains.
  /// 
  fn handle_deprecate_domain(&self, deprecate_request: shared::DeprecateDomainRequest) -> thrift::Result<()>;
  /// DeleteDomain permanently removes a domain record. This operation:
  /// - Requires domain to be in DEPRECATED status
  /// - Cannot be performed on domains with running workflows
  /// - Is irreversible and removes all domain data
  /// - Requires proper permissions and security token
  /// 
  fn handle_delete_domain(&self, delete_request: shared::DeleteDomainRequest) -> thrift::Result<()>;
  /// ListFailoverHistory returns the history of failover events for a domain.
  /// 
  fn handle_list_failover_history(&self, list_request: shared::ListFailoverHistoryRequest) -> thrift::Result<shared::ListFailoverHistoryResponse>;
  /// RestartWorkflowExecution restarts a previous workflow
  /// If the workflow is currently running it will terminate and restart
  /// 
  fn handle_restart_workflow_execution(&self, restart_request: shared::RestartWorkflowExecutionRequest) -> thrift::Result<shared::RestartWorkflowExecutionResponse>;
  /// DiagnoseWorkflowExecution diagnoses a previous workflow execution
  /// 
  fn handle_diagnose_workflow_execution(&self, diagnose_request: shared::DiagnoseWorkflowExecutionRequest) -> thrift::Result<shared::DiagnoseWorkflowExecutionResponse>;
  /// StartWorkflowExecution starts a new long running workflow instance.  It will create the instance with
  /// 'WorkflowExecutionStarted' event in history and also schedule the first DecisionTask for the worker to make the
  /// first decision for this instance.  It will return 'WorkflowExecutionAlreadyStartedError', if an instance already
  /// exists with same workflowId.
  /// 
  fn handle_start_workflow_execution(&self, start_request: shared::StartWorkflowExecutionRequest) -> thrift::Result<shared::StartWorkflowExecutionResponse>;
  /// StartWorkflowExecutionAsync starts a new long running workflow instance asynchronously. It will push a StartWorkflowExecutionRequest to a queue
  /// and immediately return a response. The request will be processed by a separate consumer eventually.
  /// 
  fn handle_start_workflow_execution_async(&self, start_request: shared::StartWorkflowExecutionAsyncRequest) -> thrift::Result<shared::StartWorkflowExecutionAsyncResponse>;
  /// Returns the history of specified workflow execution.  It fails with 'EntityNotExistError' if speficied workflow
  /// execution in unknown to the service.
  /// 
  fn handle_get_workflow_execution_history(&self, get_request: shared::GetWorkflowExecutionHistoryRequest) -> thrift::Result<shared::GetWorkflowExecutionHistoryResponse>;
  /// PollForDecisionTask is called by application worker to process DecisionTask from a specific taskList.  A
  /// DecisionTask is dispatched to callers for active workflow executions, with pending decisions.
  /// Application is then expected to call 'RespondDecisionTaskCompleted' API when it is done processing the DecisionTask.
  /// It will also create a 'DecisionTaskStarted' event in the history for that session before handing off DecisionTask to
  /// application worker.
  /// 
  fn handle_poll_for_decision_task(&self, poll_request: shared::PollForDecisionTaskRequest) -> thrift::Result<shared::PollForDecisionTaskResponse>;
  /// RespondDecisionTaskCompleted is called by application worker to complete a DecisionTask handed as a result of
  /// 'PollForDecisionTask' API call.  Completing a DecisionTask will result in new events for the workflow execution and
  /// potentially new ActivityTask being created for corresponding decisions.  It will also create a DecisionTaskCompleted
  /// event in the history for that session.  Use the 'taskToken' provided as response of PollForDecisionTask API call
  /// for completing the DecisionTask.
  /// The response could contain a new decision task if there is one or if the request asking for one.
  /// 
  fn handle_respond_decision_task_completed(&self, complete_request: shared::RespondDecisionTaskCompletedRequest) -> thrift::Result<shared::RespondDecisionTaskCompletedResponse>;
  /// RespondDecisionTaskFailed is called by application worker to indicate failure.  This results in
  /// DecisionTaskFailedEvent written to the history and a new DecisionTask created.  This API can be used by client to
  /// either clear sticky tasklist or report any panics during DecisionTask processing.  Cadence will only append first
  /// DecisionTaskFailed event to the history of workflow execution for consecutive failures.
  /// 
  fn handle_respond_decision_task_failed(&self, failed_request: shared::RespondDecisionTaskFailedRequest) -> thrift::Result<()>;
  /// PollForActivityTask is called by application worker to process ActivityTask from a specific taskList.  ActivityTask
  /// is dispatched to callers whenever a ScheduleTask decision is made for a workflow execution.
  /// Application is expected to call 'RespondActivityTaskCompleted' or 'RespondActivityTaskFailed' once it is done
  /// processing the task.
  /// Application also needs to call 'RecordActivityTaskHeartbeat' API within 'heartbeatTimeoutSeconds' interval to
  /// prevent the task from getting timed out.  An event 'ActivityTaskStarted' event is also written to workflow execution
  /// history before the ActivityTask is dispatched to application worker.
  /// 
  fn handle_poll_for_activity_task(&self, poll_request: shared::PollForActivityTaskRequest) -> thrift::Result<shared::PollForActivityTaskResponse>;
  /// RecordActivityTaskHeartbeat is called by application worker while it is processing an ActivityTask.  If worker fails
  /// to heartbeat within 'heartbeatTimeoutSeconds' interval for the ActivityTask, then it will be marked as timedout and
  /// 'ActivityTaskTimedOut' event will be written to the workflow history.  Calling 'RecordActivityTaskHeartbeat' will
  /// fail with 'EntityNotExistsError' in such situations.  Use the 'taskToken' provided as response of
  /// PollForActivityTask API call for heartbeating.
  /// 
  fn handle_record_activity_task_heartbeat(&self, heartbeat_request: shared::RecordActivityTaskHeartbeatRequest) -> thrift::Result<shared::RecordActivityTaskHeartbeatResponse>;
  /// RecordActivityTaskHeartbeatByID is called by application worker while it is processing an ActivityTask.  If worker fails
  /// to heartbeat within 'heartbeatTimeoutSeconds' interval for the ActivityTask, then it will be marked as timedout and
  /// 'ActivityTaskTimedOut' event will be written to the workflow history.  Calling 'RecordActivityTaskHeartbeatByID' will
  /// fail with 'EntityNotExistsError' in such situations.  Instead of using 'taskToken' like in RecordActivityTaskHeartbeat,
  /// use Domain, WorkflowID and ActivityID
  /// 
  fn handle_record_activity_task_heartbeat_by_i_d(&self, heartbeat_request: shared::RecordActivityTaskHeartbeatByIDRequest) -> thrift::Result<shared::RecordActivityTaskHeartbeatResponse>;
  /// RespondActivityTaskCompleted is called by application worker when it is done processing an ActivityTask.  It will
  /// result in a new 'ActivityTaskCompleted' event being written to the workflow history and a new DecisionTask
  /// created for the workflow so new decisions could be made.  Use the 'taskToken' provided as response of
  /// PollForActivityTask API call for completion. It fails with 'EntityNotExistsError' if the taskToken is not valid
  /// anymore due to activity timeout.
  /// 
  fn handle_respond_activity_task_completed(&self, complete_request: shared::RespondActivityTaskCompletedRequest) -> thrift::Result<()>;
  /// RespondActivityTaskCompletedByID is called by application worker when it is done processing an ActivityTask.
  /// It will result in a new 'ActivityTaskCompleted' event being written to the workflow history and a new DecisionTask
  /// created for the workflow so new decisions could be made.  Similar to RespondActivityTaskCompleted but use Domain,
  /// WorkflowID and ActivityID instead of 'taskToken' for completion. It fails with 'EntityNotExistsError'
  /// if the these IDs are not valid anymore due to activity timeout.
  /// 
  fn handle_respond_activity_task_completed_by_i_d(&self, complete_request: shared::RespondActivityTaskCompletedByIDRequest) -> thrift::Result<()>;
  /// RespondActivityTaskFailed is called by application worker when it is done processing an ActivityTask.  It will
  /// result in a new 'ActivityTaskFailed' event being written to the workflow history and a new DecisionTask
  /// created for the workflow instance so new decisions could be made.  Use the 'taskToken' provided as response of
  /// PollForActivityTask API call for completion. It fails with 'EntityNotExistsError' if the taskToken is not valid
  /// anymore due to activity timeout.
  /// 
  fn handle_respond_activity_task_failed(&self, fail_request: shared::RespondActivityTaskFailedRequest) -> thrift::Result<()>;
  /// RespondActivityTaskFailedByID is called by application worker when it is done processing an ActivityTask.
  /// It will result in a new 'ActivityTaskFailed' event being written to the workflow history and a new DecisionTask
  /// created for the workflow instance so new decisions could be made.  Similar to RespondActivityTaskFailed but use
  /// Domain, WorkflowID and ActivityID instead of 'taskToken' for completion. It fails with 'EntityNotExistsError'
  /// if the these IDs are not valid anymore due to activity timeout.
  /// 
  fn handle_respond_activity_task_failed_by_i_d(&self, fail_request: shared::RespondActivityTaskFailedByIDRequest) -> thrift::Result<()>;
  /// RespondActivityTaskCanceled is called by application worker when it is successfully canceled an ActivityTask.  It will
  /// result in a new 'ActivityTaskCanceled' event being written to the workflow history and a new DecisionTask
  /// created for the workflow instance so new decisions could be made.  Use the 'taskToken' provided as response of
  /// PollForActivityTask API call for completion. It fails with 'EntityNotExistsError' if the taskToken is not valid
  /// anymore due to activity timeout.
  /// 
  fn handle_respond_activity_task_canceled(&self, canceled_request: shared::RespondActivityTaskCanceledRequest) -> thrift::Result<()>;
  /// RespondActivityTaskCanceledByID is called by application worker when it is successfully canceled an ActivityTask.
  /// It will result in a new 'ActivityTaskCanceled' event being written to the workflow history and a new DecisionTask
  /// created for the workflow instance so new decisions could be made.  Similar to RespondActivityTaskCanceled but use
  /// Domain, WorkflowID and ActivityID instead of 'taskToken' for completion. It fails with 'EntityNotExistsError'
  /// if the these IDs are not valid anymore due to activity timeout.
  /// 
  fn handle_respond_activity_task_canceled_by_i_d(&self, canceled_request: shared::RespondActivityTaskCanceledByIDRequest) -> thrift::Result<()>;
  /// RequestCancelWorkflowExecution is called by application worker when it wants to request cancellation of a workflow instance.
  /// It will result in a new 'WorkflowExecutionCancelRequested' event being written to the workflow history and a new DecisionTask
  /// created for the workflow instance so new decisions could be made. It fails with 'EntityNotExistsError' if the workflow is not valid
  /// anymore due to completion or doesn't exist.
  /// 
  fn handle_request_cancel_workflow_execution(&self, cancel_request: shared::RequestCancelWorkflowExecutionRequest) -> thrift::Result<()>;
  /// SignalWorkflowExecution is used to send a signal event to running workflow execution.  This results in
  /// WorkflowExecutionSignaled event recorded in the history and a decision task being created for the execution.
  /// 
  fn handle_signal_workflow_execution(&self, signal_request: shared::SignalWorkflowExecutionRequest) -> thrift::Result<()>;
  /// SignalWithStartWorkflowExecution is used to ensure sending signal to a workflow.
  /// If the workflow is running, this results in WorkflowExecutionSignaled event being recorded in the history
  /// and a decision task being created for the execution.
  /// If the workflow is not running or not found, this results in WorkflowExecutionStarted and WorkflowExecutionSignaled
  /// events being recorded in history, and a decision task being created for the execution
  /// 
  fn handle_signal_with_start_workflow_execution(&self, signal_with_start_request: shared::SignalWithStartWorkflowExecutionRequest) -> thrift::Result<shared::StartWorkflowExecutionResponse>;
  /// SignalWithStartWorkflowExecutionAsync is used to ensure sending signal to a workflow asynchronously.  It will push a SignalWithStartWorkflowExecutionRequest to a queue
  /// and immediately return a response. The request will be processed by a separate consumer eventually.
  /// 
  fn handle_signal_with_start_workflow_execution_async(&self, signal_with_start_request: shared::SignalWithStartWorkflowExecutionAsyncRequest) -> thrift::Result<shared::SignalWithStartWorkflowExecutionAsyncResponse>;
  /// ResetWorkflowExecution reset an existing workflow execution to DecisionTaskCompleted event(exclusive).
  /// And it will immediately terminating the current execution instance.
  /// 
  fn handle_reset_workflow_execution(&self, reset_request: shared::ResetWorkflowExecutionRequest) -> thrift::Result<shared::ResetWorkflowExecutionResponse>;
  /// TerminateWorkflowExecution terminates an existing workflow execution by recording WorkflowExecutionTerminated event
  /// in the history and immediately terminating the execution instance.
  /// 
  fn handle_terminate_workflow_execution(&self, terminate_request: shared::TerminateWorkflowExecutionRequest) -> thrift::Result<()>;
  /// ListOpenWorkflowExecutions is a visibility API to list the open executions in a specific domain.
  /// 
  fn handle_list_open_workflow_executions(&self, list_request: shared::ListOpenWorkflowExecutionsRequest) -> thrift::Result<shared::ListOpenWorkflowExecutionsResponse>;
  /// ListClosedWorkflowExecutions is a visibility API to list the closed executions in a specific domain.
  /// 
  fn handle_list_closed_workflow_executions(&self, list_request: shared::ListClosedWorkflowExecutionsRequest) -> thrift::Result<shared::ListClosedWorkflowExecutionsResponse>;
  /// ListWorkflowExecutions is a visibility API to list workflow executions in a specific domain.
  /// 
  fn handle_list_workflow_executions(&self, list_request: shared::ListWorkflowExecutionsRequest) -> thrift::Result<shared::ListWorkflowExecutionsResponse>;
  /// ListArchivedWorkflowExecutions is a visibility API to list archived workflow executions in a specific domain.
  /// 
  fn handle_list_archived_workflow_executions(&self, list_request: shared::ListArchivedWorkflowExecutionsRequest) -> thrift::Result<shared::ListArchivedWorkflowExecutionsResponse>;
  /// ScanWorkflowExecutions is a visibility API to list large amount of workflow executions in a specific domain without order.
  /// 
  fn handle_scan_workflow_executions(&self, list_request: shared::ListWorkflowExecutionsRequest) -> thrift::Result<shared::ListWorkflowExecutionsResponse>;
  /// CountWorkflowExecutions is a visibility API to count of workflow executions in a specific domain.
  /// 
  fn handle_count_workflow_executions(&self, count_request: shared::CountWorkflowExecutionsRequest) -> thrift::Result<shared::CountWorkflowExecutionsResponse>;
  /// GetSearchAttributes is a visibility API to get all legal keys that could be used in list APIs
  /// 
  fn handle_get_search_attributes(&self) -> thrift::Result<shared::GetSearchAttributesResponse>;
  /// RespondQueryTaskCompleted is called by application worker to complete a QueryTask (which is a DecisionTask for query)
  /// as a result of 'PollForDecisionTask' API call. Completing a QueryTask will unblock the client call to 'QueryWorkflow'
  /// API and return the query result to client as a response to 'QueryWorkflow' API call.
  /// 
  fn handle_respond_query_task_completed(&self, complete_request: shared::RespondQueryTaskCompletedRequest) -> thrift::Result<()>;
  /// Reset the sticky tasklist related information in mutable state of a given workflow.
  /// Things cleared are:
  /// 1. StickyTaskList
  /// 2. StickyScheduleToStartTimeout
  /// 3. ClientLibraryVersion
  /// 4. ClientFeatureVersion
  /// 5. ClientImpl
  /// 
  fn handle_reset_sticky_task_list(&self, reset_request: shared::ResetStickyTaskListRequest) -> thrift::Result<shared::ResetStickyTaskListResponse>;
  /// QueryWorkflow returns query result for a specified workflow execution
  /// 
  fn handle_query_workflow(&self, query_request: shared::QueryWorkflowRequest) -> thrift::Result<shared::QueryWorkflowResponse>;
  /// DescribeWorkflowExecution returns information about the specified workflow execution.
  /// 
  fn handle_describe_workflow_execution(&self, describe_request: shared::DescribeWorkflowExecutionRequest) -> thrift::Result<shared::DescribeWorkflowExecutionResponse>;
  /// DescribeTaskList returns information about the target tasklist, right now this API returns the
  /// pollers which polled this tasklist in last few minutes.
  /// 
  fn handle_describe_task_list(&self, request: shared::DescribeTaskListRequest) -> thrift::Result<shared::DescribeTaskListResponse>;
  /// GetClusterInfo returns information about cadence cluster
  /// 
  fn handle_get_cluster_info(&self) -> thrift::Result<shared::ClusterInfo>;
  /// GetTaskListsByDomain returns the list of all the task lists for a domainName.
  /// 
  fn handle_get_task_lists_by_domain(&self, request: shared::GetTaskListsByDomainRequest) -> thrift::Result<shared::GetTaskListsByDomainResponse>;
  /// ReapplyEvents applies stale events to the current workflow and current run
  /// 
  fn handle_list_task_list_partitions(&self, request: shared::ListTaskListPartitionsRequest) -> thrift::Result<shared::ListTaskListPartitionsResponse>;
  /// RefreshWorkflowTasks refreshes all tasks of a workflow
  /// 
  fn handle_refresh_workflow_tasks(&self, request: shared::RefreshWorkflowTasksRequest) -> thrift::Result<()>;
}

pub struct WorkflowServiceSyncProcessor<H: WorkflowServiceSyncHandler> {
  handler: H,
}

impl <H: WorkflowServiceSyncHandler> WorkflowServiceSyncProcessor<H> {
  pub fn new(handler: H) -> WorkflowServiceSyncProcessor<H> {
    WorkflowServiceSyncProcessor {
      handler,
    }
  }
  fn process_register_domain(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_register_domain(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_describe_domain(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_describe_domain(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_list_domains(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_list_domains(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_domain(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_update_domain(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_failover_domain(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_failover_domain(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_deprecate_domain(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_deprecate_domain(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_delete_domain(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_delete_domain(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_list_failover_history(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_list_failover_history(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_restart_workflow_execution(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_restart_workflow_execution(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_diagnose_workflow_execution(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_diagnose_workflow_execution(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_start_workflow_execution(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_start_workflow_execution(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_start_workflow_execution_async(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_start_workflow_execution_async(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_workflow_execution_history(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_get_workflow_execution_history(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_poll_for_decision_task(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_poll_for_decision_task(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_respond_decision_task_completed(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_respond_decision_task_completed(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_respond_decision_task_failed(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_respond_decision_task_failed(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_poll_for_activity_task(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_poll_for_activity_task(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_record_activity_task_heartbeat(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_record_activity_task_heartbeat(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_record_activity_task_heartbeat_by_i_d(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_record_activity_task_heartbeat_by_i_d(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_respond_activity_task_completed(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_respond_activity_task_completed(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_respond_activity_task_completed_by_i_d(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_respond_activity_task_completed_by_i_d(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_respond_activity_task_failed(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_respond_activity_task_failed(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_respond_activity_task_failed_by_i_d(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_respond_activity_task_failed_by_i_d(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_respond_activity_task_canceled(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_respond_activity_task_canceled(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_respond_activity_task_canceled_by_i_d(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_respond_activity_task_canceled_by_i_d(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_request_cancel_workflow_execution(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_request_cancel_workflow_execution(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_signal_workflow_execution(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_signal_workflow_execution(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_signal_with_start_workflow_execution(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_signal_with_start_workflow_execution(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_signal_with_start_workflow_execution_async(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_signal_with_start_workflow_execution_async(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_reset_workflow_execution(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_reset_workflow_execution(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_terminate_workflow_execution(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_terminate_workflow_execution(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_list_open_workflow_executions(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_list_open_workflow_executions(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_list_closed_workflow_executions(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_list_closed_workflow_executions(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_list_workflow_executions(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_list_workflow_executions(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_list_archived_workflow_executions(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_list_archived_workflow_executions(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_scan_workflow_executions(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_scan_workflow_executions(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_count_workflow_executions(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_count_workflow_executions(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_search_attributes(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_get_search_attributes(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_respond_query_task_completed(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_respond_query_task_completed(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_reset_sticky_task_list(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_reset_sticky_task_list(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_query_workflow(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_query_workflow(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_describe_workflow_execution(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_describe_workflow_execution(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_describe_task_list(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_describe_task_list(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_cluster_info(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_get_cluster_info(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_task_lists_by_domain(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_get_task_lists_by_domain(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_list_task_list_partitions(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_list_task_list_partitions(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_refresh_workflow_tasks(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TWorkflowServiceProcessFunctions::process_refresh_workflow_tasks(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
}

pub struct TWorkflowServiceProcessFunctions;

impl TWorkflowServiceProcessFunctions {
  pub fn process_register_domain<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = WorkflowServiceRegisterDomainArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_register_domain(args.register_request) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("RegisterDomain", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServiceRegisterDomainResult { bad_request_error: None, domain_exists_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::BadRequestError>().is_some() {
              let err = usr_err.downcast::<shared::BadRequestError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRegisterDomainResult{ bad_request_error: Some(*err), domain_exists_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RegisterDomain", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::DomainAlreadyExistsError>().is_some() {
              let err = usr_err.downcast::<shared::DomainAlreadyExistsError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRegisterDomainResult{ bad_request_error: None, domain_exists_error: Some(*err), service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RegisterDomain", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRegisterDomainResult{ bad_request_error: None, domain_exists_error: None, service_busy_error: Some(*err), client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RegisterDomain", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ClientVersionNotSupportedError>().is_some() {
              let err = usr_err.downcast::<shared::ClientVersionNotSupportedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRegisterDomainResult{ bad_request_error: None, domain_exists_error: None, service_busy_error: None, client_version_not_supported_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RegisterDomain", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRegisterDomainResult{ bad_request_error: None, domain_exists_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("RegisterDomain", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("RegisterDomain", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("RegisterDomain", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("RegisterDomain", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_describe_domain<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = WorkflowServiceDescribeDomainArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_describe_domain(args.describe_request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("DescribeDomain", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServiceDescribeDomainResult { result_value: Some(handler_return), bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::BadRequestError>().is_some() {
              let err = usr_err.downcast::<shared::BadRequestError>().expect("downcast already checked");
              let ret_err = WorkflowServiceDescribeDomainResult{ result_value: None, bad_request_error: Some(*err), entity_not_exist_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("DescribeDomain", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::EntityNotExistsError>().is_some() {
              let err = usr_err.downcast::<shared::EntityNotExistsError>().expect("downcast already checked");
              let ret_err = WorkflowServiceDescribeDomainResult{ result_value: None, bad_request_error: None, entity_not_exist_error: Some(*err), service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("DescribeDomain", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServiceDescribeDomainResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: Some(*err), client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("DescribeDomain", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ClientVersionNotSupportedError>().is_some() {
              let err = usr_err.downcast::<shared::ClientVersionNotSupportedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceDescribeDomainResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, client_version_not_supported_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("DescribeDomain", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceDescribeDomainResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("DescribeDomain", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("DescribeDomain", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("DescribeDomain", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("DescribeDomain", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_list_domains<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = WorkflowServiceListDomainsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_list_domains(args.list_request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("ListDomains", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServiceListDomainsResult { result_value: Some(handler_return), bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::BadRequestError>().is_some() {
              let err = usr_err.downcast::<shared::BadRequestError>().expect("downcast already checked");
              let ret_err = WorkflowServiceListDomainsResult{ result_value: None, bad_request_error: Some(*err), entity_not_exist_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("ListDomains", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::EntityNotExistsError>().is_some() {
              let err = usr_err.downcast::<shared::EntityNotExistsError>().expect("downcast already checked");
              let ret_err = WorkflowServiceListDomainsResult{ result_value: None, bad_request_error: None, entity_not_exist_error: Some(*err), service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("ListDomains", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServiceListDomainsResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: Some(*err), client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("ListDomains", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ClientVersionNotSupportedError>().is_some() {
              let err = usr_err.downcast::<shared::ClientVersionNotSupportedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceListDomainsResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, client_version_not_supported_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("ListDomains", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceListDomainsResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("ListDomains", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("ListDomains", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("ListDomains", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("ListDomains", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_domain<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = WorkflowServiceUpdateDomainArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update_domain(args.update_request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("UpdateDomain", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServiceUpdateDomainResult { result_value: Some(handler_return), bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, domain_not_active_error: None, client_version_not_supported_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::BadRequestError>().is_some() {
              let err = usr_err.downcast::<shared::BadRequestError>().expect("downcast already checked");
              let ret_err = WorkflowServiceUpdateDomainResult{ result_value: None, bad_request_error: Some(*err), entity_not_exist_error: None, service_busy_error: None, domain_not_active_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("UpdateDomain", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::EntityNotExistsError>().is_some() {
              let err = usr_err.downcast::<shared::EntityNotExistsError>().expect("downcast already checked");
              let ret_err = WorkflowServiceUpdateDomainResult{ result_value: None, bad_request_error: None, entity_not_exist_error: Some(*err), service_busy_error: None, domain_not_active_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("UpdateDomain", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServiceUpdateDomainResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: Some(*err), domain_not_active_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("UpdateDomain", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::DomainNotActiveError>().is_some() {
              let err = usr_err.downcast::<shared::DomainNotActiveError>().expect("downcast already checked");
              let ret_err = WorkflowServiceUpdateDomainResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, domain_not_active_error: Some(*err), client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("UpdateDomain", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ClientVersionNotSupportedError>().is_some() {
              let err = usr_err.downcast::<shared::ClientVersionNotSupportedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceUpdateDomainResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, domain_not_active_error: None, client_version_not_supported_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("UpdateDomain", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceUpdateDomainResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, domain_not_active_error: None, client_version_not_supported_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("UpdateDomain", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("UpdateDomain", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("UpdateDomain", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("UpdateDomain", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_failover_domain<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = WorkflowServiceFailoverDomainArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_failover_domain(args.failover_request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("FailoverDomain", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServiceFailoverDomainResult { result_value: Some(handler_return), bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, domain_not_active_error: None, client_version_not_supported_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::BadRequestError>().is_some() {
              let err = usr_err.downcast::<shared::BadRequestError>().expect("downcast already checked");
              let ret_err = WorkflowServiceFailoverDomainResult{ result_value: None, bad_request_error: Some(*err), entity_not_exist_error: None, service_busy_error: None, domain_not_active_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("FailoverDomain", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::EntityNotExistsError>().is_some() {
              let err = usr_err.downcast::<shared::EntityNotExistsError>().expect("downcast already checked");
              let ret_err = WorkflowServiceFailoverDomainResult{ result_value: None, bad_request_error: None, entity_not_exist_error: Some(*err), service_busy_error: None, domain_not_active_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("FailoverDomain", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServiceFailoverDomainResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: Some(*err), domain_not_active_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("FailoverDomain", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::DomainNotActiveError>().is_some() {
              let err = usr_err.downcast::<shared::DomainNotActiveError>().expect("downcast already checked");
              let ret_err = WorkflowServiceFailoverDomainResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, domain_not_active_error: Some(*err), client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("FailoverDomain", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ClientVersionNotSupportedError>().is_some() {
              let err = usr_err.downcast::<shared::ClientVersionNotSupportedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceFailoverDomainResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, domain_not_active_error: None, client_version_not_supported_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("FailoverDomain", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceFailoverDomainResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, domain_not_active_error: None, client_version_not_supported_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("FailoverDomain", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("FailoverDomain", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("FailoverDomain", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("FailoverDomain", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_deprecate_domain<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = WorkflowServiceDeprecateDomainArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_deprecate_domain(args.deprecate_request) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("DeprecateDomain", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServiceDeprecateDomainResult { bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, domain_not_active_error: None, client_version_not_supported_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::BadRequestError>().is_some() {
              let err = usr_err.downcast::<shared::BadRequestError>().expect("downcast already checked");
              let ret_err = WorkflowServiceDeprecateDomainResult{ bad_request_error: Some(*err), entity_not_exist_error: None, service_busy_error: None, domain_not_active_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("DeprecateDomain", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::EntityNotExistsError>().is_some() {
              let err = usr_err.downcast::<shared::EntityNotExistsError>().expect("downcast already checked");
              let ret_err = WorkflowServiceDeprecateDomainResult{ bad_request_error: None, entity_not_exist_error: Some(*err), service_busy_error: None, domain_not_active_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("DeprecateDomain", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServiceDeprecateDomainResult{ bad_request_error: None, entity_not_exist_error: None, service_busy_error: Some(*err), domain_not_active_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("DeprecateDomain", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::DomainNotActiveError>().is_some() {
              let err = usr_err.downcast::<shared::DomainNotActiveError>().expect("downcast already checked");
              let ret_err = WorkflowServiceDeprecateDomainResult{ bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, domain_not_active_error: Some(*err), client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("DeprecateDomain", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ClientVersionNotSupportedError>().is_some() {
              let err = usr_err.downcast::<shared::ClientVersionNotSupportedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceDeprecateDomainResult{ bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, domain_not_active_error: None, client_version_not_supported_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("DeprecateDomain", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceDeprecateDomainResult{ bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, domain_not_active_error: None, client_version_not_supported_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("DeprecateDomain", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("DeprecateDomain", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("DeprecateDomain", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("DeprecateDomain", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_delete_domain<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = WorkflowServiceDeleteDomainArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_delete_domain(args.delete_request) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("DeleteDomain", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServiceDeleteDomainResult { bad_request_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::BadRequestError>().is_some() {
              let err = usr_err.downcast::<shared::BadRequestError>().expect("downcast already checked");
              let ret_err = WorkflowServiceDeleteDomainResult{ bad_request_error: Some(*err), service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("DeleteDomain", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServiceDeleteDomainResult{ bad_request_error: None, service_busy_error: Some(*err), client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("DeleteDomain", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ClientVersionNotSupportedError>().is_some() {
              let err = usr_err.downcast::<shared::ClientVersionNotSupportedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceDeleteDomainResult{ bad_request_error: None, service_busy_error: None, client_version_not_supported_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("DeleteDomain", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceDeleteDomainResult{ bad_request_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("DeleteDomain", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("DeleteDomain", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("DeleteDomain", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("DeleteDomain", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_list_failover_history<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = WorkflowServiceListFailoverHistoryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_list_failover_history(args.list_request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("ListFailoverHistory", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServiceListFailoverHistoryResult { result_value: Some(handler_return), bad_request_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::BadRequestError>().is_some() {
              let err = usr_err.downcast::<shared::BadRequestError>().expect("downcast already checked");
              let ret_err = WorkflowServiceListFailoverHistoryResult{ result_value: None, bad_request_error: Some(*err), service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("ListFailoverHistory", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServiceListFailoverHistoryResult{ result_value: None, bad_request_error: None, service_busy_error: Some(*err), client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("ListFailoverHistory", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ClientVersionNotSupportedError>().is_some() {
              let err = usr_err.downcast::<shared::ClientVersionNotSupportedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceListFailoverHistoryResult{ result_value: None, bad_request_error: None, service_busy_error: None, client_version_not_supported_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("ListFailoverHistory", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceListFailoverHistoryResult{ result_value: None, bad_request_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("ListFailoverHistory", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("ListFailoverHistory", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("ListFailoverHistory", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("ListFailoverHistory", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_restart_workflow_execution<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = WorkflowServiceRestartWorkflowExecutionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_restart_workflow_execution(args.restart_request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("RestartWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServiceRestartWorkflowExecutionResult { result_value: Some(handler_return), bad_request_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, entity_not_exist_error: None, client_version_not_supported_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::BadRequestError>().is_some() {
              let err = usr_err.downcast::<shared::BadRequestError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRestartWorkflowExecutionResult{ result_value: None, bad_request_error: Some(*err), service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, entity_not_exist_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RestartWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRestartWorkflowExecutionResult{ result_value: None, bad_request_error: None, service_busy_error: Some(*err), domain_not_active_error: None, limit_exceeded_error: None, entity_not_exist_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RestartWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::DomainNotActiveError>().is_some() {
              let err = usr_err.downcast::<shared::DomainNotActiveError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRestartWorkflowExecutionResult{ result_value: None, bad_request_error: None, service_busy_error: None, domain_not_active_error: Some(*err), limit_exceeded_error: None, entity_not_exist_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RestartWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::LimitExceededError>().is_some() {
              let err = usr_err.downcast::<shared::LimitExceededError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRestartWorkflowExecutionResult{ result_value: None, bad_request_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: Some(*err), entity_not_exist_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RestartWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::EntityNotExistsError>().is_some() {
              let err = usr_err.downcast::<shared::EntityNotExistsError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRestartWorkflowExecutionResult{ result_value: None, bad_request_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, entity_not_exist_error: Some(*err), client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RestartWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ClientVersionNotSupportedError>().is_some() {
              let err = usr_err.downcast::<shared::ClientVersionNotSupportedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRestartWorkflowExecutionResult{ result_value: None, bad_request_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, entity_not_exist_error: None, client_version_not_supported_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RestartWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRestartWorkflowExecutionResult{ result_value: None, bad_request_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, entity_not_exist_error: None, client_version_not_supported_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("RestartWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("RestartWorkflowExecution", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("RestartWorkflowExecution", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("RestartWorkflowExecution", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_diagnose_workflow_execution<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = WorkflowServiceDiagnoseWorkflowExecutionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_diagnose_workflow_execution(args.diagnose_request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("DiagnoseWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServiceDiagnoseWorkflowExecutionResult { result_value: Some(handler_return), domain_not_active_error: None, service_busy_error: None, entity_not_exist_error: None, client_version_not_supported_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::DomainNotActiveError>().is_some() {
              let err = usr_err.downcast::<shared::DomainNotActiveError>().expect("downcast already checked");
              let ret_err = WorkflowServiceDiagnoseWorkflowExecutionResult{ result_value: None, domain_not_active_error: Some(*err), service_busy_error: None, entity_not_exist_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("DiagnoseWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServiceDiagnoseWorkflowExecutionResult{ result_value: None, domain_not_active_error: None, service_busy_error: Some(*err), entity_not_exist_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("DiagnoseWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::EntityNotExistsError>().is_some() {
              let err = usr_err.downcast::<shared::EntityNotExistsError>().expect("downcast already checked");
              let ret_err = WorkflowServiceDiagnoseWorkflowExecutionResult{ result_value: None, domain_not_active_error: None, service_busy_error: None, entity_not_exist_error: Some(*err), client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("DiagnoseWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ClientVersionNotSupportedError>().is_some() {
              let err = usr_err.downcast::<shared::ClientVersionNotSupportedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceDiagnoseWorkflowExecutionResult{ result_value: None, domain_not_active_error: None, service_busy_error: None, entity_not_exist_error: None, client_version_not_supported_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("DiagnoseWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceDiagnoseWorkflowExecutionResult{ result_value: None, domain_not_active_error: None, service_busy_error: None, entity_not_exist_error: None, client_version_not_supported_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("DiagnoseWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("DiagnoseWorkflowExecution", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("DiagnoseWorkflowExecution", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("DiagnoseWorkflowExecution", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_start_workflow_execution<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = WorkflowServiceStartWorkflowExecutionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_start_workflow_execution(args.start_request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("StartWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServiceStartWorkflowExecutionResult { result_value: Some(handler_return), bad_request_error: None, session_already_exist_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, entity_not_exist_error: None, client_version_not_supported_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::BadRequestError>().is_some() {
              let err = usr_err.downcast::<shared::BadRequestError>().expect("downcast already checked");
              let ret_err = WorkflowServiceStartWorkflowExecutionResult{ result_value: None, bad_request_error: Some(*err), session_already_exist_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, entity_not_exist_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("StartWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::WorkflowExecutionAlreadyStartedError>().is_some() {
              let err = usr_err.downcast::<shared::WorkflowExecutionAlreadyStartedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceStartWorkflowExecutionResult{ result_value: None, bad_request_error: None, session_already_exist_error: Some(*err), service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, entity_not_exist_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("StartWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServiceStartWorkflowExecutionResult{ result_value: None, bad_request_error: None, session_already_exist_error: None, service_busy_error: Some(*err), domain_not_active_error: None, limit_exceeded_error: None, entity_not_exist_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("StartWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::DomainNotActiveError>().is_some() {
              let err = usr_err.downcast::<shared::DomainNotActiveError>().expect("downcast already checked");
              let ret_err = WorkflowServiceStartWorkflowExecutionResult{ result_value: None, bad_request_error: None, session_already_exist_error: None, service_busy_error: None, domain_not_active_error: Some(*err), limit_exceeded_error: None, entity_not_exist_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("StartWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::LimitExceededError>().is_some() {
              let err = usr_err.downcast::<shared::LimitExceededError>().expect("downcast already checked");
              let ret_err = WorkflowServiceStartWorkflowExecutionResult{ result_value: None, bad_request_error: None, session_already_exist_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: Some(*err), entity_not_exist_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("StartWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::EntityNotExistsError>().is_some() {
              let err = usr_err.downcast::<shared::EntityNotExistsError>().expect("downcast already checked");
              let ret_err = WorkflowServiceStartWorkflowExecutionResult{ result_value: None, bad_request_error: None, session_already_exist_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, entity_not_exist_error: Some(*err), client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("StartWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ClientVersionNotSupportedError>().is_some() {
              let err = usr_err.downcast::<shared::ClientVersionNotSupportedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceStartWorkflowExecutionResult{ result_value: None, bad_request_error: None, session_already_exist_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, entity_not_exist_error: None, client_version_not_supported_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("StartWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceStartWorkflowExecutionResult{ result_value: None, bad_request_error: None, session_already_exist_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, entity_not_exist_error: None, client_version_not_supported_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("StartWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("StartWorkflowExecution", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("StartWorkflowExecution", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("StartWorkflowExecution", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_start_workflow_execution_async<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = WorkflowServiceStartWorkflowExecutionAsyncArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_start_workflow_execution_async(args.start_request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("StartWorkflowExecutionAsync", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServiceStartWorkflowExecutionAsyncResult { result_value: Some(handler_return), bad_request_error: None, session_already_exist_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, entity_not_exist_error: None, client_version_not_supported_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::BadRequestError>().is_some() {
              let err = usr_err.downcast::<shared::BadRequestError>().expect("downcast already checked");
              let ret_err = WorkflowServiceStartWorkflowExecutionAsyncResult{ result_value: None, bad_request_error: Some(*err), session_already_exist_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, entity_not_exist_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("StartWorkflowExecutionAsync", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::WorkflowExecutionAlreadyStartedError>().is_some() {
              let err = usr_err.downcast::<shared::WorkflowExecutionAlreadyStartedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceStartWorkflowExecutionAsyncResult{ result_value: None, bad_request_error: None, session_already_exist_error: Some(*err), service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, entity_not_exist_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("StartWorkflowExecutionAsync", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServiceStartWorkflowExecutionAsyncResult{ result_value: None, bad_request_error: None, session_already_exist_error: None, service_busy_error: Some(*err), domain_not_active_error: None, limit_exceeded_error: None, entity_not_exist_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("StartWorkflowExecutionAsync", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::DomainNotActiveError>().is_some() {
              let err = usr_err.downcast::<shared::DomainNotActiveError>().expect("downcast already checked");
              let ret_err = WorkflowServiceStartWorkflowExecutionAsyncResult{ result_value: None, bad_request_error: None, session_already_exist_error: None, service_busy_error: None, domain_not_active_error: Some(*err), limit_exceeded_error: None, entity_not_exist_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("StartWorkflowExecutionAsync", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::LimitExceededError>().is_some() {
              let err = usr_err.downcast::<shared::LimitExceededError>().expect("downcast already checked");
              let ret_err = WorkflowServiceStartWorkflowExecutionAsyncResult{ result_value: None, bad_request_error: None, session_already_exist_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: Some(*err), entity_not_exist_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("StartWorkflowExecutionAsync", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::EntityNotExistsError>().is_some() {
              let err = usr_err.downcast::<shared::EntityNotExistsError>().expect("downcast already checked");
              let ret_err = WorkflowServiceStartWorkflowExecutionAsyncResult{ result_value: None, bad_request_error: None, session_already_exist_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, entity_not_exist_error: Some(*err), client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("StartWorkflowExecutionAsync", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ClientVersionNotSupportedError>().is_some() {
              let err = usr_err.downcast::<shared::ClientVersionNotSupportedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceStartWorkflowExecutionAsyncResult{ result_value: None, bad_request_error: None, session_already_exist_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, entity_not_exist_error: None, client_version_not_supported_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("StartWorkflowExecutionAsync", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceStartWorkflowExecutionAsyncResult{ result_value: None, bad_request_error: None, session_already_exist_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, entity_not_exist_error: None, client_version_not_supported_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("StartWorkflowExecutionAsync", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("StartWorkflowExecutionAsync", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("StartWorkflowExecutionAsync", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("StartWorkflowExecutionAsync", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_workflow_execution_history<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = WorkflowServiceGetWorkflowExecutionHistoryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_workflow_execution_history(args.get_request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GetWorkflowExecutionHistory", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServiceGetWorkflowExecutionHistoryResult { result_value: Some(handler_return), bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::BadRequestError>().is_some() {
              let err = usr_err.downcast::<shared::BadRequestError>().expect("downcast already checked");
              let ret_err = WorkflowServiceGetWorkflowExecutionHistoryResult{ result_value: None, bad_request_error: Some(*err), entity_not_exist_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("GetWorkflowExecutionHistory", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::EntityNotExistsError>().is_some() {
              let err = usr_err.downcast::<shared::EntityNotExistsError>().expect("downcast already checked");
              let ret_err = WorkflowServiceGetWorkflowExecutionHistoryResult{ result_value: None, bad_request_error: None, entity_not_exist_error: Some(*err), service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("GetWorkflowExecutionHistory", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServiceGetWorkflowExecutionHistoryResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: Some(*err), client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("GetWorkflowExecutionHistory", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ClientVersionNotSupportedError>().is_some() {
              let err = usr_err.downcast::<shared::ClientVersionNotSupportedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceGetWorkflowExecutionHistoryResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, client_version_not_supported_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("GetWorkflowExecutionHistory", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceGetWorkflowExecutionHistoryResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("GetWorkflowExecutionHistory", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("GetWorkflowExecutionHistory", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GetWorkflowExecutionHistory", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("GetWorkflowExecutionHistory", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_poll_for_decision_task<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = WorkflowServicePollForDecisionTaskArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_poll_for_decision_task(args.poll_request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PollForDecisionTask", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServicePollForDecisionTaskResult { result_value: Some(handler_return), bad_request_error: None, service_busy_error: None, limit_exceeded_error: None, entity_not_exist_error: None, domain_not_active_error: None, client_version_not_supported_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::BadRequestError>().is_some() {
              let err = usr_err.downcast::<shared::BadRequestError>().expect("downcast already checked");
              let ret_err = WorkflowServicePollForDecisionTaskResult{ result_value: None, bad_request_error: Some(*err), service_busy_error: None, limit_exceeded_error: None, entity_not_exist_error: None, domain_not_active_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("PollForDecisionTask", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServicePollForDecisionTaskResult{ result_value: None, bad_request_error: None, service_busy_error: Some(*err), limit_exceeded_error: None, entity_not_exist_error: None, domain_not_active_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("PollForDecisionTask", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::LimitExceededError>().is_some() {
              let err = usr_err.downcast::<shared::LimitExceededError>().expect("downcast already checked");
              let ret_err = WorkflowServicePollForDecisionTaskResult{ result_value: None, bad_request_error: None, service_busy_error: None, limit_exceeded_error: Some(*err), entity_not_exist_error: None, domain_not_active_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("PollForDecisionTask", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::EntityNotExistsError>().is_some() {
              let err = usr_err.downcast::<shared::EntityNotExistsError>().expect("downcast already checked");
              let ret_err = WorkflowServicePollForDecisionTaskResult{ result_value: None, bad_request_error: None, service_busy_error: None, limit_exceeded_error: None, entity_not_exist_error: Some(*err), domain_not_active_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("PollForDecisionTask", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::DomainNotActiveError>().is_some() {
              let err = usr_err.downcast::<shared::DomainNotActiveError>().expect("downcast already checked");
              let ret_err = WorkflowServicePollForDecisionTaskResult{ result_value: None, bad_request_error: None, service_busy_error: None, limit_exceeded_error: None, entity_not_exist_error: None, domain_not_active_error: Some(*err), client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("PollForDecisionTask", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ClientVersionNotSupportedError>().is_some() {
              let err = usr_err.downcast::<shared::ClientVersionNotSupportedError>().expect("downcast already checked");
              let ret_err = WorkflowServicePollForDecisionTaskResult{ result_value: None, bad_request_error: None, service_busy_error: None, limit_exceeded_error: None, entity_not_exist_error: None, domain_not_active_error: None, client_version_not_supported_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("PollForDecisionTask", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServicePollForDecisionTaskResult{ result_value: None, bad_request_error: None, service_busy_error: None, limit_exceeded_error: None, entity_not_exist_error: None, domain_not_active_error: None, client_version_not_supported_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("PollForDecisionTask", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("PollForDecisionTask", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PollForDecisionTask", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("PollForDecisionTask", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_respond_decision_task_completed<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = WorkflowServiceRespondDecisionTaskCompletedArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_respond_decision_task_completed(args.complete_request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("RespondDecisionTaskCompleted", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServiceRespondDecisionTaskCompletedResult { result_value: Some(handler_return), bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::BadRequestError>().is_some() {
              let err = usr_err.downcast::<shared::BadRequestError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondDecisionTaskCompletedResult{ result_value: None, bad_request_error: Some(*err), entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondDecisionTaskCompleted", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::EntityNotExistsError>().is_some() {
              let err = usr_err.downcast::<shared::EntityNotExistsError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondDecisionTaskCompletedResult{ result_value: None, bad_request_error: None, entity_not_exist_error: Some(*err), domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondDecisionTaskCompleted", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::DomainNotActiveError>().is_some() {
              let err = usr_err.downcast::<shared::DomainNotActiveError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondDecisionTaskCompletedResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: Some(*err), limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondDecisionTaskCompleted", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::LimitExceededError>().is_some() {
              let err = usr_err.downcast::<shared::LimitExceededError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondDecisionTaskCompletedResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: Some(*err), service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondDecisionTaskCompleted", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondDecisionTaskCompletedResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: Some(*err), client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondDecisionTaskCompleted", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ClientVersionNotSupportedError>().is_some() {
              let err = usr_err.downcast::<shared::ClientVersionNotSupportedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondDecisionTaskCompletedResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: Some(*err), workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondDecisionTaskCompleted", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::WorkflowExecutionAlreadyCompletedError>().is_some() {
              let err = usr_err.downcast::<shared::WorkflowExecutionAlreadyCompletedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondDecisionTaskCompletedResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondDecisionTaskCompleted", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondDecisionTaskCompletedResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("RespondDecisionTaskCompleted", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("RespondDecisionTaskCompleted", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("RespondDecisionTaskCompleted", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("RespondDecisionTaskCompleted", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_respond_decision_task_failed<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = WorkflowServiceRespondDecisionTaskFailedArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_respond_decision_task_failed(args.failed_request) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("RespondDecisionTaskFailed", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServiceRespondDecisionTaskFailedResult { bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::BadRequestError>().is_some() {
              let err = usr_err.downcast::<shared::BadRequestError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondDecisionTaskFailedResult{ bad_request_error: Some(*err), entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondDecisionTaskFailed", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::EntityNotExistsError>().is_some() {
              let err = usr_err.downcast::<shared::EntityNotExistsError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondDecisionTaskFailedResult{ bad_request_error: None, entity_not_exist_error: Some(*err), domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondDecisionTaskFailed", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::DomainNotActiveError>().is_some() {
              let err = usr_err.downcast::<shared::DomainNotActiveError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondDecisionTaskFailedResult{ bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: Some(*err), limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondDecisionTaskFailed", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::LimitExceededError>().is_some() {
              let err = usr_err.downcast::<shared::LimitExceededError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondDecisionTaskFailedResult{ bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: Some(*err), service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondDecisionTaskFailed", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondDecisionTaskFailedResult{ bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: Some(*err), client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondDecisionTaskFailed", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ClientVersionNotSupportedError>().is_some() {
              let err = usr_err.downcast::<shared::ClientVersionNotSupportedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondDecisionTaskFailedResult{ bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: Some(*err), workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondDecisionTaskFailed", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::WorkflowExecutionAlreadyCompletedError>().is_some() {
              let err = usr_err.downcast::<shared::WorkflowExecutionAlreadyCompletedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondDecisionTaskFailedResult{ bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondDecisionTaskFailed", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondDecisionTaskFailedResult{ bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("RespondDecisionTaskFailed", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("RespondDecisionTaskFailed", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("RespondDecisionTaskFailed", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("RespondDecisionTaskFailed", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_poll_for_activity_task<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = WorkflowServicePollForActivityTaskArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_poll_for_activity_task(args.poll_request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PollForActivityTask", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServicePollForActivityTaskResult { result_value: Some(handler_return), bad_request_error: None, service_busy_error: None, limit_exceeded_error: None, entity_not_exist_error: None, domain_not_active_error: None, client_version_not_supported_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::BadRequestError>().is_some() {
              let err = usr_err.downcast::<shared::BadRequestError>().expect("downcast already checked");
              let ret_err = WorkflowServicePollForActivityTaskResult{ result_value: None, bad_request_error: Some(*err), service_busy_error: None, limit_exceeded_error: None, entity_not_exist_error: None, domain_not_active_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("PollForActivityTask", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServicePollForActivityTaskResult{ result_value: None, bad_request_error: None, service_busy_error: Some(*err), limit_exceeded_error: None, entity_not_exist_error: None, domain_not_active_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("PollForActivityTask", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::LimitExceededError>().is_some() {
              let err = usr_err.downcast::<shared::LimitExceededError>().expect("downcast already checked");
              let ret_err = WorkflowServicePollForActivityTaskResult{ result_value: None, bad_request_error: None, service_busy_error: None, limit_exceeded_error: Some(*err), entity_not_exist_error: None, domain_not_active_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("PollForActivityTask", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::EntityNotExistsError>().is_some() {
              let err = usr_err.downcast::<shared::EntityNotExistsError>().expect("downcast already checked");
              let ret_err = WorkflowServicePollForActivityTaskResult{ result_value: None, bad_request_error: None, service_busy_error: None, limit_exceeded_error: None, entity_not_exist_error: Some(*err), domain_not_active_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("PollForActivityTask", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::DomainNotActiveError>().is_some() {
              let err = usr_err.downcast::<shared::DomainNotActiveError>().expect("downcast already checked");
              let ret_err = WorkflowServicePollForActivityTaskResult{ result_value: None, bad_request_error: None, service_busy_error: None, limit_exceeded_error: None, entity_not_exist_error: None, domain_not_active_error: Some(*err), client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("PollForActivityTask", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ClientVersionNotSupportedError>().is_some() {
              let err = usr_err.downcast::<shared::ClientVersionNotSupportedError>().expect("downcast already checked");
              let ret_err = WorkflowServicePollForActivityTaskResult{ result_value: None, bad_request_error: None, service_busy_error: None, limit_exceeded_error: None, entity_not_exist_error: None, domain_not_active_error: None, client_version_not_supported_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("PollForActivityTask", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServicePollForActivityTaskResult{ result_value: None, bad_request_error: None, service_busy_error: None, limit_exceeded_error: None, entity_not_exist_error: None, domain_not_active_error: None, client_version_not_supported_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("PollForActivityTask", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("PollForActivityTask", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PollForActivityTask", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("PollForActivityTask", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_record_activity_task_heartbeat<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = WorkflowServiceRecordActivityTaskHeartbeatArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_record_activity_task_heartbeat(args.heartbeat_request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("RecordActivityTaskHeartbeat", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServiceRecordActivityTaskHeartbeatResult { result_value: Some(handler_return), bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::BadRequestError>().is_some() {
              let err = usr_err.downcast::<shared::BadRequestError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRecordActivityTaskHeartbeatResult{ result_value: None, bad_request_error: Some(*err), entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RecordActivityTaskHeartbeat", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::EntityNotExistsError>().is_some() {
              let err = usr_err.downcast::<shared::EntityNotExistsError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRecordActivityTaskHeartbeatResult{ result_value: None, bad_request_error: None, entity_not_exist_error: Some(*err), domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RecordActivityTaskHeartbeat", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::DomainNotActiveError>().is_some() {
              let err = usr_err.downcast::<shared::DomainNotActiveError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRecordActivityTaskHeartbeatResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: Some(*err), limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RecordActivityTaskHeartbeat", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::LimitExceededError>().is_some() {
              let err = usr_err.downcast::<shared::LimitExceededError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRecordActivityTaskHeartbeatResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: Some(*err), service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RecordActivityTaskHeartbeat", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRecordActivityTaskHeartbeatResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: Some(*err), client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RecordActivityTaskHeartbeat", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ClientVersionNotSupportedError>().is_some() {
              let err = usr_err.downcast::<shared::ClientVersionNotSupportedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRecordActivityTaskHeartbeatResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: Some(*err), workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RecordActivityTaskHeartbeat", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::WorkflowExecutionAlreadyCompletedError>().is_some() {
              let err = usr_err.downcast::<shared::WorkflowExecutionAlreadyCompletedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRecordActivityTaskHeartbeatResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RecordActivityTaskHeartbeat", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRecordActivityTaskHeartbeatResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("RecordActivityTaskHeartbeat", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("RecordActivityTaskHeartbeat", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("RecordActivityTaskHeartbeat", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("RecordActivityTaskHeartbeat", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_record_activity_task_heartbeat_by_i_d<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = WorkflowServiceRecordActivityTaskHeartbeatByIDArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_record_activity_task_heartbeat_by_i_d(args.heartbeat_request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("RecordActivityTaskHeartbeatByID", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServiceRecordActivityTaskHeartbeatByIDResult { result_value: Some(handler_return), bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::BadRequestError>().is_some() {
              let err = usr_err.downcast::<shared::BadRequestError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRecordActivityTaskHeartbeatByIDResult{ result_value: None, bad_request_error: Some(*err), entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RecordActivityTaskHeartbeatByID", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::EntityNotExistsError>().is_some() {
              let err = usr_err.downcast::<shared::EntityNotExistsError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRecordActivityTaskHeartbeatByIDResult{ result_value: None, bad_request_error: None, entity_not_exist_error: Some(*err), domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RecordActivityTaskHeartbeatByID", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::DomainNotActiveError>().is_some() {
              let err = usr_err.downcast::<shared::DomainNotActiveError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRecordActivityTaskHeartbeatByIDResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: Some(*err), limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RecordActivityTaskHeartbeatByID", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::LimitExceededError>().is_some() {
              let err = usr_err.downcast::<shared::LimitExceededError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRecordActivityTaskHeartbeatByIDResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: Some(*err), service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RecordActivityTaskHeartbeatByID", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRecordActivityTaskHeartbeatByIDResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: Some(*err), client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RecordActivityTaskHeartbeatByID", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ClientVersionNotSupportedError>().is_some() {
              let err = usr_err.downcast::<shared::ClientVersionNotSupportedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRecordActivityTaskHeartbeatByIDResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: Some(*err), workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RecordActivityTaskHeartbeatByID", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::WorkflowExecutionAlreadyCompletedError>().is_some() {
              let err = usr_err.downcast::<shared::WorkflowExecutionAlreadyCompletedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRecordActivityTaskHeartbeatByIDResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RecordActivityTaskHeartbeatByID", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRecordActivityTaskHeartbeatByIDResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("RecordActivityTaskHeartbeatByID", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("RecordActivityTaskHeartbeatByID", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("RecordActivityTaskHeartbeatByID", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("RecordActivityTaskHeartbeatByID", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_respond_activity_task_completed<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = WorkflowServiceRespondActivityTaskCompletedArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_respond_activity_task_completed(args.complete_request) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("RespondActivityTaskCompleted", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServiceRespondActivityTaskCompletedResult { bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::BadRequestError>().is_some() {
              let err = usr_err.downcast::<shared::BadRequestError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskCompletedResult{ bad_request_error: Some(*err), entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskCompleted", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::EntityNotExistsError>().is_some() {
              let err = usr_err.downcast::<shared::EntityNotExistsError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskCompletedResult{ bad_request_error: None, entity_not_exist_error: Some(*err), domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskCompleted", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::DomainNotActiveError>().is_some() {
              let err = usr_err.downcast::<shared::DomainNotActiveError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskCompletedResult{ bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: Some(*err), limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskCompleted", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::LimitExceededError>().is_some() {
              let err = usr_err.downcast::<shared::LimitExceededError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskCompletedResult{ bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: Some(*err), service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskCompleted", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskCompletedResult{ bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: Some(*err), client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskCompleted", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ClientVersionNotSupportedError>().is_some() {
              let err = usr_err.downcast::<shared::ClientVersionNotSupportedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskCompletedResult{ bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: Some(*err), workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskCompleted", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::WorkflowExecutionAlreadyCompletedError>().is_some() {
              let err = usr_err.downcast::<shared::WorkflowExecutionAlreadyCompletedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskCompletedResult{ bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskCompleted", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskCompletedResult{ bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskCompleted", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskCompleted", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("RespondActivityTaskCompleted", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("RespondActivityTaskCompleted", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_respond_activity_task_completed_by_i_d<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = WorkflowServiceRespondActivityTaskCompletedByIDArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_respond_activity_task_completed_by_i_d(args.complete_request) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("RespondActivityTaskCompletedByID", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServiceRespondActivityTaskCompletedByIDResult { bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::BadRequestError>().is_some() {
              let err = usr_err.downcast::<shared::BadRequestError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskCompletedByIDResult{ bad_request_error: Some(*err), entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskCompletedByID", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::EntityNotExistsError>().is_some() {
              let err = usr_err.downcast::<shared::EntityNotExistsError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskCompletedByIDResult{ bad_request_error: None, entity_not_exist_error: Some(*err), domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskCompletedByID", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::DomainNotActiveError>().is_some() {
              let err = usr_err.downcast::<shared::DomainNotActiveError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskCompletedByIDResult{ bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: Some(*err), limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskCompletedByID", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::LimitExceededError>().is_some() {
              let err = usr_err.downcast::<shared::LimitExceededError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskCompletedByIDResult{ bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: Some(*err), service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskCompletedByID", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskCompletedByIDResult{ bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: Some(*err), client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskCompletedByID", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ClientVersionNotSupportedError>().is_some() {
              let err = usr_err.downcast::<shared::ClientVersionNotSupportedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskCompletedByIDResult{ bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: Some(*err), workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskCompletedByID", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::WorkflowExecutionAlreadyCompletedError>().is_some() {
              let err = usr_err.downcast::<shared::WorkflowExecutionAlreadyCompletedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskCompletedByIDResult{ bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskCompletedByID", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskCompletedByIDResult{ bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskCompletedByID", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskCompletedByID", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("RespondActivityTaskCompletedByID", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("RespondActivityTaskCompletedByID", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_respond_activity_task_failed<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = WorkflowServiceRespondActivityTaskFailedArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_respond_activity_task_failed(args.fail_request) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("RespondActivityTaskFailed", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServiceRespondActivityTaskFailedResult { bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::BadRequestError>().is_some() {
              let err = usr_err.downcast::<shared::BadRequestError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskFailedResult{ bad_request_error: Some(*err), entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskFailed", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::EntityNotExistsError>().is_some() {
              let err = usr_err.downcast::<shared::EntityNotExistsError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskFailedResult{ bad_request_error: None, entity_not_exist_error: Some(*err), domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskFailed", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::DomainNotActiveError>().is_some() {
              let err = usr_err.downcast::<shared::DomainNotActiveError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskFailedResult{ bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: Some(*err), limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskFailed", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::LimitExceededError>().is_some() {
              let err = usr_err.downcast::<shared::LimitExceededError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskFailedResult{ bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: Some(*err), service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskFailed", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskFailedResult{ bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: Some(*err), client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskFailed", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ClientVersionNotSupportedError>().is_some() {
              let err = usr_err.downcast::<shared::ClientVersionNotSupportedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskFailedResult{ bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: Some(*err), workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskFailed", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::WorkflowExecutionAlreadyCompletedError>().is_some() {
              let err = usr_err.downcast::<shared::WorkflowExecutionAlreadyCompletedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskFailedResult{ bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskFailed", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskFailedResult{ bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskFailed", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskFailed", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("RespondActivityTaskFailed", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("RespondActivityTaskFailed", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_respond_activity_task_failed_by_i_d<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = WorkflowServiceRespondActivityTaskFailedByIDArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_respond_activity_task_failed_by_i_d(args.fail_request) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("RespondActivityTaskFailedByID", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServiceRespondActivityTaskFailedByIDResult { bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::BadRequestError>().is_some() {
              let err = usr_err.downcast::<shared::BadRequestError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskFailedByIDResult{ bad_request_error: Some(*err), entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskFailedByID", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::EntityNotExistsError>().is_some() {
              let err = usr_err.downcast::<shared::EntityNotExistsError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskFailedByIDResult{ bad_request_error: None, entity_not_exist_error: Some(*err), domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskFailedByID", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::DomainNotActiveError>().is_some() {
              let err = usr_err.downcast::<shared::DomainNotActiveError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskFailedByIDResult{ bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: Some(*err), limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskFailedByID", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::LimitExceededError>().is_some() {
              let err = usr_err.downcast::<shared::LimitExceededError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskFailedByIDResult{ bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: Some(*err), service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskFailedByID", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskFailedByIDResult{ bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: Some(*err), client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskFailedByID", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ClientVersionNotSupportedError>().is_some() {
              let err = usr_err.downcast::<shared::ClientVersionNotSupportedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskFailedByIDResult{ bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: Some(*err), workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskFailedByID", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::WorkflowExecutionAlreadyCompletedError>().is_some() {
              let err = usr_err.downcast::<shared::WorkflowExecutionAlreadyCompletedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskFailedByIDResult{ bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskFailedByID", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskFailedByIDResult{ bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskFailedByID", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskFailedByID", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("RespondActivityTaskFailedByID", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("RespondActivityTaskFailedByID", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_respond_activity_task_canceled<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = WorkflowServiceRespondActivityTaskCanceledArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_respond_activity_task_canceled(args.canceled_request) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("RespondActivityTaskCanceled", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServiceRespondActivityTaskCanceledResult { bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::BadRequestError>().is_some() {
              let err = usr_err.downcast::<shared::BadRequestError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskCanceledResult{ bad_request_error: Some(*err), entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskCanceled", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::EntityNotExistsError>().is_some() {
              let err = usr_err.downcast::<shared::EntityNotExistsError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskCanceledResult{ bad_request_error: None, entity_not_exist_error: Some(*err), domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskCanceled", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::DomainNotActiveError>().is_some() {
              let err = usr_err.downcast::<shared::DomainNotActiveError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskCanceledResult{ bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: Some(*err), limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskCanceled", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::LimitExceededError>().is_some() {
              let err = usr_err.downcast::<shared::LimitExceededError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskCanceledResult{ bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: Some(*err), service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskCanceled", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskCanceledResult{ bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: Some(*err), client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskCanceled", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ClientVersionNotSupportedError>().is_some() {
              let err = usr_err.downcast::<shared::ClientVersionNotSupportedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskCanceledResult{ bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: Some(*err), workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskCanceled", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::WorkflowExecutionAlreadyCompletedError>().is_some() {
              let err = usr_err.downcast::<shared::WorkflowExecutionAlreadyCompletedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskCanceledResult{ bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskCanceled", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskCanceledResult{ bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskCanceled", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskCanceled", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("RespondActivityTaskCanceled", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("RespondActivityTaskCanceled", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_respond_activity_task_canceled_by_i_d<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = WorkflowServiceRespondActivityTaskCanceledByIDArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_respond_activity_task_canceled_by_i_d(args.canceled_request) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("RespondActivityTaskCanceledByID", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServiceRespondActivityTaskCanceledByIDResult { bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::BadRequestError>().is_some() {
              let err = usr_err.downcast::<shared::BadRequestError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskCanceledByIDResult{ bad_request_error: Some(*err), entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskCanceledByID", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::EntityNotExistsError>().is_some() {
              let err = usr_err.downcast::<shared::EntityNotExistsError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskCanceledByIDResult{ bad_request_error: None, entity_not_exist_error: Some(*err), domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskCanceledByID", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::DomainNotActiveError>().is_some() {
              let err = usr_err.downcast::<shared::DomainNotActiveError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskCanceledByIDResult{ bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: Some(*err), limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskCanceledByID", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::LimitExceededError>().is_some() {
              let err = usr_err.downcast::<shared::LimitExceededError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskCanceledByIDResult{ bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: Some(*err), service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskCanceledByID", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskCanceledByIDResult{ bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: Some(*err), client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskCanceledByID", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ClientVersionNotSupportedError>().is_some() {
              let err = usr_err.downcast::<shared::ClientVersionNotSupportedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskCanceledByIDResult{ bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: Some(*err), workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskCanceledByID", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::WorkflowExecutionAlreadyCompletedError>().is_some() {
              let err = usr_err.downcast::<shared::WorkflowExecutionAlreadyCompletedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskCanceledByIDResult{ bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskCanceledByID", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondActivityTaskCanceledByIDResult{ bad_request_error: None, entity_not_exist_error: None, domain_not_active_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskCanceledByID", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("RespondActivityTaskCanceledByID", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("RespondActivityTaskCanceledByID", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("RespondActivityTaskCanceledByID", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_request_cancel_workflow_execution<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = WorkflowServiceRequestCancelWorkflowExecutionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_request_cancel_workflow_execution(args.cancel_request) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("RequestCancelWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServiceRequestCancelWorkflowExecutionResult { bad_request_error: None, entity_not_exist_error: None, cancellation_already_requested_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::BadRequestError>().is_some() {
              let err = usr_err.downcast::<shared::BadRequestError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRequestCancelWorkflowExecutionResult{ bad_request_error: Some(*err), entity_not_exist_error: None, cancellation_already_requested_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RequestCancelWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::EntityNotExistsError>().is_some() {
              let err = usr_err.downcast::<shared::EntityNotExistsError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRequestCancelWorkflowExecutionResult{ bad_request_error: None, entity_not_exist_error: Some(*err), cancellation_already_requested_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RequestCancelWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::CancellationAlreadyRequestedError>().is_some() {
              let err = usr_err.downcast::<shared::CancellationAlreadyRequestedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRequestCancelWorkflowExecutionResult{ bad_request_error: None, entity_not_exist_error: None, cancellation_already_requested_error: Some(*err), service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RequestCancelWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRequestCancelWorkflowExecutionResult{ bad_request_error: None, entity_not_exist_error: None, cancellation_already_requested_error: None, service_busy_error: Some(*err), domain_not_active_error: None, limit_exceeded_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RequestCancelWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::DomainNotActiveError>().is_some() {
              let err = usr_err.downcast::<shared::DomainNotActiveError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRequestCancelWorkflowExecutionResult{ bad_request_error: None, entity_not_exist_error: None, cancellation_already_requested_error: None, service_busy_error: None, domain_not_active_error: Some(*err), limit_exceeded_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RequestCancelWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::LimitExceededError>().is_some() {
              let err = usr_err.downcast::<shared::LimitExceededError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRequestCancelWorkflowExecutionResult{ bad_request_error: None, entity_not_exist_error: None, cancellation_already_requested_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: Some(*err), client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RequestCancelWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ClientVersionNotSupportedError>().is_some() {
              let err = usr_err.downcast::<shared::ClientVersionNotSupportedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRequestCancelWorkflowExecutionResult{ bad_request_error: None, entity_not_exist_error: None, cancellation_already_requested_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, client_version_not_supported_error: Some(*err), workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RequestCancelWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::WorkflowExecutionAlreadyCompletedError>().is_some() {
              let err = usr_err.downcast::<shared::WorkflowExecutionAlreadyCompletedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRequestCancelWorkflowExecutionResult{ bad_request_error: None, entity_not_exist_error: None, cancellation_already_requested_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RequestCancelWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRequestCancelWorkflowExecutionResult{ bad_request_error: None, entity_not_exist_error: None, cancellation_already_requested_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("RequestCancelWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("RequestCancelWorkflowExecution", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("RequestCancelWorkflowExecution", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("RequestCancelWorkflowExecution", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_signal_workflow_execution<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = WorkflowServiceSignalWorkflowExecutionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_signal_workflow_execution(args.signal_request) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("SignalWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServiceSignalWorkflowExecutionResult { bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::BadRequestError>().is_some() {
              let err = usr_err.downcast::<shared::BadRequestError>().expect("downcast already checked");
              let ret_err = WorkflowServiceSignalWorkflowExecutionResult{ bad_request_error: Some(*err), entity_not_exist_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("SignalWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::EntityNotExistsError>().is_some() {
              let err = usr_err.downcast::<shared::EntityNotExistsError>().expect("downcast already checked");
              let ret_err = WorkflowServiceSignalWorkflowExecutionResult{ bad_request_error: None, entity_not_exist_error: Some(*err), service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("SignalWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServiceSignalWorkflowExecutionResult{ bad_request_error: None, entity_not_exist_error: None, service_busy_error: Some(*err), domain_not_active_error: None, limit_exceeded_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("SignalWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::DomainNotActiveError>().is_some() {
              let err = usr_err.downcast::<shared::DomainNotActiveError>().expect("downcast already checked");
              let ret_err = WorkflowServiceSignalWorkflowExecutionResult{ bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, domain_not_active_error: Some(*err), limit_exceeded_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("SignalWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::LimitExceededError>().is_some() {
              let err = usr_err.downcast::<shared::LimitExceededError>().expect("downcast already checked");
              let ret_err = WorkflowServiceSignalWorkflowExecutionResult{ bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: Some(*err), client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("SignalWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ClientVersionNotSupportedError>().is_some() {
              let err = usr_err.downcast::<shared::ClientVersionNotSupportedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceSignalWorkflowExecutionResult{ bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, client_version_not_supported_error: Some(*err), workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("SignalWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::WorkflowExecutionAlreadyCompletedError>().is_some() {
              let err = usr_err.downcast::<shared::WorkflowExecutionAlreadyCompletedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceSignalWorkflowExecutionResult{ bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("SignalWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceSignalWorkflowExecutionResult{ bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("SignalWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("SignalWorkflowExecution", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SignalWorkflowExecution", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("SignalWorkflowExecution", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_signal_with_start_workflow_execution<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = WorkflowServiceSignalWithStartWorkflowExecutionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_signal_with_start_workflow_execution(args.signal_with_start_request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SignalWithStartWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServiceSignalWithStartWorkflowExecutionResult { result_value: Some(handler_return), bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, workflow_already_started_error: None, client_version_not_supported_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::BadRequestError>().is_some() {
              let err = usr_err.downcast::<shared::BadRequestError>().expect("downcast already checked");
              let ret_err = WorkflowServiceSignalWithStartWorkflowExecutionResult{ result_value: None, bad_request_error: Some(*err), entity_not_exist_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, workflow_already_started_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("SignalWithStartWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::EntityNotExistsError>().is_some() {
              let err = usr_err.downcast::<shared::EntityNotExistsError>().expect("downcast already checked");
              let ret_err = WorkflowServiceSignalWithStartWorkflowExecutionResult{ result_value: None, bad_request_error: None, entity_not_exist_error: Some(*err), service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, workflow_already_started_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("SignalWithStartWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServiceSignalWithStartWorkflowExecutionResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: Some(*err), domain_not_active_error: None, limit_exceeded_error: None, workflow_already_started_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("SignalWithStartWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::DomainNotActiveError>().is_some() {
              let err = usr_err.downcast::<shared::DomainNotActiveError>().expect("downcast already checked");
              let ret_err = WorkflowServiceSignalWithStartWorkflowExecutionResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, domain_not_active_error: Some(*err), limit_exceeded_error: None, workflow_already_started_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("SignalWithStartWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::LimitExceededError>().is_some() {
              let err = usr_err.downcast::<shared::LimitExceededError>().expect("downcast already checked");
              let ret_err = WorkflowServiceSignalWithStartWorkflowExecutionResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: Some(*err), workflow_already_started_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("SignalWithStartWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::WorkflowExecutionAlreadyStartedError>().is_some() {
              let err = usr_err.downcast::<shared::WorkflowExecutionAlreadyStartedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceSignalWithStartWorkflowExecutionResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, workflow_already_started_error: Some(*err), client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("SignalWithStartWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ClientVersionNotSupportedError>().is_some() {
              let err = usr_err.downcast::<shared::ClientVersionNotSupportedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceSignalWithStartWorkflowExecutionResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, workflow_already_started_error: None, client_version_not_supported_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("SignalWithStartWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceSignalWithStartWorkflowExecutionResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, workflow_already_started_error: None, client_version_not_supported_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("SignalWithStartWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("SignalWithStartWorkflowExecution", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SignalWithStartWorkflowExecution", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("SignalWithStartWorkflowExecution", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_signal_with_start_workflow_execution_async<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = WorkflowServiceSignalWithStartWorkflowExecutionAsyncArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_signal_with_start_workflow_execution_async(args.signal_with_start_request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SignalWithStartWorkflowExecutionAsync", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServiceSignalWithStartWorkflowExecutionAsyncResult { result_value: Some(handler_return), bad_request_error: None, session_already_exist_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, entity_not_exist_error: None, client_version_not_supported_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::BadRequestError>().is_some() {
              let err = usr_err.downcast::<shared::BadRequestError>().expect("downcast already checked");
              let ret_err = WorkflowServiceSignalWithStartWorkflowExecutionAsyncResult{ result_value: None, bad_request_error: Some(*err), session_already_exist_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, entity_not_exist_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("SignalWithStartWorkflowExecutionAsync", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::WorkflowExecutionAlreadyStartedError>().is_some() {
              let err = usr_err.downcast::<shared::WorkflowExecutionAlreadyStartedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceSignalWithStartWorkflowExecutionAsyncResult{ result_value: None, bad_request_error: None, session_already_exist_error: Some(*err), service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, entity_not_exist_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("SignalWithStartWorkflowExecutionAsync", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServiceSignalWithStartWorkflowExecutionAsyncResult{ result_value: None, bad_request_error: None, session_already_exist_error: None, service_busy_error: Some(*err), domain_not_active_error: None, limit_exceeded_error: None, entity_not_exist_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("SignalWithStartWorkflowExecutionAsync", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::DomainNotActiveError>().is_some() {
              let err = usr_err.downcast::<shared::DomainNotActiveError>().expect("downcast already checked");
              let ret_err = WorkflowServiceSignalWithStartWorkflowExecutionAsyncResult{ result_value: None, bad_request_error: None, session_already_exist_error: None, service_busy_error: None, domain_not_active_error: Some(*err), limit_exceeded_error: None, entity_not_exist_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("SignalWithStartWorkflowExecutionAsync", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::LimitExceededError>().is_some() {
              let err = usr_err.downcast::<shared::LimitExceededError>().expect("downcast already checked");
              let ret_err = WorkflowServiceSignalWithStartWorkflowExecutionAsyncResult{ result_value: None, bad_request_error: None, session_already_exist_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: Some(*err), entity_not_exist_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("SignalWithStartWorkflowExecutionAsync", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::EntityNotExistsError>().is_some() {
              let err = usr_err.downcast::<shared::EntityNotExistsError>().expect("downcast already checked");
              let ret_err = WorkflowServiceSignalWithStartWorkflowExecutionAsyncResult{ result_value: None, bad_request_error: None, session_already_exist_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, entity_not_exist_error: Some(*err), client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("SignalWithStartWorkflowExecutionAsync", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ClientVersionNotSupportedError>().is_some() {
              let err = usr_err.downcast::<shared::ClientVersionNotSupportedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceSignalWithStartWorkflowExecutionAsyncResult{ result_value: None, bad_request_error: None, session_already_exist_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, entity_not_exist_error: None, client_version_not_supported_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("SignalWithStartWorkflowExecutionAsync", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceSignalWithStartWorkflowExecutionAsyncResult{ result_value: None, bad_request_error: None, session_already_exist_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, entity_not_exist_error: None, client_version_not_supported_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("SignalWithStartWorkflowExecutionAsync", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("SignalWithStartWorkflowExecutionAsync", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SignalWithStartWorkflowExecutionAsync", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("SignalWithStartWorkflowExecutionAsync", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_reset_workflow_execution<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = WorkflowServiceResetWorkflowExecutionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_reset_workflow_execution(args.reset_request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("ResetWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServiceResetWorkflowExecutionResult { result_value: Some(handler_return), bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, client_version_not_supported_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::BadRequestError>().is_some() {
              let err = usr_err.downcast::<shared::BadRequestError>().expect("downcast already checked");
              let ret_err = WorkflowServiceResetWorkflowExecutionResult{ result_value: None, bad_request_error: Some(*err), entity_not_exist_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("ResetWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::EntityNotExistsError>().is_some() {
              let err = usr_err.downcast::<shared::EntityNotExistsError>().expect("downcast already checked");
              let ret_err = WorkflowServiceResetWorkflowExecutionResult{ result_value: None, bad_request_error: None, entity_not_exist_error: Some(*err), service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("ResetWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServiceResetWorkflowExecutionResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: Some(*err), domain_not_active_error: None, limit_exceeded_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("ResetWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::DomainNotActiveError>().is_some() {
              let err = usr_err.downcast::<shared::DomainNotActiveError>().expect("downcast already checked");
              let ret_err = WorkflowServiceResetWorkflowExecutionResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, domain_not_active_error: Some(*err), limit_exceeded_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("ResetWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::LimitExceededError>().is_some() {
              let err = usr_err.downcast::<shared::LimitExceededError>().expect("downcast already checked");
              let ret_err = WorkflowServiceResetWorkflowExecutionResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: Some(*err), client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("ResetWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ClientVersionNotSupportedError>().is_some() {
              let err = usr_err.downcast::<shared::ClientVersionNotSupportedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceResetWorkflowExecutionResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, client_version_not_supported_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("ResetWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceResetWorkflowExecutionResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, client_version_not_supported_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("ResetWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("ResetWorkflowExecution", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("ResetWorkflowExecution", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("ResetWorkflowExecution", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_terminate_workflow_execution<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = WorkflowServiceTerminateWorkflowExecutionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_terminate_workflow_execution(args.terminate_request) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("TerminateWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServiceTerminateWorkflowExecutionResult { bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::BadRequestError>().is_some() {
              let err = usr_err.downcast::<shared::BadRequestError>().expect("downcast already checked");
              let ret_err = WorkflowServiceTerminateWorkflowExecutionResult{ bad_request_error: Some(*err), entity_not_exist_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("TerminateWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::EntityNotExistsError>().is_some() {
              let err = usr_err.downcast::<shared::EntityNotExistsError>().expect("downcast already checked");
              let ret_err = WorkflowServiceTerminateWorkflowExecutionResult{ bad_request_error: None, entity_not_exist_error: Some(*err), service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("TerminateWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServiceTerminateWorkflowExecutionResult{ bad_request_error: None, entity_not_exist_error: None, service_busy_error: Some(*err), domain_not_active_error: None, limit_exceeded_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("TerminateWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::DomainNotActiveError>().is_some() {
              let err = usr_err.downcast::<shared::DomainNotActiveError>().expect("downcast already checked");
              let ret_err = WorkflowServiceTerminateWorkflowExecutionResult{ bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, domain_not_active_error: Some(*err), limit_exceeded_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("TerminateWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::LimitExceededError>().is_some() {
              let err = usr_err.downcast::<shared::LimitExceededError>().expect("downcast already checked");
              let ret_err = WorkflowServiceTerminateWorkflowExecutionResult{ bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: Some(*err), client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("TerminateWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ClientVersionNotSupportedError>().is_some() {
              let err = usr_err.downcast::<shared::ClientVersionNotSupportedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceTerminateWorkflowExecutionResult{ bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, client_version_not_supported_error: Some(*err), workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("TerminateWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::WorkflowExecutionAlreadyCompletedError>().is_some() {
              let err = usr_err.downcast::<shared::WorkflowExecutionAlreadyCompletedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceTerminateWorkflowExecutionResult{ bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("TerminateWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceTerminateWorkflowExecutionResult{ bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, domain_not_active_error: None, limit_exceeded_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("TerminateWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("TerminateWorkflowExecution", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("TerminateWorkflowExecution", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("TerminateWorkflowExecution", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_list_open_workflow_executions<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = WorkflowServiceListOpenWorkflowExecutionsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_list_open_workflow_executions(args.list_request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("ListOpenWorkflowExecutions", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServiceListOpenWorkflowExecutionsResult { result_value: Some(handler_return), bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, limit_exceeded_error: None, client_version_not_supported_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::BadRequestError>().is_some() {
              let err = usr_err.downcast::<shared::BadRequestError>().expect("downcast already checked");
              let ret_err = WorkflowServiceListOpenWorkflowExecutionsResult{ result_value: None, bad_request_error: Some(*err), entity_not_exist_error: None, service_busy_error: None, limit_exceeded_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("ListOpenWorkflowExecutions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::EntityNotExistsError>().is_some() {
              let err = usr_err.downcast::<shared::EntityNotExistsError>().expect("downcast already checked");
              let ret_err = WorkflowServiceListOpenWorkflowExecutionsResult{ result_value: None, bad_request_error: None, entity_not_exist_error: Some(*err), service_busy_error: None, limit_exceeded_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("ListOpenWorkflowExecutions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServiceListOpenWorkflowExecutionsResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: Some(*err), limit_exceeded_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("ListOpenWorkflowExecutions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::LimitExceededError>().is_some() {
              let err = usr_err.downcast::<shared::LimitExceededError>().expect("downcast already checked");
              let ret_err = WorkflowServiceListOpenWorkflowExecutionsResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, limit_exceeded_error: Some(*err), client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("ListOpenWorkflowExecutions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ClientVersionNotSupportedError>().is_some() {
              let err = usr_err.downcast::<shared::ClientVersionNotSupportedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceListOpenWorkflowExecutionsResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, limit_exceeded_error: None, client_version_not_supported_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("ListOpenWorkflowExecutions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceListOpenWorkflowExecutionsResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, limit_exceeded_error: None, client_version_not_supported_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("ListOpenWorkflowExecutions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("ListOpenWorkflowExecutions", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("ListOpenWorkflowExecutions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("ListOpenWorkflowExecutions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_list_closed_workflow_executions<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = WorkflowServiceListClosedWorkflowExecutionsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_list_closed_workflow_executions(args.list_request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("ListClosedWorkflowExecutions", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServiceListClosedWorkflowExecutionsResult { result_value: Some(handler_return), bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::BadRequestError>().is_some() {
              let err = usr_err.downcast::<shared::BadRequestError>().expect("downcast already checked");
              let ret_err = WorkflowServiceListClosedWorkflowExecutionsResult{ result_value: None, bad_request_error: Some(*err), entity_not_exist_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("ListClosedWorkflowExecutions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::EntityNotExistsError>().is_some() {
              let err = usr_err.downcast::<shared::EntityNotExistsError>().expect("downcast already checked");
              let ret_err = WorkflowServiceListClosedWorkflowExecutionsResult{ result_value: None, bad_request_error: None, entity_not_exist_error: Some(*err), service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("ListClosedWorkflowExecutions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServiceListClosedWorkflowExecutionsResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: Some(*err), client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("ListClosedWorkflowExecutions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ClientVersionNotSupportedError>().is_some() {
              let err = usr_err.downcast::<shared::ClientVersionNotSupportedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceListClosedWorkflowExecutionsResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, client_version_not_supported_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("ListClosedWorkflowExecutions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceListClosedWorkflowExecutionsResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("ListClosedWorkflowExecutions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("ListClosedWorkflowExecutions", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("ListClosedWorkflowExecutions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("ListClosedWorkflowExecutions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_list_workflow_executions<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = WorkflowServiceListWorkflowExecutionsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_list_workflow_executions(args.list_request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("ListWorkflowExecutions", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServiceListWorkflowExecutionsResult { result_value: Some(handler_return), bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::BadRequestError>().is_some() {
              let err = usr_err.downcast::<shared::BadRequestError>().expect("downcast already checked");
              let ret_err = WorkflowServiceListWorkflowExecutionsResult{ result_value: None, bad_request_error: Some(*err), entity_not_exist_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("ListWorkflowExecutions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::EntityNotExistsError>().is_some() {
              let err = usr_err.downcast::<shared::EntityNotExistsError>().expect("downcast already checked");
              let ret_err = WorkflowServiceListWorkflowExecutionsResult{ result_value: None, bad_request_error: None, entity_not_exist_error: Some(*err), service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("ListWorkflowExecutions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServiceListWorkflowExecutionsResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: Some(*err), client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("ListWorkflowExecutions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ClientVersionNotSupportedError>().is_some() {
              let err = usr_err.downcast::<shared::ClientVersionNotSupportedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceListWorkflowExecutionsResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, client_version_not_supported_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("ListWorkflowExecutions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceListWorkflowExecutionsResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("ListWorkflowExecutions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("ListWorkflowExecutions", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("ListWorkflowExecutions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("ListWorkflowExecutions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_list_archived_workflow_executions<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = WorkflowServiceListArchivedWorkflowExecutionsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_list_archived_workflow_executions(args.list_request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("ListArchivedWorkflowExecutions", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServiceListArchivedWorkflowExecutionsResult { result_value: Some(handler_return), bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::BadRequestError>().is_some() {
              let err = usr_err.downcast::<shared::BadRequestError>().expect("downcast already checked");
              let ret_err = WorkflowServiceListArchivedWorkflowExecutionsResult{ result_value: None, bad_request_error: Some(*err), entity_not_exist_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("ListArchivedWorkflowExecutions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::EntityNotExistsError>().is_some() {
              let err = usr_err.downcast::<shared::EntityNotExistsError>().expect("downcast already checked");
              let ret_err = WorkflowServiceListArchivedWorkflowExecutionsResult{ result_value: None, bad_request_error: None, entity_not_exist_error: Some(*err), service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("ListArchivedWorkflowExecutions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServiceListArchivedWorkflowExecutionsResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: Some(*err), client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("ListArchivedWorkflowExecutions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ClientVersionNotSupportedError>().is_some() {
              let err = usr_err.downcast::<shared::ClientVersionNotSupportedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceListArchivedWorkflowExecutionsResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, client_version_not_supported_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("ListArchivedWorkflowExecutions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceListArchivedWorkflowExecutionsResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("ListArchivedWorkflowExecutions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("ListArchivedWorkflowExecutions", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("ListArchivedWorkflowExecutions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("ListArchivedWorkflowExecutions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_scan_workflow_executions<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = WorkflowServiceScanWorkflowExecutionsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_scan_workflow_executions(args.list_request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("ScanWorkflowExecutions", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServiceScanWorkflowExecutionsResult { result_value: Some(handler_return), bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::BadRequestError>().is_some() {
              let err = usr_err.downcast::<shared::BadRequestError>().expect("downcast already checked");
              let ret_err = WorkflowServiceScanWorkflowExecutionsResult{ result_value: None, bad_request_error: Some(*err), entity_not_exist_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("ScanWorkflowExecutions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::EntityNotExistsError>().is_some() {
              let err = usr_err.downcast::<shared::EntityNotExistsError>().expect("downcast already checked");
              let ret_err = WorkflowServiceScanWorkflowExecutionsResult{ result_value: None, bad_request_error: None, entity_not_exist_error: Some(*err), service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("ScanWorkflowExecutions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServiceScanWorkflowExecutionsResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: Some(*err), client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("ScanWorkflowExecutions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ClientVersionNotSupportedError>().is_some() {
              let err = usr_err.downcast::<shared::ClientVersionNotSupportedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceScanWorkflowExecutionsResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, client_version_not_supported_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("ScanWorkflowExecutions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceScanWorkflowExecutionsResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("ScanWorkflowExecutions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("ScanWorkflowExecutions", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("ScanWorkflowExecutions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("ScanWorkflowExecutions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_count_workflow_executions<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = WorkflowServiceCountWorkflowExecutionsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_count_workflow_executions(args.count_request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("CountWorkflowExecutions", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServiceCountWorkflowExecutionsResult { result_value: Some(handler_return), bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::BadRequestError>().is_some() {
              let err = usr_err.downcast::<shared::BadRequestError>().expect("downcast already checked");
              let ret_err = WorkflowServiceCountWorkflowExecutionsResult{ result_value: None, bad_request_error: Some(*err), entity_not_exist_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("CountWorkflowExecutions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::EntityNotExistsError>().is_some() {
              let err = usr_err.downcast::<shared::EntityNotExistsError>().expect("downcast already checked");
              let ret_err = WorkflowServiceCountWorkflowExecutionsResult{ result_value: None, bad_request_error: None, entity_not_exist_error: Some(*err), service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("CountWorkflowExecutions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServiceCountWorkflowExecutionsResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: Some(*err), client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("CountWorkflowExecutions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ClientVersionNotSupportedError>().is_some() {
              let err = usr_err.downcast::<shared::ClientVersionNotSupportedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceCountWorkflowExecutionsResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, client_version_not_supported_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("CountWorkflowExecutions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceCountWorkflowExecutionsResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("CountWorkflowExecutions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("CountWorkflowExecutions", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("CountWorkflowExecutions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("CountWorkflowExecutions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_search_attributes<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = WorkflowServiceGetSearchAttributesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_search_attributes() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GetSearchAttributes", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServiceGetSearchAttributesResult { result_value: Some(handler_return), service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServiceGetSearchAttributesResult{ result_value: None, service_busy_error: Some(*err), client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("GetSearchAttributes", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ClientVersionNotSupportedError>().is_some() {
              let err = usr_err.downcast::<shared::ClientVersionNotSupportedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceGetSearchAttributesResult{ result_value: None, service_busy_error: None, client_version_not_supported_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("GetSearchAttributes", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceGetSearchAttributesResult{ result_value: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("GetSearchAttributes", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("GetSearchAttributes", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GetSearchAttributes", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("GetSearchAttributes", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_respond_query_task_completed<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = WorkflowServiceRespondQueryTaskCompletedArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_respond_query_task_completed(args.complete_request) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("RespondQueryTaskCompleted", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServiceRespondQueryTaskCompletedResult { bad_request_error: None, entity_not_exist_error: None, limit_exceeded_error: None, service_busy_error: None, domain_not_active_error: None, client_version_not_supported_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::BadRequestError>().is_some() {
              let err = usr_err.downcast::<shared::BadRequestError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondQueryTaskCompletedResult{ bad_request_error: Some(*err), entity_not_exist_error: None, limit_exceeded_error: None, service_busy_error: None, domain_not_active_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondQueryTaskCompleted", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::EntityNotExistsError>().is_some() {
              let err = usr_err.downcast::<shared::EntityNotExistsError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondQueryTaskCompletedResult{ bad_request_error: None, entity_not_exist_error: Some(*err), limit_exceeded_error: None, service_busy_error: None, domain_not_active_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondQueryTaskCompleted", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::LimitExceededError>().is_some() {
              let err = usr_err.downcast::<shared::LimitExceededError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondQueryTaskCompletedResult{ bad_request_error: None, entity_not_exist_error: None, limit_exceeded_error: Some(*err), service_busy_error: None, domain_not_active_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondQueryTaskCompleted", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondQueryTaskCompletedResult{ bad_request_error: None, entity_not_exist_error: None, limit_exceeded_error: None, service_busy_error: Some(*err), domain_not_active_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondQueryTaskCompleted", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::DomainNotActiveError>().is_some() {
              let err = usr_err.downcast::<shared::DomainNotActiveError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondQueryTaskCompletedResult{ bad_request_error: None, entity_not_exist_error: None, limit_exceeded_error: None, service_busy_error: None, domain_not_active_error: Some(*err), client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondQueryTaskCompleted", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ClientVersionNotSupportedError>().is_some() {
              let err = usr_err.downcast::<shared::ClientVersionNotSupportedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondQueryTaskCompletedResult{ bad_request_error: None, entity_not_exist_error: None, limit_exceeded_error: None, service_busy_error: None, domain_not_active_error: None, client_version_not_supported_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RespondQueryTaskCompleted", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRespondQueryTaskCompletedResult{ bad_request_error: None, entity_not_exist_error: None, limit_exceeded_error: None, service_busy_error: None, domain_not_active_error: None, client_version_not_supported_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("RespondQueryTaskCompleted", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("RespondQueryTaskCompleted", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("RespondQueryTaskCompleted", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("RespondQueryTaskCompleted", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_reset_sticky_task_list<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = WorkflowServiceResetStickyTaskListArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_reset_sticky_task_list(args.reset_request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("ResetStickyTaskList", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServiceResetStickyTaskListResult { result_value: Some(handler_return), bad_request_error: None, entity_not_exist_error: None, limit_exceeded_error: None, service_busy_error: None, domain_not_active_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::BadRequestError>().is_some() {
              let err = usr_err.downcast::<shared::BadRequestError>().expect("downcast already checked");
              let ret_err = WorkflowServiceResetStickyTaskListResult{ result_value: None, bad_request_error: Some(*err), entity_not_exist_error: None, limit_exceeded_error: None, service_busy_error: None, domain_not_active_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("ResetStickyTaskList", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::EntityNotExistsError>().is_some() {
              let err = usr_err.downcast::<shared::EntityNotExistsError>().expect("downcast already checked");
              let ret_err = WorkflowServiceResetStickyTaskListResult{ result_value: None, bad_request_error: None, entity_not_exist_error: Some(*err), limit_exceeded_error: None, service_busy_error: None, domain_not_active_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("ResetStickyTaskList", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::LimitExceededError>().is_some() {
              let err = usr_err.downcast::<shared::LimitExceededError>().expect("downcast already checked");
              let ret_err = WorkflowServiceResetStickyTaskListResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, limit_exceeded_error: Some(*err), service_busy_error: None, domain_not_active_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("ResetStickyTaskList", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServiceResetStickyTaskListResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, limit_exceeded_error: None, service_busy_error: Some(*err), domain_not_active_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("ResetStickyTaskList", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::DomainNotActiveError>().is_some() {
              let err = usr_err.downcast::<shared::DomainNotActiveError>().expect("downcast already checked");
              let ret_err = WorkflowServiceResetStickyTaskListResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, limit_exceeded_error: None, service_busy_error: None, domain_not_active_error: Some(*err), client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("ResetStickyTaskList", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ClientVersionNotSupportedError>().is_some() {
              let err = usr_err.downcast::<shared::ClientVersionNotSupportedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceResetStickyTaskListResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, limit_exceeded_error: None, service_busy_error: None, domain_not_active_error: None, client_version_not_supported_error: Some(*err), workflow_execution_already_completed_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("ResetStickyTaskList", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::WorkflowExecutionAlreadyCompletedError>().is_some() {
              let err = usr_err.downcast::<shared::WorkflowExecutionAlreadyCompletedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceResetStickyTaskListResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, limit_exceeded_error: None, service_busy_error: None, domain_not_active_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("ResetStickyTaskList", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceResetStickyTaskListResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, limit_exceeded_error: None, service_busy_error: None, domain_not_active_error: None, client_version_not_supported_error: None, workflow_execution_already_completed_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("ResetStickyTaskList", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("ResetStickyTaskList", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("ResetStickyTaskList", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("ResetStickyTaskList", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_query_workflow<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = WorkflowServiceQueryWorkflowArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_query_workflow(args.query_request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("QueryWorkflow", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServiceQueryWorkflowResult { result_value: Some(handler_return), bad_request_error: None, entity_not_exist_error: None, query_failed_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::BadRequestError>().is_some() {
              let err = usr_err.downcast::<shared::BadRequestError>().expect("downcast already checked");
              let ret_err = WorkflowServiceQueryWorkflowResult{ result_value: None, bad_request_error: Some(*err), entity_not_exist_error: None, query_failed_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("QueryWorkflow", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::EntityNotExistsError>().is_some() {
              let err = usr_err.downcast::<shared::EntityNotExistsError>().expect("downcast already checked");
              let ret_err = WorkflowServiceQueryWorkflowResult{ result_value: None, bad_request_error: None, entity_not_exist_error: Some(*err), query_failed_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("QueryWorkflow", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::QueryFailedError>().is_some() {
              let err = usr_err.downcast::<shared::QueryFailedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceQueryWorkflowResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, query_failed_error: Some(*err), limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("QueryWorkflow", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::LimitExceededError>().is_some() {
              let err = usr_err.downcast::<shared::LimitExceededError>().expect("downcast already checked");
              let ret_err = WorkflowServiceQueryWorkflowResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, query_failed_error: None, limit_exceeded_error: Some(*err), service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("QueryWorkflow", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServiceQueryWorkflowResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, query_failed_error: None, limit_exceeded_error: None, service_busy_error: Some(*err), client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("QueryWorkflow", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ClientVersionNotSupportedError>().is_some() {
              let err = usr_err.downcast::<shared::ClientVersionNotSupportedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceQueryWorkflowResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, query_failed_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("QueryWorkflow", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceQueryWorkflowResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, query_failed_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("QueryWorkflow", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("QueryWorkflow", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("QueryWorkflow", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("QueryWorkflow", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_describe_workflow_execution<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = WorkflowServiceDescribeWorkflowExecutionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_describe_workflow_execution(args.describe_request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("DescribeWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServiceDescribeWorkflowExecutionResult { result_value: Some(handler_return), bad_request_error: None, entity_not_exist_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::BadRequestError>().is_some() {
              let err = usr_err.downcast::<shared::BadRequestError>().expect("downcast already checked");
              let ret_err = WorkflowServiceDescribeWorkflowExecutionResult{ result_value: None, bad_request_error: Some(*err), entity_not_exist_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("DescribeWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::EntityNotExistsError>().is_some() {
              let err = usr_err.downcast::<shared::EntityNotExistsError>().expect("downcast already checked");
              let ret_err = WorkflowServiceDescribeWorkflowExecutionResult{ result_value: None, bad_request_error: None, entity_not_exist_error: Some(*err), limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("DescribeWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::LimitExceededError>().is_some() {
              let err = usr_err.downcast::<shared::LimitExceededError>().expect("downcast already checked");
              let ret_err = WorkflowServiceDescribeWorkflowExecutionResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, limit_exceeded_error: Some(*err), service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("DescribeWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServiceDescribeWorkflowExecutionResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, limit_exceeded_error: None, service_busy_error: Some(*err), client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("DescribeWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ClientVersionNotSupportedError>().is_some() {
              let err = usr_err.downcast::<shared::ClientVersionNotSupportedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceDescribeWorkflowExecutionResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("DescribeWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceDescribeWorkflowExecutionResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("DescribeWorkflowExecution", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("DescribeWorkflowExecution", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("DescribeWorkflowExecution", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("DescribeWorkflowExecution", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_describe_task_list<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = WorkflowServiceDescribeTaskListArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_describe_task_list(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("DescribeTaskList", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServiceDescribeTaskListResult { result_value: Some(handler_return), bad_request_error: None, entity_not_exist_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::BadRequestError>().is_some() {
              let err = usr_err.downcast::<shared::BadRequestError>().expect("downcast already checked");
              let ret_err = WorkflowServiceDescribeTaskListResult{ result_value: None, bad_request_error: Some(*err), entity_not_exist_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("DescribeTaskList", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::EntityNotExistsError>().is_some() {
              let err = usr_err.downcast::<shared::EntityNotExistsError>().expect("downcast already checked");
              let ret_err = WorkflowServiceDescribeTaskListResult{ result_value: None, bad_request_error: None, entity_not_exist_error: Some(*err), limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("DescribeTaskList", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::LimitExceededError>().is_some() {
              let err = usr_err.downcast::<shared::LimitExceededError>().expect("downcast already checked");
              let ret_err = WorkflowServiceDescribeTaskListResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, limit_exceeded_error: Some(*err), service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("DescribeTaskList", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServiceDescribeTaskListResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, limit_exceeded_error: None, service_busy_error: Some(*err), client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("DescribeTaskList", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ClientVersionNotSupportedError>().is_some() {
              let err = usr_err.downcast::<shared::ClientVersionNotSupportedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceDescribeTaskListResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("DescribeTaskList", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceDescribeTaskListResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("DescribeTaskList", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("DescribeTaskList", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("DescribeTaskList", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("DescribeTaskList", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_cluster_info<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let _ = WorkflowServiceGetClusterInfoArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_cluster_info() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GetClusterInfo", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServiceGetClusterInfoResult { result_value: Some(handler_return), internal_service_error: None, service_busy_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::InternalServiceError>().is_some() {
              let err = usr_err.downcast::<shared::InternalServiceError>().expect("downcast already checked");
              let ret_err = WorkflowServiceGetClusterInfoResult{ result_value: None, internal_service_error: Some(*err), service_busy_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("GetClusterInfo", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServiceGetClusterInfoResult{ result_value: None, internal_service_error: None, service_busy_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("GetClusterInfo", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceGetClusterInfoResult{ result_value: None, internal_service_error: None, service_busy_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("GetClusterInfo", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("GetClusterInfo", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GetClusterInfo", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("GetClusterInfo", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_task_lists_by_domain<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = WorkflowServiceGetTaskListsByDomainArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_task_lists_by_domain(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GetTaskListsByDomain", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServiceGetTaskListsByDomainResult { result_value: Some(handler_return), bad_request_error: None, entity_not_exist_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::BadRequestError>().is_some() {
              let err = usr_err.downcast::<shared::BadRequestError>().expect("downcast already checked");
              let ret_err = WorkflowServiceGetTaskListsByDomainResult{ result_value: None, bad_request_error: Some(*err), entity_not_exist_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("GetTaskListsByDomain", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::EntityNotExistsError>().is_some() {
              let err = usr_err.downcast::<shared::EntityNotExistsError>().expect("downcast already checked");
              let ret_err = WorkflowServiceGetTaskListsByDomainResult{ result_value: None, bad_request_error: None, entity_not_exist_error: Some(*err), limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("GetTaskListsByDomain", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::LimitExceededError>().is_some() {
              let err = usr_err.downcast::<shared::LimitExceededError>().expect("downcast already checked");
              let ret_err = WorkflowServiceGetTaskListsByDomainResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, limit_exceeded_error: Some(*err), service_busy_error: None, client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("GetTaskListsByDomain", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServiceGetTaskListsByDomainResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, limit_exceeded_error: None, service_busy_error: Some(*err), client_version_not_supported_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("GetTaskListsByDomain", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ClientVersionNotSupportedError>().is_some() {
              let err = usr_err.downcast::<shared::ClientVersionNotSupportedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceGetTaskListsByDomainResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("GetTaskListsByDomain", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceGetTaskListsByDomainResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, limit_exceeded_error: None, service_busy_error: None, client_version_not_supported_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("GetTaskListsByDomain", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("GetTaskListsByDomain", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GetTaskListsByDomain", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("GetTaskListsByDomain", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_list_task_list_partitions<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = WorkflowServiceListTaskListPartitionsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_list_task_list_partitions(args.request) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("ListTaskListPartitions", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServiceListTaskListPartitionsResult { result_value: Some(handler_return), bad_request_error: None, entity_not_exist_error: None, limit_exceeded_error: None, service_busy_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::BadRequestError>().is_some() {
              let err = usr_err.downcast::<shared::BadRequestError>().expect("downcast already checked");
              let ret_err = WorkflowServiceListTaskListPartitionsResult{ result_value: None, bad_request_error: Some(*err), entity_not_exist_error: None, limit_exceeded_error: None, service_busy_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("ListTaskListPartitions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::EntityNotExistsError>().is_some() {
              let err = usr_err.downcast::<shared::EntityNotExistsError>().expect("downcast already checked");
              let ret_err = WorkflowServiceListTaskListPartitionsResult{ result_value: None, bad_request_error: None, entity_not_exist_error: Some(*err), limit_exceeded_error: None, service_busy_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("ListTaskListPartitions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::LimitExceededError>().is_some() {
              let err = usr_err.downcast::<shared::LimitExceededError>().expect("downcast already checked");
              let ret_err = WorkflowServiceListTaskListPartitionsResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, limit_exceeded_error: Some(*err), service_busy_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("ListTaskListPartitions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServiceListTaskListPartitionsResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, limit_exceeded_error: None, service_busy_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("ListTaskListPartitions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceListTaskListPartitionsResult{ result_value: None, bad_request_error: None, entity_not_exist_error: None, limit_exceeded_error: None, service_busy_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("ListTaskListPartitions", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("ListTaskListPartitions", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("ListTaskListPartitions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("ListTaskListPartitions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_refresh_workflow_tasks<H: WorkflowServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = WorkflowServiceRefreshWorkflowTasksArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_refresh_workflow_tasks(args.request) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("RefreshWorkflowTasks", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = WorkflowServiceRefreshWorkflowTasksResult { bad_request_error: None, domain_not_active_error: None, service_busy_error: None, entity_not_exist_error: None, access_denied_error: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<shared::BadRequestError>().is_some() {
              let err = usr_err.downcast::<shared::BadRequestError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRefreshWorkflowTasksResult{ bad_request_error: Some(*err), domain_not_active_error: None, service_busy_error: None, entity_not_exist_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RefreshWorkflowTasks", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::DomainNotActiveError>().is_some() {
              let err = usr_err.downcast::<shared::DomainNotActiveError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRefreshWorkflowTasksResult{ bad_request_error: None, domain_not_active_error: Some(*err), service_busy_error: None, entity_not_exist_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RefreshWorkflowTasks", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::ServiceBusyError>().is_some() {
              let err = usr_err.downcast::<shared::ServiceBusyError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRefreshWorkflowTasksResult{ bad_request_error: None, domain_not_active_error: None, service_busy_error: Some(*err), entity_not_exist_error: None, access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RefreshWorkflowTasks", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::EntityNotExistsError>().is_some() {
              let err = usr_err.downcast::<shared::EntityNotExistsError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRefreshWorkflowTasksResult{ bad_request_error: None, domain_not_active_error: None, service_busy_error: None, entity_not_exist_error: Some(*err), access_denied_error: None };
              let message_ident = TMessageIdentifier::new("RefreshWorkflowTasks", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else if usr_err.downcast_ref::<shared::AccessDeniedError>().is_some() {
              let err = usr_err.downcast::<shared::AccessDeniedError>().expect("downcast already checked");
              let ret_err = WorkflowServiceRefreshWorkflowTasksResult{ bad_request_error: None, domain_not_active_error: None, service_busy_error: None, entity_not_exist_error: None, access_denied_error: Some(*err) };
              let message_ident = TMessageIdentifier::new("RefreshWorkflowTasks", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("RefreshWorkflowTasks", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("RefreshWorkflowTasks", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("RefreshWorkflowTasks", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
}

impl <H: WorkflowServiceSyncHandler> TProcessor for WorkflowServiceSyncProcessor<H> {
  fn process(&self, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let message_ident = i_prot.read_message_begin()?;
    let res = match &*message_ident.name {
      "RegisterDomain" => {
        self.process_register_domain(message_ident.sequence_number, i_prot, o_prot)
      },
      "DescribeDomain" => {
        self.process_describe_domain(message_ident.sequence_number, i_prot, o_prot)
      },
      "ListDomains" => {
        self.process_list_domains(message_ident.sequence_number, i_prot, o_prot)
      },
      "UpdateDomain" => {
        self.process_update_domain(message_ident.sequence_number, i_prot, o_prot)
      },
      "FailoverDomain" => {
        self.process_failover_domain(message_ident.sequence_number, i_prot, o_prot)
      },
      "DeprecateDomain" => {
        self.process_deprecate_domain(message_ident.sequence_number, i_prot, o_prot)
      },
      "DeleteDomain" => {
        self.process_delete_domain(message_ident.sequence_number, i_prot, o_prot)
      },
      "ListFailoverHistory" => {
        self.process_list_failover_history(message_ident.sequence_number, i_prot, o_prot)
      },
      "RestartWorkflowExecution" => {
        self.process_restart_workflow_execution(message_ident.sequence_number, i_prot, o_prot)
      },
      "DiagnoseWorkflowExecution" => {
        self.process_diagnose_workflow_execution(message_ident.sequence_number, i_prot, o_prot)
      },
      "StartWorkflowExecution" => {
        self.process_start_workflow_execution(message_ident.sequence_number, i_prot, o_prot)
      },
      "StartWorkflowExecutionAsync" => {
        self.process_start_workflow_execution_async(message_ident.sequence_number, i_prot, o_prot)
      },
      "GetWorkflowExecutionHistory" => {
        self.process_get_workflow_execution_history(message_ident.sequence_number, i_prot, o_prot)
      },
      "PollForDecisionTask" => {
        self.process_poll_for_decision_task(message_ident.sequence_number, i_prot, o_prot)
      },
      "RespondDecisionTaskCompleted" => {
        self.process_respond_decision_task_completed(message_ident.sequence_number, i_prot, o_prot)
      },
      "RespondDecisionTaskFailed" => {
        self.process_respond_decision_task_failed(message_ident.sequence_number, i_prot, o_prot)
      },
      "PollForActivityTask" => {
        self.process_poll_for_activity_task(message_ident.sequence_number, i_prot, o_prot)
      },
      "RecordActivityTaskHeartbeat" => {
        self.process_record_activity_task_heartbeat(message_ident.sequence_number, i_prot, o_prot)
      },
      "RecordActivityTaskHeartbeatByID" => {
        self.process_record_activity_task_heartbeat_by_i_d(message_ident.sequence_number, i_prot, o_prot)
      },
      "RespondActivityTaskCompleted" => {
        self.process_respond_activity_task_completed(message_ident.sequence_number, i_prot, o_prot)
      },
      "RespondActivityTaskCompletedByID" => {
        self.process_respond_activity_task_completed_by_i_d(message_ident.sequence_number, i_prot, o_prot)
      },
      "RespondActivityTaskFailed" => {
        self.process_respond_activity_task_failed(message_ident.sequence_number, i_prot, o_prot)
      },
      "RespondActivityTaskFailedByID" => {
        self.process_respond_activity_task_failed_by_i_d(message_ident.sequence_number, i_prot, o_prot)
      },
      "RespondActivityTaskCanceled" => {
        self.process_respond_activity_task_canceled(message_ident.sequence_number, i_prot, o_prot)
      },
      "RespondActivityTaskCanceledByID" => {
        self.process_respond_activity_task_canceled_by_i_d(message_ident.sequence_number, i_prot, o_prot)
      },
      "RequestCancelWorkflowExecution" => {
        self.process_request_cancel_workflow_execution(message_ident.sequence_number, i_prot, o_prot)
      },
      "SignalWorkflowExecution" => {
        self.process_signal_workflow_execution(message_ident.sequence_number, i_prot, o_prot)
      },
      "SignalWithStartWorkflowExecution" => {
        self.process_signal_with_start_workflow_execution(message_ident.sequence_number, i_prot, o_prot)
      },
      "SignalWithStartWorkflowExecutionAsync" => {
        self.process_signal_with_start_workflow_execution_async(message_ident.sequence_number, i_prot, o_prot)
      },
      "ResetWorkflowExecution" => {
        self.process_reset_workflow_execution(message_ident.sequence_number, i_prot, o_prot)
      },
      "TerminateWorkflowExecution" => {
        self.process_terminate_workflow_execution(message_ident.sequence_number, i_prot, o_prot)
      },
      "ListOpenWorkflowExecutions" => {
        self.process_list_open_workflow_executions(message_ident.sequence_number, i_prot, o_prot)
      },
      "ListClosedWorkflowExecutions" => {
        self.process_list_closed_workflow_executions(message_ident.sequence_number, i_prot, o_prot)
      },
      "ListWorkflowExecutions" => {
        self.process_list_workflow_executions(message_ident.sequence_number, i_prot, o_prot)
      },
      "ListArchivedWorkflowExecutions" => {
        self.process_list_archived_workflow_executions(message_ident.sequence_number, i_prot, o_prot)
      },
      "ScanWorkflowExecutions" => {
        self.process_scan_workflow_executions(message_ident.sequence_number, i_prot, o_prot)
      },
      "CountWorkflowExecutions" => {
        self.process_count_workflow_executions(message_ident.sequence_number, i_prot, o_prot)
      },
      "GetSearchAttributes" => {
        self.process_get_search_attributes(message_ident.sequence_number, i_prot, o_prot)
      },
      "RespondQueryTaskCompleted" => {
        self.process_respond_query_task_completed(message_ident.sequence_number, i_prot, o_prot)
      },
      "ResetStickyTaskList" => {
        self.process_reset_sticky_task_list(message_ident.sequence_number, i_prot, o_prot)
      },
      "QueryWorkflow" => {
        self.process_query_workflow(message_ident.sequence_number, i_prot, o_prot)
      },
      "DescribeWorkflowExecution" => {
        self.process_describe_workflow_execution(message_ident.sequence_number, i_prot, o_prot)
      },
      "DescribeTaskList" => {
        self.process_describe_task_list(message_ident.sequence_number, i_prot, o_prot)
      },
      "GetClusterInfo" => {
        self.process_get_cluster_info(message_ident.sequence_number, i_prot, o_prot)
      },
      "GetTaskListsByDomain" => {
        self.process_get_task_lists_by_domain(message_ident.sequence_number, i_prot, o_prot)
      },
      "ListTaskListPartitions" => {
        self.process_list_task_list_partitions(message_ident.sequence_number, i_prot, o_prot)
      },
      "RefreshWorkflowTasks" => {
        self.process_refresh_workflow_tasks(message_ident.sequence_number, i_prot, o_prot)
      },
      method => {
        Err(
          thrift::Error::Application(
            ApplicationError::new(
              ApplicationErrorKind::UnknownMethod,
              format!("unknown method {}", method)
            )
          )
        )
      },
    };
    thrift::server::handle_process_result(&message_ident, res, o_prot)
  }
}

//
// WorkflowServiceRegisterDomainArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceRegisterDomainArgs {
  register_request: shared::RegisterDomainRequest,
}

impl WorkflowServiceRegisterDomainArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceRegisterDomainArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::RegisterDomainRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::RegisterDomainRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WorkflowServiceRegisterDomainArgs.register_request", &f_1)?;
    let ret = WorkflowServiceRegisterDomainArgs {
      register_request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RegisterDomain_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("registerRequest", TType::Struct, 1))?;
    self.register_request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceRegisterDomainResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceRegisterDomainResult {
  bad_request_error: Option<shared::BadRequestError>,
  domain_exists_error: Option<shared::DomainAlreadyExistsError>,
  service_busy_error: Option<shared::ServiceBusyError>,
  client_version_not_supported_error: Option<shared::ClientVersionNotSupportedError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServiceRegisterDomainResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.bad_request_error.is_some() {
      Err(thrift::Error::User(Box::new(self.bad_request_error.unwrap())))
    } else if self.domain_exists_error.is_some() {
      Err(thrift::Error::User(Box::new(self.domain_exists_error.unwrap())))
    } else if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.client_version_not_supported_error.is_some() {
      Err(thrift::Error::User(Box::new(self.client_version_not_supported_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceRegisterDomainResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::BadRequestError> = None;
    let mut f_3: Option<shared::DomainAlreadyExistsError> = None;
    let mut f_4: Option<shared::ServiceBusyError> = None;
    let mut f_5: Option<shared::ClientVersionNotSupportedError> = None;
    let mut f_6: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::BadRequestError::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        3 => {
          let val = shared::DomainAlreadyExistsError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = shared::ClientVersionNotSupportedError::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceRegisterDomainResult {
      bad_request_error: f_1,
      domain_exists_error: f_3,
      service_busy_error: f_4,
      client_version_not_supported_error: f_5,
      access_denied_error: f_6,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServiceRegisterDomainResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.bad_request_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("badRequestError", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.domain_exists_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("domainExistsError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_version_not_supported_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientVersionNotSupportedError", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceDescribeDomainArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceDescribeDomainArgs {
  describe_request: shared::DescribeDomainRequest,
}

impl WorkflowServiceDescribeDomainArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceDescribeDomainArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::DescribeDomainRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::DescribeDomainRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WorkflowServiceDescribeDomainArgs.describe_request", &f_1)?;
    let ret = WorkflowServiceDescribeDomainArgs {
      describe_request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DescribeDomain_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("describeRequest", TType::Struct, 1))?;
    self.describe_request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceDescribeDomainResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceDescribeDomainResult {
  result_value: Option<shared::DescribeDomainResponse>,
  bad_request_error: Option<shared::BadRequestError>,
  entity_not_exist_error: Option<shared::EntityNotExistsError>,
  service_busy_error: Option<shared::ServiceBusyError>,
  client_version_not_supported_error: Option<shared::ClientVersionNotSupportedError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServiceDescribeDomainResult {
  fn ok_or(self) -> thrift::Result<shared::DescribeDomainResponse> {
    if self.bad_request_error.is_some() {
      Err(thrift::Error::User(Box::new(self.bad_request_error.unwrap())))
    } else if self.entity_not_exist_error.is_some() {
      Err(thrift::Error::User(Box::new(self.entity_not_exist_error.unwrap())))
    } else if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.client_version_not_supported_error.is_some() {
      Err(thrift::Error::User(Box::new(self.client_version_not_supported_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for WorkflowServiceDescribeDomain"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceDescribeDomainResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<shared::DescribeDomainResponse> = None;
    let mut f_1: Option<shared::BadRequestError> = None;
    let mut f_3: Option<shared::EntityNotExistsError> = None;
    let mut f_4: Option<shared::ServiceBusyError> = None;
    let mut f_5: Option<shared::ClientVersionNotSupportedError> = None;
    let mut f_6: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = shared::DescribeDomainResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = shared::BadRequestError::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        3 => {
          let val = shared::EntityNotExistsError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = shared::ClientVersionNotSupportedError::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceDescribeDomainResult {
      result_value: f_0,
      bad_request_error: f_1,
      entity_not_exist_error: f_3,
      service_busy_error: f_4,
      client_version_not_supported_error: f_5,
      access_denied_error: f_6,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServiceDescribeDomainResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.bad_request_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("badRequestError", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_not_exist_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("entityNotExistError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_version_not_supported_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientVersionNotSupportedError", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceListDomainsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceListDomainsArgs {
  list_request: shared::ListDomainsRequest,
}

impl WorkflowServiceListDomainsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceListDomainsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::ListDomainsRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::ListDomainsRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WorkflowServiceListDomainsArgs.list_request", &f_1)?;
    let ret = WorkflowServiceListDomainsArgs {
      list_request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ListDomains_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("listRequest", TType::Struct, 1))?;
    self.list_request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceListDomainsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceListDomainsResult {
  result_value: Option<shared::ListDomainsResponse>,
  bad_request_error: Option<shared::BadRequestError>,
  entity_not_exist_error: Option<shared::EntityNotExistsError>,
  service_busy_error: Option<shared::ServiceBusyError>,
  client_version_not_supported_error: Option<shared::ClientVersionNotSupportedError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServiceListDomainsResult {
  fn ok_or(self) -> thrift::Result<shared::ListDomainsResponse> {
    if self.bad_request_error.is_some() {
      Err(thrift::Error::User(Box::new(self.bad_request_error.unwrap())))
    } else if self.entity_not_exist_error.is_some() {
      Err(thrift::Error::User(Box::new(self.entity_not_exist_error.unwrap())))
    } else if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.client_version_not_supported_error.is_some() {
      Err(thrift::Error::User(Box::new(self.client_version_not_supported_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for WorkflowServiceListDomains"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceListDomainsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<shared::ListDomainsResponse> = None;
    let mut f_1: Option<shared::BadRequestError> = None;
    let mut f_3: Option<shared::EntityNotExistsError> = None;
    let mut f_4: Option<shared::ServiceBusyError> = None;
    let mut f_5: Option<shared::ClientVersionNotSupportedError> = None;
    let mut f_6: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = shared::ListDomainsResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = shared::BadRequestError::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        3 => {
          let val = shared::EntityNotExistsError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = shared::ClientVersionNotSupportedError::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceListDomainsResult {
      result_value: f_0,
      bad_request_error: f_1,
      entity_not_exist_error: f_3,
      service_busy_error: f_4,
      client_version_not_supported_error: f_5,
      access_denied_error: f_6,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServiceListDomainsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.bad_request_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("badRequestError", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_not_exist_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("entityNotExistError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_version_not_supported_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientVersionNotSupportedError", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceUpdateDomainArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceUpdateDomainArgs {
  update_request: shared::UpdateDomainRequest,
}

impl WorkflowServiceUpdateDomainArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceUpdateDomainArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::UpdateDomainRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::UpdateDomainRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WorkflowServiceUpdateDomainArgs.update_request", &f_1)?;
    let ret = WorkflowServiceUpdateDomainArgs {
      update_request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UpdateDomain_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("updateRequest", TType::Struct, 1))?;
    self.update_request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceUpdateDomainResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceUpdateDomainResult {
  result_value: Option<shared::UpdateDomainResponse>,
  bad_request_error: Option<shared::BadRequestError>,
  entity_not_exist_error: Option<shared::EntityNotExistsError>,
  service_busy_error: Option<shared::ServiceBusyError>,
  domain_not_active_error: Option<shared::DomainNotActiveError>,
  client_version_not_supported_error: Option<shared::ClientVersionNotSupportedError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServiceUpdateDomainResult {
  fn ok_or(self) -> thrift::Result<shared::UpdateDomainResponse> {
    if self.bad_request_error.is_some() {
      Err(thrift::Error::User(Box::new(self.bad_request_error.unwrap())))
    } else if self.entity_not_exist_error.is_some() {
      Err(thrift::Error::User(Box::new(self.entity_not_exist_error.unwrap())))
    } else if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.domain_not_active_error.is_some() {
      Err(thrift::Error::User(Box::new(self.domain_not_active_error.unwrap())))
    } else if self.client_version_not_supported_error.is_some() {
      Err(thrift::Error::User(Box::new(self.client_version_not_supported_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for WorkflowServiceUpdateDomain"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceUpdateDomainResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<shared::UpdateDomainResponse> = None;
    let mut f_1: Option<shared::BadRequestError> = None;
    let mut f_3: Option<shared::EntityNotExistsError> = None;
    let mut f_4: Option<shared::ServiceBusyError> = None;
    let mut f_5: Option<shared::DomainNotActiveError> = None;
    let mut f_6: Option<shared::ClientVersionNotSupportedError> = None;
    let mut f_7: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = shared::UpdateDomainResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = shared::BadRequestError::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        3 => {
          let val = shared::EntityNotExistsError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = shared::DomainNotActiveError::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = shared::ClientVersionNotSupportedError::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceUpdateDomainResult {
      result_value: f_0,
      bad_request_error: f_1,
      entity_not_exist_error: f_3,
      service_busy_error: f_4,
      domain_not_active_error: f_5,
      client_version_not_supported_error: f_6,
      access_denied_error: f_7,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServiceUpdateDomainResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.bad_request_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("badRequestError", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_not_exist_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("entityNotExistError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.domain_not_active_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("domainNotActiveError", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_version_not_supported_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientVersionNotSupportedError", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceFailoverDomainArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceFailoverDomainArgs {
  failover_request: shared::FailoverDomainRequest,
}

impl WorkflowServiceFailoverDomainArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceFailoverDomainArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::FailoverDomainRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::FailoverDomainRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WorkflowServiceFailoverDomainArgs.failover_request", &f_1)?;
    let ret = WorkflowServiceFailoverDomainArgs {
      failover_request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("FailoverDomain_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("failoverRequest", TType::Struct, 1))?;
    self.failover_request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceFailoverDomainResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceFailoverDomainResult {
  result_value: Option<shared::FailoverDomainResponse>,
  bad_request_error: Option<shared::BadRequestError>,
  entity_not_exist_error: Option<shared::EntityNotExistsError>,
  service_busy_error: Option<shared::ServiceBusyError>,
  domain_not_active_error: Option<shared::DomainNotActiveError>,
  client_version_not_supported_error: Option<shared::ClientVersionNotSupportedError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServiceFailoverDomainResult {
  fn ok_or(self) -> thrift::Result<shared::FailoverDomainResponse> {
    if self.bad_request_error.is_some() {
      Err(thrift::Error::User(Box::new(self.bad_request_error.unwrap())))
    } else if self.entity_not_exist_error.is_some() {
      Err(thrift::Error::User(Box::new(self.entity_not_exist_error.unwrap())))
    } else if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.domain_not_active_error.is_some() {
      Err(thrift::Error::User(Box::new(self.domain_not_active_error.unwrap())))
    } else if self.client_version_not_supported_error.is_some() {
      Err(thrift::Error::User(Box::new(self.client_version_not_supported_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for WorkflowServiceFailoverDomain"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceFailoverDomainResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<shared::FailoverDomainResponse> = None;
    let mut f_1: Option<shared::BadRequestError> = None;
    let mut f_3: Option<shared::EntityNotExistsError> = None;
    let mut f_4: Option<shared::ServiceBusyError> = None;
    let mut f_5: Option<shared::DomainNotActiveError> = None;
    let mut f_6: Option<shared::ClientVersionNotSupportedError> = None;
    let mut f_7: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = shared::FailoverDomainResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = shared::BadRequestError::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        3 => {
          let val = shared::EntityNotExistsError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = shared::DomainNotActiveError::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = shared::ClientVersionNotSupportedError::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceFailoverDomainResult {
      result_value: f_0,
      bad_request_error: f_1,
      entity_not_exist_error: f_3,
      service_busy_error: f_4,
      domain_not_active_error: f_5,
      client_version_not_supported_error: f_6,
      access_denied_error: f_7,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServiceFailoverDomainResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.bad_request_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("badRequestError", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_not_exist_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("entityNotExistError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.domain_not_active_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("domainNotActiveError", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_version_not_supported_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientVersionNotSupportedError", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceDeprecateDomainArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceDeprecateDomainArgs {
  deprecate_request: shared::DeprecateDomainRequest,
}

impl WorkflowServiceDeprecateDomainArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceDeprecateDomainArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::DeprecateDomainRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::DeprecateDomainRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WorkflowServiceDeprecateDomainArgs.deprecate_request", &f_1)?;
    let ret = WorkflowServiceDeprecateDomainArgs {
      deprecate_request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DeprecateDomain_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("deprecateRequest", TType::Struct, 1))?;
    self.deprecate_request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceDeprecateDomainResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceDeprecateDomainResult {
  bad_request_error: Option<shared::BadRequestError>,
  entity_not_exist_error: Option<shared::EntityNotExistsError>,
  service_busy_error: Option<shared::ServiceBusyError>,
  domain_not_active_error: Option<shared::DomainNotActiveError>,
  client_version_not_supported_error: Option<shared::ClientVersionNotSupportedError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServiceDeprecateDomainResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.bad_request_error.is_some() {
      Err(thrift::Error::User(Box::new(self.bad_request_error.unwrap())))
    } else if self.entity_not_exist_error.is_some() {
      Err(thrift::Error::User(Box::new(self.entity_not_exist_error.unwrap())))
    } else if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.domain_not_active_error.is_some() {
      Err(thrift::Error::User(Box::new(self.domain_not_active_error.unwrap())))
    } else if self.client_version_not_supported_error.is_some() {
      Err(thrift::Error::User(Box::new(self.client_version_not_supported_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceDeprecateDomainResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::BadRequestError> = None;
    let mut f_3: Option<shared::EntityNotExistsError> = None;
    let mut f_4: Option<shared::ServiceBusyError> = None;
    let mut f_5: Option<shared::DomainNotActiveError> = None;
    let mut f_6: Option<shared::ClientVersionNotSupportedError> = None;
    let mut f_7: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::BadRequestError::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        3 => {
          let val = shared::EntityNotExistsError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = shared::DomainNotActiveError::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = shared::ClientVersionNotSupportedError::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceDeprecateDomainResult {
      bad_request_error: f_1,
      entity_not_exist_error: f_3,
      service_busy_error: f_4,
      domain_not_active_error: f_5,
      client_version_not_supported_error: f_6,
      access_denied_error: f_7,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServiceDeprecateDomainResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.bad_request_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("badRequestError", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_not_exist_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("entityNotExistError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.domain_not_active_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("domainNotActiveError", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_version_not_supported_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientVersionNotSupportedError", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceDeleteDomainArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceDeleteDomainArgs {
  delete_request: shared::DeleteDomainRequest,
}

impl WorkflowServiceDeleteDomainArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceDeleteDomainArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::DeleteDomainRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::DeleteDomainRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WorkflowServiceDeleteDomainArgs.delete_request", &f_1)?;
    let ret = WorkflowServiceDeleteDomainArgs {
      delete_request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DeleteDomain_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("deleteRequest", TType::Struct, 1))?;
    self.delete_request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceDeleteDomainResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceDeleteDomainResult {
  bad_request_error: Option<shared::BadRequestError>,
  service_busy_error: Option<shared::ServiceBusyError>,
  client_version_not_supported_error: Option<shared::ClientVersionNotSupportedError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServiceDeleteDomainResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.bad_request_error.is_some() {
      Err(thrift::Error::User(Box::new(self.bad_request_error.unwrap())))
    } else if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.client_version_not_supported_error.is_some() {
      Err(thrift::Error::User(Box::new(self.client_version_not_supported_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceDeleteDomainResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::BadRequestError> = None;
    let mut f_2: Option<shared::ServiceBusyError> = None;
    let mut f_3: Option<shared::ClientVersionNotSupportedError> = None;
    let mut f_4: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::BadRequestError::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = shared::ClientVersionNotSupportedError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceDeleteDomainResult {
      bad_request_error: f_1,
      service_busy_error: f_2,
      client_version_not_supported_error: f_3,
      access_denied_error: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServiceDeleteDomainResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.bad_request_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("badRequestError", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_version_not_supported_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientVersionNotSupportedError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceListFailoverHistoryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceListFailoverHistoryArgs {
  list_request: shared::ListFailoverHistoryRequest,
}

impl WorkflowServiceListFailoverHistoryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceListFailoverHistoryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::ListFailoverHistoryRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::ListFailoverHistoryRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WorkflowServiceListFailoverHistoryArgs.list_request", &f_1)?;
    let ret = WorkflowServiceListFailoverHistoryArgs {
      list_request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ListFailoverHistory_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("listRequest", TType::Struct, 1))?;
    self.list_request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceListFailoverHistoryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceListFailoverHistoryResult {
  result_value: Option<shared::ListFailoverHistoryResponse>,
  bad_request_error: Option<shared::BadRequestError>,
  service_busy_error: Option<shared::ServiceBusyError>,
  client_version_not_supported_error: Option<shared::ClientVersionNotSupportedError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServiceListFailoverHistoryResult {
  fn ok_or(self) -> thrift::Result<shared::ListFailoverHistoryResponse> {
    if self.bad_request_error.is_some() {
      Err(thrift::Error::User(Box::new(self.bad_request_error.unwrap())))
    } else if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.client_version_not_supported_error.is_some() {
      Err(thrift::Error::User(Box::new(self.client_version_not_supported_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for WorkflowServiceListFailoverHistory"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceListFailoverHistoryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<shared::ListFailoverHistoryResponse> = None;
    let mut f_1: Option<shared::BadRequestError> = None;
    let mut f_2: Option<shared::ServiceBusyError> = None;
    let mut f_3: Option<shared::ClientVersionNotSupportedError> = None;
    let mut f_4: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = shared::ListFailoverHistoryResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = shared::BadRequestError::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = shared::ClientVersionNotSupportedError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceListFailoverHistoryResult {
      result_value: f_0,
      bad_request_error: f_1,
      service_busy_error: f_2,
      client_version_not_supported_error: f_3,
      access_denied_error: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServiceListFailoverHistoryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.bad_request_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("badRequestError", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_version_not_supported_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientVersionNotSupportedError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceRestartWorkflowExecutionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceRestartWorkflowExecutionArgs {
  restart_request: shared::RestartWorkflowExecutionRequest,
}

impl WorkflowServiceRestartWorkflowExecutionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceRestartWorkflowExecutionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::RestartWorkflowExecutionRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::RestartWorkflowExecutionRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WorkflowServiceRestartWorkflowExecutionArgs.restart_request", &f_1)?;
    let ret = WorkflowServiceRestartWorkflowExecutionArgs {
      restart_request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RestartWorkflowExecution_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("restartRequest", TType::Struct, 1))?;
    self.restart_request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceRestartWorkflowExecutionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceRestartWorkflowExecutionResult {
  result_value: Option<shared::RestartWorkflowExecutionResponse>,
  bad_request_error: Option<shared::BadRequestError>,
  service_busy_error: Option<shared::ServiceBusyError>,
  domain_not_active_error: Option<shared::DomainNotActiveError>,
  limit_exceeded_error: Option<shared::LimitExceededError>,
  entity_not_exist_error: Option<shared::EntityNotExistsError>,
  client_version_not_supported_error: Option<shared::ClientVersionNotSupportedError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServiceRestartWorkflowExecutionResult {
  fn ok_or(self) -> thrift::Result<shared::RestartWorkflowExecutionResponse> {
    if self.bad_request_error.is_some() {
      Err(thrift::Error::User(Box::new(self.bad_request_error.unwrap())))
    } else if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.domain_not_active_error.is_some() {
      Err(thrift::Error::User(Box::new(self.domain_not_active_error.unwrap())))
    } else if self.limit_exceeded_error.is_some() {
      Err(thrift::Error::User(Box::new(self.limit_exceeded_error.unwrap())))
    } else if self.entity_not_exist_error.is_some() {
      Err(thrift::Error::User(Box::new(self.entity_not_exist_error.unwrap())))
    } else if self.client_version_not_supported_error.is_some() {
      Err(thrift::Error::User(Box::new(self.client_version_not_supported_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for WorkflowServiceRestartWorkflowExecution"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceRestartWorkflowExecutionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<shared::RestartWorkflowExecutionResponse> = None;
    let mut f_1: Option<shared::BadRequestError> = None;
    let mut f_2: Option<shared::ServiceBusyError> = None;
    let mut f_3: Option<shared::DomainNotActiveError> = None;
    let mut f_4: Option<shared::LimitExceededError> = None;
    let mut f_5: Option<shared::EntityNotExistsError> = None;
    let mut f_6: Option<shared::ClientVersionNotSupportedError> = None;
    let mut f_7: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = shared::RestartWorkflowExecutionResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = shared::BadRequestError::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = shared::DomainNotActiveError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = shared::LimitExceededError::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = shared::EntityNotExistsError::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = shared::ClientVersionNotSupportedError::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceRestartWorkflowExecutionResult {
      result_value: f_0,
      bad_request_error: f_1,
      service_busy_error: f_2,
      domain_not_active_error: f_3,
      limit_exceeded_error: f_4,
      entity_not_exist_error: f_5,
      client_version_not_supported_error: f_6,
      access_denied_error: f_7,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServiceRestartWorkflowExecutionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.bad_request_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("badRequestError", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.domain_not_active_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("domainNotActiveError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.limit_exceeded_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("limitExceededError", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_not_exist_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("entityNotExistError", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_version_not_supported_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientVersionNotSupportedError", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceDiagnoseWorkflowExecutionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceDiagnoseWorkflowExecutionArgs {
  diagnose_request: shared::DiagnoseWorkflowExecutionRequest,
}

impl WorkflowServiceDiagnoseWorkflowExecutionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceDiagnoseWorkflowExecutionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::DiagnoseWorkflowExecutionRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::DiagnoseWorkflowExecutionRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WorkflowServiceDiagnoseWorkflowExecutionArgs.diagnose_request", &f_1)?;
    let ret = WorkflowServiceDiagnoseWorkflowExecutionArgs {
      diagnose_request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DiagnoseWorkflowExecution_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("diagnoseRequest", TType::Struct, 1))?;
    self.diagnose_request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceDiagnoseWorkflowExecutionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceDiagnoseWorkflowExecutionResult {
  result_value: Option<shared::DiagnoseWorkflowExecutionResponse>,
  domain_not_active_error: Option<shared::DomainNotActiveError>,
  service_busy_error: Option<shared::ServiceBusyError>,
  entity_not_exist_error: Option<shared::EntityNotExistsError>,
  client_version_not_supported_error: Option<shared::ClientVersionNotSupportedError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServiceDiagnoseWorkflowExecutionResult {
  fn ok_or(self) -> thrift::Result<shared::DiagnoseWorkflowExecutionResponse> {
    if self.domain_not_active_error.is_some() {
      Err(thrift::Error::User(Box::new(self.domain_not_active_error.unwrap())))
    } else if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.entity_not_exist_error.is_some() {
      Err(thrift::Error::User(Box::new(self.entity_not_exist_error.unwrap())))
    } else if self.client_version_not_supported_error.is_some() {
      Err(thrift::Error::User(Box::new(self.client_version_not_supported_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for WorkflowServiceDiagnoseWorkflowExecution"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceDiagnoseWorkflowExecutionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<shared::DiagnoseWorkflowExecutionResponse> = None;
    let mut f_1: Option<shared::DomainNotActiveError> = None;
    let mut f_2: Option<shared::ServiceBusyError> = None;
    let mut f_3: Option<shared::EntityNotExistsError> = None;
    let mut f_4: Option<shared::ClientVersionNotSupportedError> = None;
    let mut f_5: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = shared::DiagnoseWorkflowExecutionResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = shared::DomainNotActiveError::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = shared::EntityNotExistsError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = shared::ClientVersionNotSupportedError::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceDiagnoseWorkflowExecutionResult {
      result_value: f_0,
      domain_not_active_error: f_1,
      service_busy_error: f_2,
      entity_not_exist_error: f_3,
      client_version_not_supported_error: f_4,
      access_denied_error: f_5,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServiceDiagnoseWorkflowExecutionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.domain_not_active_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("domainNotActiveError", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_not_exist_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("entityNotExistError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_version_not_supported_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientVersionNotSupportedError", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceStartWorkflowExecutionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceStartWorkflowExecutionArgs {
  start_request: shared::StartWorkflowExecutionRequest,
}

impl WorkflowServiceStartWorkflowExecutionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceStartWorkflowExecutionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::StartWorkflowExecutionRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::StartWorkflowExecutionRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WorkflowServiceStartWorkflowExecutionArgs.start_request", &f_1)?;
    let ret = WorkflowServiceStartWorkflowExecutionArgs {
      start_request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("StartWorkflowExecution_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("startRequest", TType::Struct, 1))?;
    self.start_request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceStartWorkflowExecutionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceStartWorkflowExecutionResult {
  result_value: Option<shared::StartWorkflowExecutionResponse>,
  bad_request_error: Option<shared::BadRequestError>,
  session_already_exist_error: Option<shared::WorkflowExecutionAlreadyStartedError>,
  service_busy_error: Option<shared::ServiceBusyError>,
  domain_not_active_error: Option<shared::DomainNotActiveError>,
  limit_exceeded_error: Option<shared::LimitExceededError>,
  entity_not_exist_error: Option<shared::EntityNotExistsError>,
  client_version_not_supported_error: Option<shared::ClientVersionNotSupportedError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServiceStartWorkflowExecutionResult {
  fn ok_or(self) -> thrift::Result<shared::StartWorkflowExecutionResponse> {
    if self.bad_request_error.is_some() {
      Err(thrift::Error::User(Box::new(self.bad_request_error.unwrap())))
    } else if self.session_already_exist_error.is_some() {
      Err(thrift::Error::User(Box::new(self.session_already_exist_error.unwrap())))
    } else if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.domain_not_active_error.is_some() {
      Err(thrift::Error::User(Box::new(self.domain_not_active_error.unwrap())))
    } else if self.limit_exceeded_error.is_some() {
      Err(thrift::Error::User(Box::new(self.limit_exceeded_error.unwrap())))
    } else if self.entity_not_exist_error.is_some() {
      Err(thrift::Error::User(Box::new(self.entity_not_exist_error.unwrap())))
    } else if self.client_version_not_supported_error.is_some() {
      Err(thrift::Error::User(Box::new(self.client_version_not_supported_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for WorkflowServiceStartWorkflowExecution"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceStartWorkflowExecutionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<shared::StartWorkflowExecutionResponse> = None;
    let mut f_1: Option<shared::BadRequestError> = None;
    let mut f_3: Option<shared::WorkflowExecutionAlreadyStartedError> = None;
    let mut f_4: Option<shared::ServiceBusyError> = None;
    let mut f_5: Option<shared::DomainNotActiveError> = None;
    let mut f_6: Option<shared::LimitExceededError> = None;
    let mut f_7: Option<shared::EntityNotExistsError> = None;
    let mut f_8: Option<shared::ClientVersionNotSupportedError> = None;
    let mut f_9: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = shared::StartWorkflowExecutionResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = shared::BadRequestError::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        3 => {
          let val = shared::WorkflowExecutionAlreadyStartedError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = shared::DomainNotActiveError::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = shared::LimitExceededError::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = shared::EntityNotExistsError::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = shared::ClientVersionNotSupportedError::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        9 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceStartWorkflowExecutionResult {
      result_value: f_0,
      bad_request_error: f_1,
      session_already_exist_error: f_3,
      service_busy_error: f_4,
      domain_not_active_error: f_5,
      limit_exceeded_error: f_6,
      entity_not_exist_error: f_7,
      client_version_not_supported_error: f_8,
      access_denied_error: f_9,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServiceStartWorkflowExecutionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.bad_request_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("badRequestError", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.session_already_exist_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("sessionAlreadyExistError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.domain_not_active_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("domainNotActiveError", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.limit_exceeded_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("limitExceededError", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_not_exist_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("entityNotExistError", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_version_not_supported_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientVersionNotSupportedError", TType::Struct, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 9))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceStartWorkflowExecutionAsyncArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceStartWorkflowExecutionAsyncArgs {
  start_request: shared::StartWorkflowExecutionAsyncRequest,
}

impl WorkflowServiceStartWorkflowExecutionAsyncArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceStartWorkflowExecutionAsyncArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::StartWorkflowExecutionAsyncRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::StartWorkflowExecutionAsyncRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WorkflowServiceStartWorkflowExecutionAsyncArgs.start_request", &f_1)?;
    let ret = WorkflowServiceStartWorkflowExecutionAsyncArgs {
      start_request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("StartWorkflowExecutionAsync_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("startRequest", TType::Struct, 1))?;
    self.start_request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceStartWorkflowExecutionAsyncResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceStartWorkflowExecutionAsyncResult {
  result_value: Option<shared::StartWorkflowExecutionAsyncResponse>,
  bad_request_error: Option<shared::BadRequestError>,
  session_already_exist_error: Option<shared::WorkflowExecutionAlreadyStartedError>,
  service_busy_error: Option<shared::ServiceBusyError>,
  domain_not_active_error: Option<shared::DomainNotActiveError>,
  limit_exceeded_error: Option<shared::LimitExceededError>,
  entity_not_exist_error: Option<shared::EntityNotExistsError>,
  client_version_not_supported_error: Option<shared::ClientVersionNotSupportedError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServiceStartWorkflowExecutionAsyncResult {
  fn ok_or(self) -> thrift::Result<shared::StartWorkflowExecutionAsyncResponse> {
    if self.bad_request_error.is_some() {
      Err(thrift::Error::User(Box::new(self.bad_request_error.unwrap())))
    } else if self.session_already_exist_error.is_some() {
      Err(thrift::Error::User(Box::new(self.session_already_exist_error.unwrap())))
    } else if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.domain_not_active_error.is_some() {
      Err(thrift::Error::User(Box::new(self.domain_not_active_error.unwrap())))
    } else if self.limit_exceeded_error.is_some() {
      Err(thrift::Error::User(Box::new(self.limit_exceeded_error.unwrap())))
    } else if self.entity_not_exist_error.is_some() {
      Err(thrift::Error::User(Box::new(self.entity_not_exist_error.unwrap())))
    } else if self.client_version_not_supported_error.is_some() {
      Err(thrift::Error::User(Box::new(self.client_version_not_supported_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for WorkflowServiceStartWorkflowExecutionAsync"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceStartWorkflowExecutionAsyncResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<shared::StartWorkflowExecutionAsyncResponse> = None;
    let mut f_1: Option<shared::BadRequestError> = None;
    let mut f_3: Option<shared::WorkflowExecutionAlreadyStartedError> = None;
    let mut f_4: Option<shared::ServiceBusyError> = None;
    let mut f_5: Option<shared::DomainNotActiveError> = None;
    let mut f_6: Option<shared::LimitExceededError> = None;
    let mut f_7: Option<shared::EntityNotExistsError> = None;
    let mut f_8: Option<shared::ClientVersionNotSupportedError> = None;
    let mut f_9: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = shared::StartWorkflowExecutionAsyncResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = shared::BadRequestError::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        3 => {
          let val = shared::WorkflowExecutionAlreadyStartedError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = shared::DomainNotActiveError::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = shared::LimitExceededError::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = shared::EntityNotExistsError::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = shared::ClientVersionNotSupportedError::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        9 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceStartWorkflowExecutionAsyncResult {
      result_value: f_0,
      bad_request_error: f_1,
      session_already_exist_error: f_3,
      service_busy_error: f_4,
      domain_not_active_error: f_5,
      limit_exceeded_error: f_6,
      entity_not_exist_error: f_7,
      client_version_not_supported_error: f_8,
      access_denied_error: f_9,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServiceStartWorkflowExecutionAsyncResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.bad_request_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("badRequestError", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.session_already_exist_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("sessionAlreadyExistError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.domain_not_active_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("domainNotActiveError", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.limit_exceeded_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("limitExceededError", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_not_exist_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("entityNotExistError", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_version_not_supported_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientVersionNotSupportedError", TType::Struct, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 9))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceGetWorkflowExecutionHistoryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceGetWorkflowExecutionHistoryArgs {
  get_request: shared::GetWorkflowExecutionHistoryRequest,
}

impl WorkflowServiceGetWorkflowExecutionHistoryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceGetWorkflowExecutionHistoryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::GetWorkflowExecutionHistoryRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::GetWorkflowExecutionHistoryRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WorkflowServiceGetWorkflowExecutionHistoryArgs.get_request", &f_1)?;
    let ret = WorkflowServiceGetWorkflowExecutionHistoryArgs {
      get_request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetWorkflowExecutionHistory_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("getRequest", TType::Struct, 1))?;
    self.get_request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceGetWorkflowExecutionHistoryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceGetWorkflowExecutionHistoryResult {
  result_value: Option<shared::GetWorkflowExecutionHistoryResponse>,
  bad_request_error: Option<shared::BadRequestError>,
  entity_not_exist_error: Option<shared::EntityNotExistsError>,
  service_busy_error: Option<shared::ServiceBusyError>,
  client_version_not_supported_error: Option<shared::ClientVersionNotSupportedError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServiceGetWorkflowExecutionHistoryResult {
  fn ok_or(self) -> thrift::Result<shared::GetWorkflowExecutionHistoryResponse> {
    if self.bad_request_error.is_some() {
      Err(thrift::Error::User(Box::new(self.bad_request_error.unwrap())))
    } else if self.entity_not_exist_error.is_some() {
      Err(thrift::Error::User(Box::new(self.entity_not_exist_error.unwrap())))
    } else if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.client_version_not_supported_error.is_some() {
      Err(thrift::Error::User(Box::new(self.client_version_not_supported_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for WorkflowServiceGetWorkflowExecutionHistory"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceGetWorkflowExecutionHistoryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<shared::GetWorkflowExecutionHistoryResponse> = None;
    let mut f_1: Option<shared::BadRequestError> = None;
    let mut f_3: Option<shared::EntityNotExistsError> = None;
    let mut f_4: Option<shared::ServiceBusyError> = None;
    let mut f_5: Option<shared::ClientVersionNotSupportedError> = None;
    let mut f_6: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = shared::GetWorkflowExecutionHistoryResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = shared::BadRequestError::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        3 => {
          let val = shared::EntityNotExistsError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = shared::ClientVersionNotSupportedError::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceGetWorkflowExecutionHistoryResult {
      result_value: f_0,
      bad_request_error: f_1,
      entity_not_exist_error: f_3,
      service_busy_error: f_4,
      client_version_not_supported_error: f_5,
      access_denied_error: f_6,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServiceGetWorkflowExecutionHistoryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.bad_request_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("badRequestError", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_not_exist_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("entityNotExistError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_version_not_supported_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientVersionNotSupportedError", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServicePollForDecisionTaskArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServicePollForDecisionTaskArgs {
  poll_request: shared::PollForDecisionTaskRequest,
}

impl WorkflowServicePollForDecisionTaskArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServicePollForDecisionTaskArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::PollForDecisionTaskRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::PollForDecisionTaskRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WorkflowServicePollForDecisionTaskArgs.poll_request", &f_1)?;
    let ret = WorkflowServicePollForDecisionTaskArgs {
      poll_request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PollForDecisionTask_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pollRequest", TType::Struct, 1))?;
    self.poll_request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServicePollForDecisionTaskResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServicePollForDecisionTaskResult {
  result_value: Option<shared::PollForDecisionTaskResponse>,
  bad_request_error: Option<shared::BadRequestError>,
  service_busy_error: Option<shared::ServiceBusyError>,
  limit_exceeded_error: Option<shared::LimitExceededError>,
  entity_not_exist_error: Option<shared::EntityNotExistsError>,
  domain_not_active_error: Option<shared::DomainNotActiveError>,
  client_version_not_supported_error: Option<shared::ClientVersionNotSupportedError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServicePollForDecisionTaskResult {
  fn ok_or(self) -> thrift::Result<shared::PollForDecisionTaskResponse> {
    if self.bad_request_error.is_some() {
      Err(thrift::Error::User(Box::new(self.bad_request_error.unwrap())))
    } else if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.limit_exceeded_error.is_some() {
      Err(thrift::Error::User(Box::new(self.limit_exceeded_error.unwrap())))
    } else if self.entity_not_exist_error.is_some() {
      Err(thrift::Error::User(Box::new(self.entity_not_exist_error.unwrap())))
    } else if self.domain_not_active_error.is_some() {
      Err(thrift::Error::User(Box::new(self.domain_not_active_error.unwrap())))
    } else if self.client_version_not_supported_error.is_some() {
      Err(thrift::Error::User(Box::new(self.client_version_not_supported_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for WorkflowServicePollForDecisionTask"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServicePollForDecisionTaskResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<shared::PollForDecisionTaskResponse> = None;
    let mut f_1: Option<shared::BadRequestError> = None;
    let mut f_3: Option<shared::ServiceBusyError> = None;
    let mut f_4: Option<shared::LimitExceededError> = None;
    let mut f_5: Option<shared::EntityNotExistsError> = None;
    let mut f_6: Option<shared::DomainNotActiveError> = None;
    let mut f_7: Option<shared::ClientVersionNotSupportedError> = None;
    let mut f_8: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = shared::PollForDecisionTaskResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = shared::BadRequestError::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        3 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = shared::LimitExceededError::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = shared::EntityNotExistsError::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = shared::DomainNotActiveError::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = shared::ClientVersionNotSupportedError::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServicePollForDecisionTaskResult {
      result_value: f_0,
      bad_request_error: f_1,
      service_busy_error: f_3,
      limit_exceeded_error: f_4,
      entity_not_exist_error: f_5,
      domain_not_active_error: f_6,
      client_version_not_supported_error: f_7,
      access_denied_error: f_8,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServicePollForDecisionTaskResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.bad_request_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("badRequestError", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.limit_exceeded_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("limitExceededError", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_not_exist_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("entityNotExistError", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.domain_not_active_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("domainNotActiveError", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_version_not_supported_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientVersionNotSupportedError", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceRespondDecisionTaskCompletedArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceRespondDecisionTaskCompletedArgs {
  complete_request: shared::RespondDecisionTaskCompletedRequest,
}

impl WorkflowServiceRespondDecisionTaskCompletedArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceRespondDecisionTaskCompletedArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::RespondDecisionTaskCompletedRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::RespondDecisionTaskCompletedRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WorkflowServiceRespondDecisionTaskCompletedArgs.complete_request", &f_1)?;
    let ret = WorkflowServiceRespondDecisionTaskCompletedArgs {
      complete_request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RespondDecisionTaskCompleted_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("completeRequest", TType::Struct, 1))?;
    self.complete_request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceRespondDecisionTaskCompletedResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceRespondDecisionTaskCompletedResult {
  result_value: Option<shared::RespondDecisionTaskCompletedResponse>,
  bad_request_error: Option<shared::BadRequestError>,
  entity_not_exist_error: Option<shared::EntityNotExistsError>,
  domain_not_active_error: Option<shared::DomainNotActiveError>,
  limit_exceeded_error: Option<shared::LimitExceededError>,
  service_busy_error: Option<shared::ServiceBusyError>,
  client_version_not_supported_error: Option<shared::ClientVersionNotSupportedError>,
  workflow_execution_already_completed_error: Option<shared::WorkflowExecutionAlreadyCompletedError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServiceRespondDecisionTaskCompletedResult {
  fn ok_or(self) -> thrift::Result<shared::RespondDecisionTaskCompletedResponse> {
    if self.bad_request_error.is_some() {
      Err(thrift::Error::User(Box::new(self.bad_request_error.unwrap())))
    } else if self.entity_not_exist_error.is_some() {
      Err(thrift::Error::User(Box::new(self.entity_not_exist_error.unwrap())))
    } else if self.domain_not_active_error.is_some() {
      Err(thrift::Error::User(Box::new(self.domain_not_active_error.unwrap())))
    } else if self.limit_exceeded_error.is_some() {
      Err(thrift::Error::User(Box::new(self.limit_exceeded_error.unwrap())))
    } else if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.client_version_not_supported_error.is_some() {
      Err(thrift::Error::User(Box::new(self.client_version_not_supported_error.unwrap())))
    } else if self.workflow_execution_already_completed_error.is_some() {
      Err(thrift::Error::User(Box::new(self.workflow_execution_already_completed_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for WorkflowServiceRespondDecisionTaskCompleted"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceRespondDecisionTaskCompletedResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<shared::RespondDecisionTaskCompletedResponse> = None;
    let mut f_1: Option<shared::BadRequestError> = None;
    let mut f_3: Option<shared::EntityNotExistsError> = None;
    let mut f_4: Option<shared::DomainNotActiveError> = None;
    let mut f_5: Option<shared::LimitExceededError> = None;
    let mut f_6: Option<shared::ServiceBusyError> = None;
    let mut f_7: Option<shared::ClientVersionNotSupportedError> = None;
    let mut f_8: Option<shared::WorkflowExecutionAlreadyCompletedError> = None;
    let mut f_9: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = shared::RespondDecisionTaskCompletedResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = shared::BadRequestError::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        3 => {
          let val = shared::EntityNotExistsError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = shared::DomainNotActiveError::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = shared::LimitExceededError::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = shared::ClientVersionNotSupportedError::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = shared::WorkflowExecutionAlreadyCompletedError::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        9 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceRespondDecisionTaskCompletedResult {
      result_value: f_0,
      bad_request_error: f_1,
      entity_not_exist_error: f_3,
      domain_not_active_error: f_4,
      limit_exceeded_error: f_5,
      service_busy_error: f_6,
      client_version_not_supported_error: f_7,
      workflow_execution_already_completed_error: f_8,
      access_denied_error: f_9,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServiceRespondDecisionTaskCompletedResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.bad_request_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("badRequestError", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_not_exist_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("entityNotExistError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.domain_not_active_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("domainNotActiveError", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.limit_exceeded_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("limitExceededError", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_version_not_supported_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientVersionNotSupportedError", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_execution_already_completed_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecutionAlreadyCompletedError", TType::Struct, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 9))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceRespondDecisionTaskFailedArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceRespondDecisionTaskFailedArgs {
  failed_request: shared::RespondDecisionTaskFailedRequest,
}

impl WorkflowServiceRespondDecisionTaskFailedArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceRespondDecisionTaskFailedArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::RespondDecisionTaskFailedRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::RespondDecisionTaskFailedRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WorkflowServiceRespondDecisionTaskFailedArgs.failed_request", &f_1)?;
    let ret = WorkflowServiceRespondDecisionTaskFailedArgs {
      failed_request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RespondDecisionTaskFailed_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("failedRequest", TType::Struct, 1))?;
    self.failed_request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceRespondDecisionTaskFailedResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceRespondDecisionTaskFailedResult {
  bad_request_error: Option<shared::BadRequestError>,
  entity_not_exist_error: Option<shared::EntityNotExistsError>,
  domain_not_active_error: Option<shared::DomainNotActiveError>,
  limit_exceeded_error: Option<shared::LimitExceededError>,
  service_busy_error: Option<shared::ServiceBusyError>,
  client_version_not_supported_error: Option<shared::ClientVersionNotSupportedError>,
  workflow_execution_already_completed_error: Option<shared::WorkflowExecutionAlreadyCompletedError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServiceRespondDecisionTaskFailedResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.bad_request_error.is_some() {
      Err(thrift::Error::User(Box::new(self.bad_request_error.unwrap())))
    } else if self.entity_not_exist_error.is_some() {
      Err(thrift::Error::User(Box::new(self.entity_not_exist_error.unwrap())))
    } else if self.domain_not_active_error.is_some() {
      Err(thrift::Error::User(Box::new(self.domain_not_active_error.unwrap())))
    } else if self.limit_exceeded_error.is_some() {
      Err(thrift::Error::User(Box::new(self.limit_exceeded_error.unwrap())))
    } else if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.client_version_not_supported_error.is_some() {
      Err(thrift::Error::User(Box::new(self.client_version_not_supported_error.unwrap())))
    } else if self.workflow_execution_already_completed_error.is_some() {
      Err(thrift::Error::User(Box::new(self.workflow_execution_already_completed_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceRespondDecisionTaskFailedResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::BadRequestError> = None;
    let mut f_3: Option<shared::EntityNotExistsError> = None;
    let mut f_4: Option<shared::DomainNotActiveError> = None;
    let mut f_5: Option<shared::LimitExceededError> = None;
    let mut f_6: Option<shared::ServiceBusyError> = None;
    let mut f_7: Option<shared::ClientVersionNotSupportedError> = None;
    let mut f_8: Option<shared::WorkflowExecutionAlreadyCompletedError> = None;
    let mut f_9: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::BadRequestError::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        3 => {
          let val = shared::EntityNotExistsError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = shared::DomainNotActiveError::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = shared::LimitExceededError::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = shared::ClientVersionNotSupportedError::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = shared::WorkflowExecutionAlreadyCompletedError::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        9 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceRespondDecisionTaskFailedResult {
      bad_request_error: f_1,
      entity_not_exist_error: f_3,
      domain_not_active_error: f_4,
      limit_exceeded_error: f_5,
      service_busy_error: f_6,
      client_version_not_supported_error: f_7,
      workflow_execution_already_completed_error: f_8,
      access_denied_error: f_9,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServiceRespondDecisionTaskFailedResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.bad_request_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("badRequestError", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_not_exist_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("entityNotExistError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.domain_not_active_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("domainNotActiveError", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.limit_exceeded_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("limitExceededError", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_version_not_supported_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientVersionNotSupportedError", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_execution_already_completed_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecutionAlreadyCompletedError", TType::Struct, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 9))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServicePollForActivityTaskArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServicePollForActivityTaskArgs {
  poll_request: shared::PollForActivityTaskRequest,
}

impl WorkflowServicePollForActivityTaskArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServicePollForActivityTaskArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::PollForActivityTaskRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::PollForActivityTaskRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WorkflowServicePollForActivityTaskArgs.poll_request", &f_1)?;
    let ret = WorkflowServicePollForActivityTaskArgs {
      poll_request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PollForActivityTask_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pollRequest", TType::Struct, 1))?;
    self.poll_request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServicePollForActivityTaskResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServicePollForActivityTaskResult {
  result_value: Option<shared::PollForActivityTaskResponse>,
  bad_request_error: Option<shared::BadRequestError>,
  service_busy_error: Option<shared::ServiceBusyError>,
  limit_exceeded_error: Option<shared::LimitExceededError>,
  entity_not_exist_error: Option<shared::EntityNotExistsError>,
  domain_not_active_error: Option<shared::DomainNotActiveError>,
  client_version_not_supported_error: Option<shared::ClientVersionNotSupportedError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServicePollForActivityTaskResult {
  fn ok_or(self) -> thrift::Result<shared::PollForActivityTaskResponse> {
    if self.bad_request_error.is_some() {
      Err(thrift::Error::User(Box::new(self.bad_request_error.unwrap())))
    } else if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.limit_exceeded_error.is_some() {
      Err(thrift::Error::User(Box::new(self.limit_exceeded_error.unwrap())))
    } else if self.entity_not_exist_error.is_some() {
      Err(thrift::Error::User(Box::new(self.entity_not_exist_error.unwrap())))
    } else if self.domain_not_active_error.is_some() {
      Err(thrift::Error::User(Box::new(self.domain_not_active_error.unwrap())))
    } else if self.client_version_not_supported_error.is_some() {
      Err(thrift::Error::User(Box::new(self.client_version_not_supported_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for WorkflowServicePollForActivityTask"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServicePollForActivityTaskResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<shared::PollForActivityTaskResponse> = None;
    let mut f_1: Option<shared::BadRequestError> = None;
    let mut f_3: Option<shared::ServiceBusyError> = None;
    let mut f_4: Option<shared::LimitExceededError> = None;
    let mut f_5: Option<shared::EntityNotExistsError> = None;
    let mut f_6: Option<shared::DomainNotActiveError> = None;
    let mut f_7: Option<shared::ClientVersionNotSupportedError> = None;
    let mut f_8: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = shared::PollForActivityTaskResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = shared::BadRequestError::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        3 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = shared::LimitExceededError::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = shared::EntityNotExistsError::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = shared::DomainNotActiveError::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = shared::ClientVersionNotSupportedError::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServicePollForActivityTaskResult {
      result_value: f_0,
      bad_request_error: f_1,
      service_busy_error: f_3,
      limit_exceeded_error: f_4,
      entity_not_exist_error: f_5,
      domain_not_active_error: f_6,
      client_version_not_supported_error: f_7,
      access_denied_error: f_8,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServicePollForActivityTaskResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.bad_request_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("badRequestError", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.limit_exceeded_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("limitExceededError", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_not_exist_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("entityNotExistError", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.domain_not_active_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("domainNotActiveError", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_version_not_supported_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientVersionNotSupportedError", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceRecordActivityTaskHeartbeatArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceRecordActivityTaskHeartbeatArgs {
  heartbeat_request: shared::RecordActivityTaskHeartbeatRequest,
}

impl WorkflowServiceRecordActivityTaskHeartbeatArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceRecordActivityTaskHeartbeatArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::RecordActivityTaskHeartbeatRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::RecordActivityTaskHeartbeatRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WorkflowServiceRecordActivityTaskHeartbeatArgs.heartbeat_request", &f_1)?;
    let ret = WorkflowServiceRecordActivityTaskHeartbeatArgs {
      heartbeat_request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RecordActivityTaskHeartbeat_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("heartbeatRequest", TType::Struct, 1))?;
    self.heartbeat_request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceRecordActivityTaskHeartbeatResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceRecordActivityTaskHeartbeatResult {
  result_value: Option<shared::RecordActivityTaskHeartbeatResponse>,
  bad_request_error: Option<shared::BadRequestError>,
  entity_not_exist_error: Option<shared::EntityNotExistsError>,
  domain_not_active_error: Option<shared::DomainNotActiveError>,
  limit_exceeded_error: Option<shared::LimitExceededError>,
  service_busy_error: Option<shared::ServiceBusyError>,
  client_version_not_supported_error: Option<shared::ClientVersionNotSupportedError>,
  workflow_execution_already_completed_error: Option<shared::WorkflowExecutionAlreadyCompletedError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServiceRecordActivityTaskHeartbeatResult {
  fn ok_or(self) -> thrift::Result<shared::RecordActivityTaskHeartbeatResponse> {
    if self.bad_request_error.is_some() {
      Err(thrift::Error::User(Box::new(self.bad_request_error.unwrap())))
    } else if self.entity_not_exist_error.is_some() {
      Err(thrift::Error::User(Box::new(self.entity_not_exist_error.unwrap())))
    } else if self.domain_not_active_error.is_some() {
      Err(thrift::Error::User(Box::new(self.domain_not_active_error.unwrap())))
    } else if self.limit_exceeded_error.is_some() {
      Err(thrift::Error::User(Box::new(self.limit_exceeded_error.unwrap())))
    } else if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.client_version_not_supported_error.is_some() {
      Err(thrift::Error::User(Box::new(self.client_version_not_supported_error.unwrap())))
    } else if self.workflow_execution_already_completed_error.is_some() {
      Err(thrift::Error::User(Box::new(self.workflow_execution_already_completed_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for WorkflowServiceRecordActivityTaskHeartbeat"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceRecordActivityTaskHeartbeatResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<shared::RecordActivityTaskHeartbeatResponse> = None;
    let mut f_1: Option<shared::BadRequestError> = None;
    let mut f_3: Option<shared::EntityNotExistsError> = None;
    let mut f_4: Option<shared::DomainNotActiveError> = None;
    let mut f_5: Option<shared::LimitExceededError> = None;
    let mut f_6: Option<shared::ServiceBusyError> = None;
    let mut f_7: Option<shared::ClientVersionNotSupportedError> = None;
    let mut f_8: Option<shared::WorkflowExecutionAlreadyCompletedError> = None;
    let mut f_9: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = shared::RecordActivityTaskHeartbeatResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = shared::BadRequestError::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        3 => {
          let val = shared::EntityNotExistsError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = shared::DomainNotActiveError::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = shared::LimitExceededError::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = shared::ClientVersionNotSupportedError::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = shared::WorkflowExecutionAlreadyCompletedError::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        9 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceRecordActivityTaskHeartbeatResult {
      result_value: f_0,
      bad_request_error: f_1,
      entity_not_exist_error: f_3,
      domain_not_active_error: f_4,
      limit_exceeded_error: f_5,
      service_busy_error: f_6,
      client_version_not_supported_error: f_7,
      workflow_execution_already_completed_error: f_8,
      access_denied_error: f_9,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServiceRecordActivityTaskHeartbeatResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.bad_request_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("badRequestError", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_not_exist_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("entityNotExistError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.domain_not_active_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("domainNotActiveError", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.limit_exceeded_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("limitExceededError", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_version_not_supported_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientVersionNotSupportedError", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_execution_already_completed_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecutionAlreadyCompletedError", TType::Struct, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 9))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceRecordActivityTaskHeartbeatByIDArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceRecordActivityTaskHeartbeatByIDArgs {
  heartbeat_request: shared::RecordActivityTaskHeartbeatByIDRequest,
}

impl WorkflowServiceRecordActivityTaskHeartbeatByIDArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceRecordActivityTaskHeartbeatByIDArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::RecordActivityTaskHeartbeatByIDRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::RecordActivityTaskHeartbeatByIDRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WorkflowServiceRecordActivityTaskHeartbeatByIDArgs.heartbeat_request", &f_1)?;
    let ret = WorkflowServiceRecordActivityTaskHeartbeatByIDArgs {
      heartbeat_request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RecordActivityTaskHeartbeatByID_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("heartbeatRequest", TType::Struct, 1))?;
    self.heartbeat_request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceRecordActivityTaskHeartbeatByIDResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceRecordActivityTaskHeartbeatByIDResult {
  result_value: Option<shared::RecordActivityTaskHeartbeatResponse>,
  bad_request_error: Option<shared::BadRequestError>,
  entity_not_exist_error: Option<shared::EntityNotExistsError>,
  domain_not_active_error: Option<shared::DomainNotActiveError>,
  limit_exceeded_error: Option<shared::LimitExceededError>,
  service_busy_error: Option<shared::ServiceBusyError>,
  client_version_not_supported_error: Option<shared::ClientVersionNotSupportedError>,
  workflow_execution_already_completed_error: Option<shared::WorkflowExecutionAlreadyCompletedError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServiceRecordActivityTaskHeartbeatByIDResult {
  fn ok_or(self) -> thrift::Result<shared::RecordActivityTaskHeartbeatResponse> {
    if self.bad_request_error.is_some() {
      Err(thrift::Error::User(Box::new(self.bad_request_error.unwrap())))
    } else if self.entity_not_exist_error.is_some() {
      Err(thrift::Error::User(Box::new(self.entity_not_exist_error.unwrap())))
    } else if self.domain_not_active_error.is_some() {
      Err(thrift::Error::User(Box::new(self.domain_not_active_error.unwrap())))
    } else if self.limit_exceeded_error.is_some() {
      Err(thrift::Error::User(Box::new(self.limit_exceeded_error.unwrap())))
    } else if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.client_version_not_supported_error.is_some() {
      Err(thrift::Error::User(Box::new(self.client_version_not_supported_error.unwrap())))
    } else if self.workflow_execution_already_completed_error.is_some() {
      Err(thrift::Error::User(Box::new(self.workflow_execution_already_completed_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for WorkflowServiceRecordActivityTaskHeartbeatByID"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceRecordActivityTaskHeartbeatByIDResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<shared::RecordActivityTaskHeartbeatResponse> = None;
    let mut f_1: Option<shared::BadRequestError> = None;
    let mut f_3: Option<shared::EntityNotExistsError> = None;
    let mut f_4: Option<shared::DomainNotActiveError> = None;
    let mut f_5: Option<shared::LimitExceededError> = None;
    let mut f_6: Option<shared::ServiceBusyError> = None;
    let mut f_7: Option<shared::ClientVersionNotSupportedError> = None;
    let mut f_8: Option<shared::WorkflowExecutionAlreadyCompletedError> = None;
    let mut f_9: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = shared::RecordActivityTaskHeartbeatResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = shared::BadRequestError::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        3 => {
          let val = shared::EntityNotExistsError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = shared::DomainNotActiveError::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = shared::LimitExceededError::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = shared::ClientVersionNotSupportedError::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = shared::WorkflowExecutionAlreadyCompletedError::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        9 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceRecordActivityTaskHeartbeatByIDResult {
      result_value: f_0,
      bad_request_error: f_1,
      entity_not_exist_error: f_3,
      domain_not_active_error: f_4,
      limit_exceeded_error: f_5,
      service_busy_error: f_6,
      client_version_not_supported_error: f_7,
      workflow_execution_already_completed_error: f_8,
      access_denied_error: f_9,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServiceRecordActivityTaskHeartbeatByIDResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.bad_request_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("badRequestError", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_not_exist_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("entityNotExistError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.domain_not_active_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("domainNotActiveError", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.limit_exceeded_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("limitExceededError", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_version_not_supported_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientVersionNotSupportedError", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_execution_already_completed_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecutionAlreadyCompletedError", TType::Struct, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 9))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceRespondActivityTaskCompletedArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceRespondActivityTaskCompletedArgs {
  complete_request: shared::RespondActivityTaskCompletedRequest,
}

impl WorkflowServiceRespondActivityTaskCompletedArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceRespondActivityTaskCompletedArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::RespondActivityTaskCompletedRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::RespondActivityTaskCompletedRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WorkflowServiceRespondActivityTaskCompletedArgs.complete_request", &f_1)?;
    let ret = WorkflowServiceRespondActivityTaskCompletedArgs {
      complete_request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RespondActivityTaskCompleted_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("completeRequest", TType::Struct, 1))?;
    self.complete_request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceRespondActivityTaskCompletedResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceRespondActivityTaskCompletedResult {
  bad_request_error: Option<shared::BadRequestError>,
  entity_not_exist_error: Option<shared::EntityNotExistsError>,
  domain_not_active_error: Option<shared::DomainNotActiveError>,
  limit_exceeded_error: Option<shared::LimitExceededError>,
  service_busy_error: Option<shared::ServiceBusyError>,
  client_version_not_supported_error: Option<shared::ClientVersionNotSupportedError>,
  workflow_execution_already_completed_error: Option<shared::WorkflowExecutionAlreadyCompletedError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServiceRespondActivityTaskCompletedResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.bad_request_error.is_some() {
      Err(thrift::Error::User(Box::new(self.bad_request_error.unwrap())))
    } else if self.entity_not_exist_error.is_some() {
      Err(thrift::Error::User(Box::new(self.entity_not_exist_error.unwrap())))
    } else if self.domain_not_active_error.is_some() {
      Err(thrift::Error::User(Box::new(self.domain_not_active_error.unwrap())))
    } else if self.limit_exceeded_error.is_some() {
      Err(thrift::Error::User(Box::new(self.limit_exceeded_error.unwrap())))
    } else if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.client_version_not_supported_error.is_some() {
      Err(thrift::Error::User(Box::new(self.client_version_not_supported_error.unwrap())))
    } else if self.workflow_execution_already_completed_error.is_some() {
      Err(thrift::Error::User(Box::new(self.workflow_execution_already_completed_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceRespondActivityTaskCompletedResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::BadRequestError> = None;
    let mut f_3: Option<shared::EntityNotExistsError> = None;
    let mut f_4: Option<shared::DomainNotActiveError> = None;
    let mut f_5: Option<shared::LimitExceededError> = None;
    let mut f_6: Option<shared::ServiceBusyError> = None;
    let mut f_7: Option<shared::ClientVersionNotSupportedError> = None;
    let mut f_8: Option<shared::WorkflowExecutionAlreadyCompletedError> = None;
    let mut f_9: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::BadRequestError::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        3 => {
          let val = shared::EntityNotExistsError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = shared::DomainNotActiveError::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = shared::LimitExceededError::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = shared::ClientVersionNotSupportedError::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = shared::WorkflowExecutionAlreadyCompletedError::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        9 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceRespondActivityTaskCompletedResult {
      bad_request_error: f_1,
      entity_not_exist_error: f_3,
      domain_not_active_error: f_4,
      limit_exceeded_error: f_5,
      service_busy_error: f_6,
      client_version_not_supported_error: f_7,
      workflow_execution_already_completed_error: f_8,
      access_denied_error: f_9,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServiceRespondActivityTaskCompletedResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.bad_request_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("badRequestError", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_not_exist_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("entityNotExistError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.domain_not_active_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("domainNotActiveError", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.limit_exceeded_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("limitExceededError", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_version_not_supported_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientVersionNotSupportedError", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_execution_already_completed_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecutionAlreadyCompletedError", TType::Struct, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 9))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceRespondActivityTaskCompletedByIDArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceRespondActivityTaskCompletedByIDArgs {
  complete_request: shared::RespondActivityTaskCompletedByIDRequest,
}

impl WorkflowServiceRespondActivityTaskCompletedByIDArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceRespondActivityTaskCompletedByIDArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::RespondActivityTaskCompletedByIDRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::RespondActivityTaskCompletedByIDRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WorkflowServiceRespondActivityTaskCompletedByIDArgs.complete_request", &f_1)?;
    let ret = WorkflowServiceRespondActivityTaskCompletedByIDArgs {
      complete_request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RespondActivityTaskCompletedByID_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("completeRequest", TType::Struct, 1))?;
    self.complete_request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceRespondActivityTaskCompletedByIDResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceRespondActivityTaskCompletedByIDResult {
  bad_request_error: Option<shared::BadRequestError>,
  entity_not_exist_error: Option<shared::EntityNotExistsError>,
  domain_not_active_error: Option<shared::DomainNotActiveError>,
  limit_exceeded_error: Option<shared::LimitExceededError>,
  service_busy_error: Option<shared::ServiceBusyError>,
  client_version_not_supported_error: Option<shared::ClientVersionNotSupportedError>,
  workflow_execution_already_completed_error: Option<shared::WorkflowExecutionAlreadyCompletedError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServiceRespondActivityTaskCompletedByIDResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.bad_request_error.is_some() {
      Err(thrift::Error::User(Box::new(self.bad_request_error.unwrap())))
    } else if self.entity_not_exist_error.is_some() {
      Err(thrift::Error::User(Box::new(self.entity_not_exist_error.unwrap())))
    } else if self.domain_not_active_error.is_some() {
      Err(thrift::Error::User(Box::new(self.domain_not_active_error.unwrap())))
    } else if self.limit_exceeded_error.is_some() {
      Err(thrift::Error::User(Box::new(self.limit_exceeded_error.unwrap())))
    } else if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.client_version_not_supported_error.is_some() {
      Err(thrift::Error::User(Box::new(self.client_version_not_supported_error.unwrap())))
    } else if self.workflow_execution_already_completed_error.is_some() {
      Err(thrift::Error::User(Box::new(self.workflow_execution_already_completed_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceRespondActivityTaskCompletedByIDResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::BadRequestError> = None;
    let mut f_3: Option<shared::EntityNotExistsError> = None;
    let mut f_4: Option<shared::DomainNotActiveError> = None;
    let mut f_5: Option<shared::LimitExceededError> = None;
    let mut f_6: Option<shared::ServiceBusyError> = None;
    let mut f_7: Option<shared::ClientVersionNotSupportedError> = None;
    let mut f_8: Option<shared::WorkflowExecutionAlreadyCompletedError> = None;
    let mut f_9: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::BadRequestError::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        3 => {
          let val = shared::EntityNotExistsError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = shared::DomainNotActiveError::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = shared::LimitExceededError::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = shared::ClientVersionNotSupportedError::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = shared::WorkflowExecutionAlreadyCompletedError::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        9 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceRespondActivityTaskCompletedByIDResult {
      bad_request_error: f_1,
      entity_not_exist_error: f_3,
      domain_not_active_error: f_4,
      limit_exceeded_error: f_5,
      service_busy_error: f_6,
      client_version_not_supported_error: f_7,
      workflow_execution_already_completed_error: f_8,
      access_denied_error: f_9,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServiceRespondActivityTaskCompletedByIDResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.bad_request_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("badRequestError", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_not_exist_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("entityNotExistError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.domain_not_active_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("domainNotActiveError", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.limit_exceeded_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("limitExceededError", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_version_not_supported_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientVersionNotSupportedError", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_execution_already_completed_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecutionAlreadyCompletedError", TType::Struct, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 9))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceRespondActivityTaskFailedArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceRespondActivityTaskFailedArgs {
  fail_request: shared::RespondActivityTaskFailedRequest,
}

impl WorkflowServiceRespondActivityTaskFailedArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceRespondActivityTaskFailedArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::RespondActivityTaskFailedRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::RespondActivityTaskFailedRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WorkflowServiceRespondActivityTaskFailedArgs.fail_request", &f_1)?;
    let ret = WorkflowServiceRespondActivityTaskFailedArgs {
      fail_request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RespondActivityTaskFailed_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("failRequest", TType::Struct, 1))?;
    self.fail_request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceRespondActivityTaskFailedResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceRespondActivityTaskFailedResult {
  bad_request_error: Option<shared::BadRequestError>,
  entity_not_exist_error: Option<shared::EntityNotExistsError>,
  domain_not_active_error: Option<shared::DomainNotActiveError>,
  limit_exceeded_error: Option<shared::LimitExceededError>,
  service_busy_error: Option<shared::ServiceBusyError>,
  client_version_not_supported_error: Option<shared::ClientVersionNotSupportedError>,
  workflow_execution_already_completed_error: Option<shared::WorkflowExecutionAlreadyCompletedError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServiceRespondActivityTaskFailedResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.bad_request_error.is_some() {
      Err(thrift::Error::User(Box::new(self.bad_request_error.unwrap())))
    } else if self.entity_not_exist_error.is_some() {
      Err(thrift::Error::User(Box::new(self.entity_not_exist_error.unwrap())))
    } else if self.domain_not_active_error.is_some() {
      Err(thrift::Error::User(Box::new(self.domain_not_active_error.unwrap())))
    } else if self.limit_exceeded_error.is_some() {
      Err(thrift::Error::User(Box::new(self.limit_exceeded_error.unwrap())))
    } else if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.client_version_not_supported_error.is_some() {
      Err(thrift::Error::User(Box::new(self.client_version_not_supported_error.unwrap())))
    } else if self.workflow_execution_already_completed_error.is_some() {
      Err(thrift::Error::User(Box::new(self.workflow_execution_already_completed_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceRespondActivityTaskFailedResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::BadRequestError> = None;
    let mut f_3: Option<shared::EntityNotExistsError> = None;
    let mut f_4: Option<shared::DomainNotActiveError> = None;
    let mut f_5: Option<shared::LimitExceededError> = None;
    let mut f_6: Option<shared::ServiceBusyError> = None;
    let mut f_7: Option<shared::ClientVersionNotSupportedError> = None;
    let mut f_8: Option<shared::WorkflowExecutionAlreadyCompletedError> = None;
    let mut f_9: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::BadRequestError::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        3 => {
          let val = shared::EntityNotExistsError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = shared::DomainNotActiveError::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = shared::LimitExceededError::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = shared::ClientVersionNotSupportedError::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = shared::WorkflowExecutionAlreadyCompletedError::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        9 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceRespondActivityTaskFailedResult {
      bad_request_error: f_1,
      entity_not_exist_error: f_3,
      domain_not_active_error: f_4,
      limit_exceeded_error: f_5,
      service_busy_error: f_6,
      client_version_not_supported_error: f_7,
      workflow_execution_already_completed_error: f_8,
      access_denied_error: f_9,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServiceRespondActivityTaskFailedResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.bad_request_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("badRequestError", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_not_exist_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("entityNotExistError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.domain_not_active_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("domainNotActiveError", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.limit_exceeded_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("limitExceededError", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_version_not_supported_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientVersionNotSupportedError", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_execution_already_completed_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecutionAlreadyCompletedError", TType::Struct, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 9))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceRespondActivityTaskFailedByIDArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceRespondActivityTaskFailedByIDArgs {
  fail_request: shared::RespondActivityTaskFailedByIDRequest,
}

impl WorkflowServiceRespondActivityTaskFailedByIDArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceRespondActivityTaskFailedByIDArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::RespondActivityTaskFailedByIDRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::RespondActivityTaskFailedByIDRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WorkflowServiceRespondActivityTaskFailedByIDArgs.fail_request", &f_1)?;
    let ret = WorkflowServiceRespondActivityTaskFailedByIDArgs {
      fail_request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RespondActivityTaskFailedByID_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("failRequest", TType::Struct, 1))?;
    self.fail_request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceRespondActivityTaskFailedByIDResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceRespondActivityTaskFailedByIDResult {
  bad_request_error: Option<shared::BadRequestError>,
  entity_not_exist_error: Option<shared::EntityNotExistsError>,
  domain_not_active_error: Option<shared::DomainNotActiveError>,
  limit_exceeded_error: Option<shared::LimitExceededError>,
  service_busy_error: Option<shared::ServiceBusyError>,
  client_version_not_supported_error: Option<shared::ClientVersionNotSupportedError>,
  workflow_execution_already_completed_error: Option<shared::WorkflowExecutionAlreadyCompletedError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServiceRespondActivityTaskFailedByIDResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.bad_request_error.is_some() {
      Err(thrift::Error::User(Box::new(self.bad_request_error.unwrap())))
    } else if self.entity_not_exist_error.is_some() {
      Err(thrift::Error::User(Box::new(self.entity_not_exist_error.unwrap())))
    } else if self.domain_not_active_error.is_some() {
      Err(thrift::Error::User(Box::new(self.domain_not_active_error.unwrap())))
    } else if self.limit_exceeded_error.is_some() {
      Err(thrift::Error::User(Box::new(self.limit_exceeded_error.unwrap())))
    } else if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.client_version_not_supported_error.is_some() {
      Err(thrift::Error::User(Box::new(self.client_version_not_supported_error.unwrap())))
    } else if self.workflow_execution_already_completed_error.is_some() {
      Err(thrift::Error::User(Box::new(self.workflow_execution_already_completed_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceRespondActivityTaskFailedByIDResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::BadRequestError> = None;
    let mut f_3: Option<shared::EntityNotExistsError> = None;
    let mut f_4: Option<shared::DomainNotActiveError> = None;
    let mut f_5: Option<shared::LimitExceededError> = None;
    let mut f_6: Option<shared::ServiceBusyError> = None;
    let mut f_7: Option<shared::ClientVersionNotSupportedError> = None;
    let mut f_8: Option<shared::WorkflowExecutionAlreadyCompletedError> = None;
    let mut f_9: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::BadRequestError::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        3 => {
          let val = shared::EntityNotExistsError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = shared::DomainNotActiveError::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = shared::LimitExceededError::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = shared::ClientVersionNotSupportedError::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = shared::WorkflowExecutionAlreadyCompletedError::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        9 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceRespondActivityTaskFailedByIDResult {
      bad_request_error: f_1,
      entity_not_exist_error: f_3,
      domain_not_active_error: f_4,
      limit_exceeded_error: f_5,
      service_busy_error: f_6,
      client_version_not_supported_error: f_7,
      workflow_execution_already_completed_error: f_8,
      access_denied_error: f_9,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServiceRespondActivityTaskFailedByIDResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.bad_request_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("badRequestError", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_not_exist_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("entityNotExistError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.domain_not_active_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("domainNotActiveError", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.limit_exceeded_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("limitExceededError", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_version_not_supported_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientVersionNotSupportedError", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_execution_already_completed_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecutionAlreadyCompletedError", TType::Struct, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 9))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceRespondActivityTaskCanceledArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceRespondActivityTaskCanceledArgs {
  canceled_request: shared::RespondActivityTaskCanceledRequest,
}

impl WorkflowServiceRespondActivityTaskCanceledArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceRespondActivityTaskCanceledArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::RespondActivityTaskCanceledRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::RespondActivityTaskCanceledRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WorkflowServiceRespondActivityTaskCanceledArgs.canceled_request", &f_1)?;
    let ret = WorkflowServiceRespondActivityTaskCanceledArgs {
      canceled_request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RespondActivityTaskCanceled_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("canceledRequest", TType::Struct, 1))?;
    self.canceled_request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceRespondActivityTaskCanceledResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceRespondActivityTaskCanceledResult {
  bad_request_error: Option<shared::BadRequestError>,
  entity_not_exist_error: Option<shared::EntityNotExistsError>,
  domain_not_active_error: Option<shared::DomainNotActiveError>,
  limit_exceeded_error: Option<shared::LimitExceededError>,
  service_busy_error: Option<shared::ServiceBusyError>,
  client_version_not_supported_error: Option<shared::ClientVersionNotSupportedError>,
  workflow_execution_already_completed_error: Option<shared::WorkflowExecutionAlreadyCompletedError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServiceRespondActivityTaskCanceledResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.bad_request_error.is_some() {
      Err(thrift::Error::User(Box::new(self.bad_request_error.unwrap())))
    } else if self.entity_not_exist_error.is_some() {
      Err(thrift::Error::User(Box::new(self.entity_not_exist_error.unwrap())))
    } else if self.domain_not_active_error.is_some() {
      Err(thrift::Error::User(Box::new(self.domain_not_active_error.unwrap())))
    } else if self.limit_exceeded_error.is_some() {
      Err(thrift::Error::User(Box::new(self.limit_exceeded_error.unwrap())))
    } else if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.client_version_not_supported_error.is_some() {
      Err(thrift::Error::User(Box::new(self.client_version_not_supported_error.unwrap())))
    } else if self.workflow_execution_already_completed_error.is_some() {
      Err(thrift::Error::User(Box::new(self.workflow_execution_already_completed_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceRespondActivityTaskCanceledResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::BadRequestError> = None;
    let mut f_3: Option<shared::EntityNotExistsError> = None;
    let mut f_4: Option<shared::DomainNotActiveError> = None;
    let mut f_5: Option<shared::LimitExceededError> = None;
    let mut f_6: Option<shared::ServiceBusyError> = None;
    let mut f_7: Option<shared::ClientVersionNotSupportedError> = None;
    let mut f_8: Option<shared::WorkflowExecutionAlreadyCompletedError> = None;
    let mut f_9: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::BadRequestError::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        3 => {
          let val = shared::EntityNotExistsError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = shared::DomainNotActiveError::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = shared::LimitExceededError::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = shared::ClientVersionNotSupportedError::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = shared::WorkflowExecutionAlreadyCompletedError::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        9 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceRespondActivityTaskCanceledResult {
      bad_request_error: f_1,
      entity_not_exist_error: f_3,
      domain_not_active_error: f_4,
      limit_exceeded_error: f_5,
      service_busy_error: f_6,
      client_version_not_supported_error: f_7,
      workflow_execution_already_completed_error: f_8,
      access_denied_error: f_9,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServiceRespondActivityTaskCanceledResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.bad_request_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("badRequestError", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_not_exist_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("entityNotExistError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.domain_not_active_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("domainNotActiveError", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.limit_exceeded_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("limitExceededError", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_version_not_supported_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientVersionNotSupportedError", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_execution_already_completed_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecutionAlreadyCompletedError", TType::Struct, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 9))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceRespondActivityTaskCanceledByIDArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceRespondActivityTaskCanceledByIDArgs {
  canceled_request: shared::RespondActivityTaskCanceledByIDRequest,
}

impl WorkflowServiceRespondActivityTaskCanceledByIDArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceRespondActivityTaskCanceledByIDArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::RespondActivityTaskCanceledByIDRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::RespondActivityTaskCanceledByIDRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WorkflowServiceRespondActivityTaskCanceledByIDArgs.canceled_request", &f_1)?;
    let ret = WorkflowServiceRespondActivityTaskCanceledByIDArgs {
      canceled_request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RespondActivityTaskCanceledByID_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("canceledRequest", TType::Struct, 1))?;
    self.canceled_request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceRespondActivityTaskCanceledByIDResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceRespondActivityTaskCanceledByIDResult {
  bad_request_error: Option<shared::BadRequestError>,
  entity_not_exist_error: Option<shared::EntityNotExistsError>,
  domain_not_active_error: Option<shared::DomainNotActiveError>,
  limit_exceeded_error: Option<shared::LimitExceededError>,
  service_busy_error: Option<shared::ServiceBusyError>,
  client_version_not_supported_error: Option<shared::ClientVersionNotSupportedError>,
  workflow_execution_already_completed_error: Option<shared::WorkflowExecutionAlreadyCompletedError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServiceRespondActivityTaskCanceledByIDResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.bad_request_error.is_some() {
      Err(thrift::Error::User(Box::new(self.bad_request_error.unwrap())))
    } else if self.entity_not_exist_error.is_some() {
      Err(thrift::Error::User(Box::new(self.entity_not_exist_error.unwrap())))
    } else if self.domain_not_active_error.is_some() {
      Err(thrift::Error::User(Box::new(self.domain_not_active_error.unwrap())))
    } else if self.limit_exceeded_error.is_some() {
      Err(thrift::Error::User(Box::new(self.limit_exceeded_error.unwrap())))
    } else if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.client_version_not_supported_error.is_some() {
      Err(thrift::Error::User(Box::new(self.client_version_not_supported_error.unwrap())))
    } else if self.workflow_execution_already_completed_error.is_some() {
      Err(thrift::Error::User(Box::new(self.workflow_execution_already_completed_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceRespondActivityTaskCanceledByIDResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::BadRequestError> = None;
    let mut f_3: Option<shared::EntityNotExistsError> = None;
    let mut f_4: Option<shared::DomainNotActiveError> = None;
    let mut f_5: Option<shared::LimitExceededError> = None;
    let mut f_6: Option<shared::ServiceBusyError> = None;
    let mut f_7: Option<shared::ClientVersionNotSupportedError> = None;
    let mut f_8: Option<shared::WorkflowExecutionAlreadyCompletedError> = None;
    let mut f_9: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::BadRequestError::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        3 => {
          let val = shared::EntityNotExistsError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = shared::DomainNotActiveError::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = shared::LimitExceededError::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = shared::ClientVersionNotSupportedError::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = shared::WorkflowExecutionAlreadyCompletedError::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        9 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceRespondActivityTaskCanceledByIDResult {
      bad_request_error: f_1,
      entity_not_exist_error: f_3,
      domain_not_active_error: f_4,
      limit_exceeded_error: f_5,
      service_busy_error: f_6,
      client_version_not_supported_error: f_7,
      workflow_execution_already_completed_error: f_8,
      access_denied_error: f_9,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServiceRespondActivityTaskCanceledByIDResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.bad_request_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("badRequestError", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_not_exist_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("entityNotExistError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.domain_not_active_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("domainNotActiveError", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.limit_exceeded_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("limitExceededError", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_version_not_supported_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientVersionNotSupportedError", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_execution_already_completed_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecutionAlreadyCompletedError", TType::Struct, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 9))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceRequestCancelWorkflowExecutionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceRequestCancelWorkflowExecutionArgs {
  cancel_request: shared::RequestCancelWorkflowExecutionRequest,
}

impl WorkflowServiceRequestCancelWorkflowExecutionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceRequestCancelWorkflowExecutionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::RequestCancelWorkflowExecutionRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::RequestCancelWorkflowExecutionRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WorkflowServiceRequestCancelWorkflowExecutionArgs.cancel_request", &f_1)?;
    let ret = WorkflowServiceRequestCancelWorkflowExecutionArgs {
      cancel_request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RequestCancelWorkflowExecution_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("cancelRequest", TType::Struct, 1))?;
    self.cancel_request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceRequestCancelWorkflowExecutionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceRequestCancelWorkflowExecutionResult {
  bad_request_error: Option<shared::BadRequestError>,
  entity_not_exist_error: Option<shared::EntityNotExistsError>,
  cancellation_already_requested_error: Option<shared::CancellationAlreadyRequestedError>,
  service_busy_error: Option<shared::ServiceBusyError>,
  domain_not_active_error: Option<shared::DomainNotActiveError>,
  limit_exceeded_error: Option<shared::LimitExceededError>,
  client_version_not_supported_error: Option<shared::ClientVersionNotSupportedError>,
  workflow_execution_already_completed_error: Option<shared::WorkflowExecutionAlreadyCompletedError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServiceRequestCancelWorkflowExecutionResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.bad_request_error.is_some() {
      Err(thrift::Error::User(Box::new(self.bad_request_error.unwrap())))
    } else if self.entity_not_exist_error.is_some() {
      Err(thrift::Error::User(Box::new(self.entity_not_exist_error.unwrap())))
    } else if self.cancellation_already_requested_error.is_some() {
      Err(thrift::Error::User(Box::new(self.cancellation_already_requested_error.unwrap())))
    } else if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.domain_not_active_error.is_some() {
      Err(thrift::Error::User(Box::new(self.domain_not_active_error.unwrap())))
    } else if self.limit_exceeded_error.is_some() {
      Err(thrift::Error::User(Box::new(self.limit_exceeded_error.unwrap())))
    } else if self.client_version_not_supported_error.is_some() {
      Err(thrift::Error::User(Box::new(self.client_version_not_supported_error.unwrap())))
    } else if self.workflow_execution_already_completed_error.is_some() {
      Err(thrift::Error::User(Box::new(self.workflow_execution_already_completed_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceRequestCancelWorkflowExecutionResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::BadRequestError> = None;
    let mut f_3: Option<shared::EntityNotExistsError> = None;
    let mut f_4: Option<shared::CancellationAlreadyRequestedError> = None;
    let mut f_5: Option<shared::ServiceBusyError> = None;
    let mut f_6: Option<shared::DomainNotActiveError> = None;
    let mut f_7: Option<shared::LimitExceededError> = None;
    let mut f_8: Option<shared::ClientVersionNotSupportedError> = None;
    let mut f_9: Option<shared::WorkflowExecutionAlreadyCompletedError> = None;
    let mut f_10: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::BadRequestError::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        3 => {
          let val = shared::EntityNotExistsError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = shared::CancellationAlreadyRequestedError::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = shared::DomainNotActiveError::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = shared::LimitExceededError::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = shared::ClientVersionNotSupportedError::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        9 => {
          let val = shared::WorkflowExecutionAlreadyCompletedError::read_from_in_protocol(i_prot)?;
          f_9 = Some(val);
        },
        10 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceRequestCancelWorkflowExecutionResult {
      bad_request_error: f_1,
      entity_not_exist_error: f_3,
      cancellation_already_requested_error: f_4,
      service_busy_error: f_5,
      domain_not_active_error: f_6,
      limit_exceeded_error: f_7,
      client_version_not_supported_error: f_8,
      workflow_execution_already_completed_error: f_9,
      access_denied_error: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServiceRequestCancelWorkflowExecutionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.bad_request_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("badRequestError", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_not_exist_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("entityNotExistError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cancellation_already_requested_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("cancellationAlreadyRequestedError", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.domain_not_active_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("domainNotActiveError", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.limit_exceeded_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("limitExceededError", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_version_not_supported_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientVersionNotSupportedError", TType::Struct, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_execution_already_completed_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecutionAlreadyCompletedError", TType::Struct, 9))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceSignalWorkflowExecutionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceSignalWorkflowExecutionArgs {
  signal_request: shared::SignalWorkflowExecutionRequest,
}

impl WorkflowServiceSignalWorkflowExecutionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceSignalWorkflowExecutionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::SignalWorkflowExecutionRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::SignalWorkflowExecutionRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WorkflowServiceSignalWorkflowExecutionArgs.signal_request", &f_1)?;
    let ret = WorkflowServiceSignalWorkflowExecutionArgs {
      signal_request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SignalWorkflowExecution_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("signalRequest", TType::Struct, 1))?;
    self.signal_request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceSignalWorkflowExecutionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceSignalWorkflowExecutionResult {
  bad_request_error: Option<shared::BadRequestError>,
  entity_not_exist_error: Option<shared::EntityNotExistsError>,
  service_busy_error: Option<shared::ServiceBusyError>,
  domain_not_active_error: Option<shared::DomainNotActiveError>,
  limit_exceeded_error: Option<shared::LimitExceededError>,
  client_version_not_supported_error: Option<shared::ClientVersionNotSupportedError>,
  workflow_execution_already_completed_error: Option<shared::WorkflowExecutionAlreadyCompletedError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServiceSignalWorkflowExecutionResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.bad_request_error.is_some() {
      Err(thrift::Error::User(Box::new(self.bad_request_error.unwrap())))
    } else if self.entity_not_exist_error.is_some() {
      Err(thrift::Error::User(Box::new(self.entity_not_exist_error.unwrap())))
    } else if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.domain_not_active_error.is_some() {
      Err(thrift::Error::User(Box::new(self.domain_not_active_error.unwrap())))
    } else if self.limit_exceeded_error.is_some() {
      Err(thrift::Error::User(Box::new(self.limit_exceeded_error.unwrap())))
    } else if self.client_version_not_supported_error.is_some() {
      Err(thrift::Error::User(Box::new(self.client_version_not_supported_error.unwrap())))
    } else if self.workflow_execution_already_completed_error.is_some() {
      Err(thrift::Error::User(Box::new(self.workflow_execution_already_completed_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceSignalWorkflowExecutionResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::BadRequestError> = None;
    let mut f_3: Option<shared::EntityNotExistsError> = None;
    let mut f_4: Option<shared::ServiceBusyError> = None;
    let mut f_5: Option<shared::DomainNotActiveError> = None;
    let mut f_6: Option<shared::LimitExceededError> = None;
    let mut f_7: Option<shared::ClientVersionNotSupportedError> = None;
    let mut f_8: Option<shared::WorkflowExecutionAlreadyCompletedError> = None;
    let mut f_9: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::BadRequestError::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        3 => {
          let val = shared::EntityNotExistsError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = shared::DomainNotActiveError::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = shared::LimitExceededError::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = shared::ClientVersionNotSupportedError::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = shared::WorkflowExecutionAlreadyCompletedError::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        9 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceSignalWorkflowExecutionResult {
      bad_request_error: f_1,
      entity_not_exist_error: f_3,
      service_busy_error: f_4,
      domain_not_active_error: f_5,
      limit_exceeded_error: f_6,
      client_version_not_supported_error: f_7,
      workflow_execution_already_completed_error: f_8,
      access_denied_error: f_9,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServiceSignalWorkflowExecutionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.bad_request_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("badRequestError", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_not_exist_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("entityNotExistError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.domain_not_active_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("domainNotActiveError", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.limit_exceeded_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("limitExceededError", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_version_not_supported_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientVersionNotSupportedError", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_execution_already_completed_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecutionAlreadyCompletedError", TType::Struct, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 9))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceSignalWithStartWorkflowExecutionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceSignalWithStartWorkflowExecutionArgs {
  signal_with_start_request: shared::SignalWithStartWorkflowExecutionRequest,
}

impl WorkflowServiceSignalWithStartWorkflowExecutionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceSignalWithStartWorkflowExecutionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::SignalWithStartWorkflowExecutionRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::SignalWithStartWorkflowExecutionRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WorkflowServiceSignalWithStartWorkflowExecutionArgs.signal_with_start_request", &f_1)?;
    let ret = WorkflowServiceSignalWithStartWorkflowExecutionArgs {
      signal_with_start_request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SignalWithStartWorkflowExecution_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("signalWithStartRequest", TType::Struct, 1))?;
    self.signal_with_start_request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceSignalWithStartWorkflowExecutionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceSignalWithStartWorkflowExecutionResult {
  result_value: Option<shared::StartWorkflowExecutionResponse>,
  bad_request_error: Option<shared::BadRequestError>,
  entity_not_exist_error: Option<shared::EntityNotExistsError>,
  service_busy_error: Option<shared::ServiceBusyError>,
  domain_not_active_error: Option<shared::DomainNotActiveError>,
  limit_exceeded_error: Option<shared::LimitExceededError>,
  workflow_already_started_error: Option<shared::WorkflowExecutionAlreadyStartedError>,
  client_version_not_supported_error: Option<shared::ClientVersionNotSupportedError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServiceSignalWithStartWorkflowExecutionResult {
  fn ok_or(self) -> thrift::Result<shared::StartWorkflowExecutionResponse> {
    if self.bad_request_error.is_some() {
      Err(thrift::Error::User(Box::new(self.bad_request_error.unwrap())))
    } else if self.entity_not_exist_error.is_some() {
      Err(thrift::Error::User(Box::new(self.entity_not_exist_error.unwrap())))
    } else if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.domain_not_active_error.is_some() {
      Err(thrift::Error::User(Box::new(self.domain_not_active_error.unwrap())))
    } else if self.limit_exceeded_error.is_some() {
      Err(thrift::Error::User(Box::new(self.limit_exceeded_error.unwrap())))
    } else if self.workflow_already_started_error.is_some() {
      Err(thrift::Error::User(Box::new(self.workflow_already_started_error.unwrap())))
    } else if self.client_version_not_supported_error.is_some() {
      Err(thrift::Error::User(Box::new(self.client_version_not_supported_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for WorkflowServiceSignalWithStartWorkflowExecution"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceSignalWithStartWorkflowExecutionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<shared::StartWorkflowExecutionResponse> = None;
    let mut f_1: Option<shared::BadRequestError> = None;
    let mut f_3: Option<shared::EntityNotExistsError> = None;
    let mut f_4: Option<shared::ServiceBusyError> = None;
    let mut f_5: Option<shared::DomainNotActiveError> = None;
    let mut f_6: Option<shared::LimitExceededError> = None;
    let mut f_7: Option<shared::WorkflowExecutionAlreadyStartedError> = None;
    let mut f_8: Option<shared::ClientVersionNotSupportedError> = None;
    let mut f_9: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = shared::StartWorkflowExecutionResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = shared::BadRequestError::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        3 => {
          let val = shared::EntityNotExistsError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = shared::DomainNotActiveError::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = shared::LimitExceededError::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = shared::WorkflowExecutionAlreadyStartedError::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = shared::ClientVersionNotSupportedError::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        9 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceSignalWithStartWorkflowExecutionResult {
      result_value: f_0,
      bad_request_error: f_1,
      entity_not_exist_error: f_3,
      service_busy_error: f_4,
      domain_not_active_error: f_5,
      limit_exceeded_error: f_6,
      workflow_already_started_error: f_7,
      client_version_not_supported_error: f_8,
      access_denied_error: f_9,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServiceSignalWithStartWorkflowExecutionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.bad_request_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("badRequestError", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_not_exist_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("entityNotExistError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.domain_not_active_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("domainNotActiveError", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.limit_exceeded_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("limitExceededError", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_already_started_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowAlreadyStartedError", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_version_not_supported_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientVersionNotSupportedError", TType::Struct, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 9))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceSignalWithStartWorkflowExecutionAsyncArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceSignalWithStartWorkflowExecutionAsyncArgs {
  signal_with_start_request: shared::SignalWithStartWorkflowExecutionAsyncRequest,
}

impl WorkflowServiceSignalWithStartWorkflowExecutionAsyncArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceSignalWithStartWorkflowExecutionAsyncArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::SignalWithStartWorkflowExecutionAsyncRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::SignalWithStartWorkflowExecutionAsyncRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WorkflowServiceSignalWithStartWorkflowExecutionAsyncArgs.signal_with_start_request", &f_1)?;
    let ret = WorkflowServiceSignalWithStartWorkflowExecutionAsyncArgs {
      signal_with_start_request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SignalWithStartWorkflowExecutionAsync_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("signalWithStartRequest", TType::Struct, 1))?;
    self.signal_with_start_request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceSignalWithStartWorkflowExecutionAsyncResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceSignalWithStartWorkflowExecutionAsyncResult {
  result_value: Option<shared::SignalWithStartWorkflowExecutionAsyncResponse>,
  bad_request_error: Option<shared::BadRequestError>,
  session_already_exist_error: Option<shared::WorkflowExecutionAlreadyStartedError>,
  service_busy_error: Option<shared::ServiceBusyError>,
  domain_not_active_error: Option<shared::DomainNotActiveError>,
  limit_exceeded_error: Option<shared::LimitExceededError>,
  entity_not_exist_error: Option<shared::EntityNotExistsError>,
  client_version_not_supported_error: Option<shared::ClientVersionNotSupportedError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServiceSignalWithStartWorkflowExecutionAsyncResult {
  fn ok_or(self) -> thrift::Result<shared::SignalWithStartWorkflowExecutionAsyncResponse> {
    if self.bad_request_error.is_some() {
      Err(thrift::Error::User(Box::new(self.bad_request_error.unwrap())))
    } else if self.session_already_exist_error.is_some() {
      Err(thrift::Error::User(Box::new(self.session_already_exist_error.unwrap())))
    } else if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.domain_not_active_error.is_some() {
      Err(thrift::Error::User(Box::new(self.domain_not_active_error.unwrap())))
    } else if self.limit_exceeded_error.is_some() {
      Err(thrift::Error::User(Box::new(self.limit_exceeded_error.unwrap())))
    } else if self.entity_not_exist_error.is_some() {
      Err(thrift::Error::User(Box::new(self.entity_not_exist_error.unwrap())))
    } else if self.client_version_not_supported_error.is_some() {
      Err(thrift::Error::User(Box::new(self.client_version_not_supported_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for WorkflowServiceSignalWithStartWorkflowExecutionAsync"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceSignalWithStartWorkflowExecutionAsyncResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<shared::SignalWithStartWorkflowExecutionAsyncResponse> = None;
    let mut f_1: Option<shared::BadRequestError> = None;
    let mut f_3: Option<shared::WorkflowExecutionAlreadyStartedError> = None;
    let mut f_4: Option<shared::ServiceBusyError> = None;
    let mut f_5: Option<shared::DomainNotActiveError> = None;
    let mut f_6: Option<shared::LimitExceededError> = None;
    let mut f_7: Option<shared::EntityNotExistsError> = None;
    let mut f_8: Option<shared::ClientVersionNotSupportedError> = None;
    let mut f_9: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = shared::SignalWithStartWorkflowExecutionAsyncResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = shared::BadRequestError::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        3 => {
          let val = shared::WorkflowExecutionAlreadyStartedError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = shared::DomainNotActiveError::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = shared::LimitExceededError::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = shared::EntityNotExistsError::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = shared::ClientVersionNotSupportedError::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        9 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceSignalWithStartWorkflowExecutionAsyncResult {
      result_value: f_0,
      bad_request_error: f_1,
      session_already_exist_error: f_3,
      service_busy_error: f_4,
      domain_not_active_error: f_5,
      limit_exceeded_error: f_6,
      entity_not_exist_error: f_7,
      client_version_not_supported_error: f_8,
      access_denied_error: f_9,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServiceSignalWithStartWorkflowExecutionAsyncResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.bad_request_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("badRequestError", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.session_already_exist_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("sessionAlreadyExistError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.domain_not_active_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("domainNotActiveError", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.limit_exceeded_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("limitExceededError", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_not_exist_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("entityNotExistError", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_version_not_supported_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientVersionNotSupportedError", TType::Struct, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 9))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceResetWorkflowExecutionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceResetWorkflowExecutionArgs {
  reset_request: shared::ResetWorkflowExecutionRequest,
}

impl WorkflowServiceResetWorkflowExecutionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceResetWorkflowExecutionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::ResetWorkflowExecutionRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::ResetWorkflowExecutionRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WorkflowServiceResetWorkflowExecutionArgs.reset_request", &f_1)?;
    let ret = WorkflowServiceResetWorkflowExecutionArgs {
      reset_request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ResetWorkflowExecution_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("resetRequest", TType::Struct, 1))?;
    self.reset_request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceResetWorkflowExecutionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceResetWorkflowExecutionResult {
  result_value: Option<shared::ResetWorkflowExecutionResponse>,
  bad_request_error: Option<shared::BadRequestError>,
  entity_not_exist_error: Option<shared::EntityNotExistsError>,
  service_busy_error: Option<shared::ServiceBusyError>,
  domain_not_active_error: Option<shared::DomainNotActiveError>,
  limit_exceeded_error: Option<shared::LimitExceededError>,
  client_version_not_supported_error: Option<shared::ClientVersionNotSupportedError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServiceResetWorkflowExecutionResult {
  fn ok_or(self) -> thrift::Result<shared::ResetWorkflowExecutionResponse> {
    if self.bad_request_error.is_some() {
      Err(thrift::Error::User(Box::new(self.bad_request_error.unwrap())))
    } else if self.entity_not_exist_error.is_some() {
      Err(thrift::Error::User(Box::new(self.entity_not_exist_error.unwrap())))
    } else if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.domain_not_active_error.is_some() {
      Err(thrift::Error::User(Box::new(self.domain_not_active_error.unwrap())))
    } else if self.limit_exceeded_error.is_some() {
      Err(thrift::Error::User(Box::new(self.limit_exceeded_error.unwrap())))
    } else if self.client_version_not_supported_error.is_some() {
      Err(thrift::Error::User(Box::new(self.client_version_not_supported_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for WorkflowServiceResetWorkflowExecution"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceResetWorkflowExecutionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<shared::ResetWorkflowExecutionResponse> = None;
    let mut f_1: Option<shared::BadRequestError> = None;
    let mut f_3: Option<shared::EntityNotExistsError> = None;
    let mut f_4: Option<shared::ServiceBusyError> = None;
    let mut f_5: Option<shared::DomainNotActiveError> = None;
    let mut f_6: Option<shared::LimitExceededError> = None;
    let mut f_7: Option<shared::ClientVersionNotSupportedError> = None;
    let mut f_8: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = shared::ResetWorkflowExecutionResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = shared::BadRequestError::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        3 => {
          let val = shared::EntityNotExistsError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = shared::DomainNotActiveError::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = shared::LimitExceededError::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = shared::ClientVersionNotSupportedError::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceResetWorkflowExecutionResult {
      result_value: f_0,
      bad_request_error: f_1,
      entity_not_exist_error: f_3,
      service_busy_error: f_4,
      domain_not_active_error: f_5,
      limit_exceeded_error: f_6,
      client_version_not_supported_error: f_7,
      access_denied_error: f_8,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServiceResetWorkflowExecutionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.bad_request_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("badRequestError", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_not_exist_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("entityNotExistError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.domain_not_active_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("domainNotActiveError", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.limit_exceeded_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("limitExceededError", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_version_not_supported_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientVersionNotSupportedError", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceTerminateWorkflowExecutionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceTerminateWorkflowExecutionArgs {
  terminate_request: shared::TerminateWorkflowExecutionRequest,
}

impl WorkflowServiceTerminateWorkflowExecutionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceTerminateWorkflowExecutionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::TerminateWorkflowExecutionRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::TerminateWorkflowExecutionRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WorkflowServiceTerminateWorkflowExecutionArgs.terminate_request", &f_1)?;
    let ret = WorkflowServiceTerminateWorkflowExecutionArgs {
      terminate_request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TerminateWorkflowExecution_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("terminateRequest", TType::Struct, 1))?;
    self.terminate_request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceTerminateWorkflowExecutionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceTerminateWorkflowExecutionResult {
  bad_request_error: Option<shared::BadRequestError>,
  entity_not_exist_error: Option<shared::EntityNotExistsError>,
  service_busy_error: Option<shared::ServiceBusyError>,
  domain_not_active_error: Option<shared::DomainNotActiveError>,
  limit_exceeded_error: Option<shared::LimitExceededError>,
  client_version_not_supported_error: Option<shared::ClientVersionNotSupportedError>,
  workflow_execution_already_completed_error: Option<shared::WorkflowExecutionAlreadyCompletedError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServiceTerminateWorkflowExecutionResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.bad_request_error.is_some() {
      Err(thrift::Error::User(Box::new(self.bad_request_error.unwrap())))
    } else if self.entity_not_exist_error.is_some() {
      Err(thrift::Error::User(Box::new(self.entity_not_exist_error.unwrap())))
    } else if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.domain_not_active_error.is_some() {
      Err(thrift::Error::User(Box::new(self.domain_not_active_error.unwrap())))
    } else if self.limit_exceeded_error.is_some() {
      Err(thrift::Error::User(Box::new(self.limit_exceeded_error.unwrap())))
    } else if self.client_version_not_supported_error.is_some() {
      Err(thrift::Error::User(Box::new(self.client_version_not_supported_error.unwrap())))
    } else if self.workflow_execution_already_completed_error.is_some() {
      Err(thrift::Error::User(Box::new(self.workflow_execution_already_completed_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceTerminateWorkflowExecutionResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::BadRequestError> = None;
    let mut f_3: Option<shared::EntityNotExistsError> = None;
    let mut f_4: Option<shared::ServiceBusyError> = None;
    let mut f_5: Option<shared::DomainNotActiveError> = None;
    let mut f_6: Option<shared::LimitExceededError> = None;
    let mut f_7: Option<shared::ClientVersionNotSupportedError> = None;
    let mut f_8: Option<shared::WorkflowExecutionAlreadyCompletedError> = None;
    let mut f_9: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::BadRequestError::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        3 => {
          let val = shared::EntityNotExistsError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = shared::DomainNotActiveError::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = shared::LimitExceededError::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = shared::ClientVersionNotSupportedError::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = shared::WorkflowExecutionAlreadyCompletedError::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        9 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceTerminateWorkflowExecutionResult {
      bad_request_error: f_1,
      entity_not_exist_error: f_3,
      service_busy_error: f_4,
      domain_not_active_error: f_5,
      limit_exceeded_error: f_6,
      client_version_not_supported_error: f_7,
      workflow_execution_already_completed_error: f_8,
      access_denied_error: f_9,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServiceTerminateWorkflowExecutionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.bad_request_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("badRequestError", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_not_exist_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("entityNotExistError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.domain_not_active_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("domainNotActiveError", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.limit_exceeded_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("limitExceededError", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_version_not_supported_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientVersionNotSupportedError", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_execution_already_completed_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecutionAlreadyCompletedError", TType::Struct, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 9))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceListOpenWorkflowExecutionsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceListOpenWorkflowExecutionsArgs {
  list_request: shared::ListOpenWorkflowExecutionsRequest,
}

impl WorkflowServiceListOpenWorkflowExecutionsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceListOpenWorkflowExecutionsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::ListOpenWorkflowExecutionsRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::ListOpenWorkflowExecutionsRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WorkflowServiceListOpenWorkflowExecutionsArgs.list_request", &f_1)?;
    let ret = WorkflowServiceListOpenWorkflowExecutionsArgs {
      list_request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ListOpenWorkflowExecutions_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("listRequest", TType::Struct, 1))?;
    self.list_request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceListOpenWorkflowExecutionsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceListOpenWorkflowExecutionsResult {
  result_value: Option<shared::ListOpenWorkflowExecutionsResponse>,
  bad_request_error: Option<shared::BadRequestError>,
  entity_not_exist_error: Option<shared::EntityNotExistsError>,
  service_busy_error: Option<shared::ServiceBusyError>,
  limit_exceeded_error: Option<shared::LimitExceededError>,
  client_version_not_supported_error: Option<shared::ClientVersionNotSupportedError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServiceListOpenWorkflowExecutionsResult {
  fn ok_or(self) -> thrift::Result<shared::ListOpenWorkflowExecutionsResponse> {
    if self.bad_request_error.is_some() {
      Err(thrift::Error::User(Box::new(self.bad_request_error.unwrap())))
    } else if self.entity_not_exist_error.is_some() {
      Err(thrift::Error::User(Box::new(self.entity_not_exist_error.unwrap())))
    } else if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.limit_exceeded_error.is_some() {
      Err(thrift::Error::User(Box::new(self.limit_exceeded_error.unwrap())))
    } else if self.client_version_not_supported_error.is_some() {
      Err(thrift::Error::User(Box::new(self.client_version_not_supported_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for WorkflowServiceListOpenWorkflowExecutions"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceListOpenWorkflowExecutionsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<shared::ListOpenWorkflowExecutionsResponse> = None;
    let mut f_1: Option<shared::BadRequestError> = None;
    let mut f_3: Option<shared::EntityNotExistsError> = None;
    let mut f_4: Option<shared::ServiceBusyError> = None;
    let mut f_5: Option<shared::LimitExceededError> = None;
    let mut f_6: Option<shared::ClientVersionNotSupportedError> = None;
    let mut f_7: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = shared::ListOpenWorkflowExecutionsResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = shared::BadRequestError::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        3 => {
          let val = shared::EntityNotExistsError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = shared::LimitExceededError::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = shared::ClientVersionNotSupportedError::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceListOpenWorkflowExecutionsResult {
      result_value: f_0,
      bad_request_error: f_1,
      entity_not_exist_error: f_3,
      service_busy_error: f_4,
      limit_exceeded_error: f_5,
      client_version_not_supported_error: f_6,
      access_denied_error: f_7,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServiceListOpenWorkflowExecutionsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.bad_request_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("badRequestError", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_not_exist_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("entityNotExistError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.limit_exceeded_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("limitExceededError", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_version_not_supported_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientVersionNotSupportedError", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceListClosedWorkflowExecutionsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceListClosedWorkflowExecutionsArgs {
  list_request: shared::ListClosedWorkflowExecutionsRequest,
}

impl WorkflowServiceListClosedWorkflowExecutionsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceListClosedWorkflowExecutionsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::ListClosedWorkflowExecutionsRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::ListClosedWorkflowExecutionsRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WorkflowServiceListClosedWorkflowExecutionsArgs.list_request", &f_1)?;
    let ret = WorkflowServiceListClosedWorkflowExecutionsArgs {
      list_request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ListClosedWorkflowExecutions_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("listRequest", TType::Struct, 1))?;
    self.list_request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceListClosedWorkflowExecutionsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceListClosedWorkflowExecutionsResult {
  result_value: Option<shared::ListClosedWorkflowExecutionsResponse>,
  bad_request_error: Option<shared::BadRequestError>,
  entity_not_exist_error: Option<shared::EntityNotExistsError>,
  service_busy_error: Option<shared::ServiceBusyError>,
  client_version_not_supported_error: Option<shared::ClientVersionNotSupportedError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServiceListClosedWorkflowExecutionsResult {
  fn ok_or(self) -> thrift::Result<shared::ListClosedWorkflowExecutionsResponse> {
    if self.bad_request_error.is_some() {
      Err(thrift::Error::User(Box::new(self.bad_request_error.unwrap())))
    } else if self.entity_not_exist_error.is_some() {
      Err(thrift::Error::User(Box::new(self.entity_not_exist_error.unwrap())))
    } else if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.client_version_not_supported_error.is_some() {
      Err(thrift::Error::User(Box::new(self.client_version_not_supported_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for WorkflowServiceListClosedWorkflowExecutions"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceListClosedWorkflowExecutionsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<shared::ListClosedWorkflowExecutionsResponse> = None;
    let mut f_1: Option<shared::BadRequestError> = None;
    let mut f_3: Option<shared::EntityNotExistsError> = None;
    let mut f_4: Option<shared::ServiceBusyError> = None;
    let mut f_5: Option<shared::ClientVersionNotSupportedError> = None;
    let mut f_6: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = shared::ListClosedWorkflowExecutionsResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = shared::BadRequestError::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        3 => {
          let val = shared::EntityNotExistsError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = shared::ClientVersionNotSupportedError::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceListClosedWorkflowExecutionsResult {
      result_value: f_0,
      bad_request_error: f_1,
      entity_not_exist_error: f_3,
      service_busy_error: f_4,
      client_version_not_supported_error: f_5,
      access_denied_error: f_6,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServiceListClosedWorkflowExecutionsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.bad_request_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("badRequestError", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_not_exist_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("entityNotExistError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_version_not_supported_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientVersionNotSupportedError", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceListWorkflowExecutionsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceListWorkflowExecutionsArgs {
  list_request: shared::ListWorkflowExecutionsRequest,
}

impl WorkflowServiceListWorkflowExecutionsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceListWorkflowExecutionsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::ListWorkflowExecutionsRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::ListWorkflowExecutionsRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WorkflowServiceListWorkflowExecutionsArgs.list_request", &f_1)?;
    let ret = WorkflowServiceListWorkflowExecutionsArgs {
      list_request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ListWorkflowExecutions_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("listRequest", TType::Struct, 1))?;
    self.list_request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceListWorkflowExecutionsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceListWorkflowExecutionsResult {
  result_value: Option<shared::ListWorkflowExecutionsResponse>,
  bad_request_error: Option<shared::BadRequestError>,
  entity_not_exist_error: Option<shared::EntityNotExistsError>,
  service_busy_error: Option<shared::ServiceBusyError>,
  client_version_not_supported_error: Option<shared::ClientVersionNotSupportedError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServiceListWorkflowExecutionsResult {
  fn ok_or(self) -> thrift::Result<shared::ListWorkflowExecutionsResponse> {
    if self.bad_request_error.is_some() {
      Err(thrift::Error::User(Box::new(self.bad_request_error.unwrap())))
    } else if self.entity_not_exist_error.is_some() {
      Err(thrift::Error::User(Box::new(self.entity_not_exist_error.unwrap())))
    } else if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.client_version_not_supported_error.is_some() {
      Err(thrift::Error::User(Box::new(self.client_version_not_supported_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for WorkflowServiceListWorkflowExecutions"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceListWorkflowExecutionsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<shared::ListWorkflowExecutionsResponse> = None;
    let mut f_1: Option<shared::BadRequestError> = None;
    let mut f_3: Option<shared::EntityNotExistsError> = None;
    let mut f_4: Option<shared::ServiceBusyError> = None;
    let mut f_5: Option<shared::ClientVersionNotSupportedError> = None;
    let mut f_6: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = shared::ListWorkflowExecutionsResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = shared::BadRequestError::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        3 => {
          let val = shared::EntityNotExistsError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = shared::ClientVersionNotSupportedError::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceListWorkflowExecutionsResult {
      result_value: f_0,
      bad_request_error: f_1,
      entity_not_exist_error: f_3,
      service_busy_error: f_4,
      client_version_not_supported_error: f_5,
      access_denied_error: f_6,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServiceListWorkflowExecutionsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.bad_request_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("badRequestError", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_not_exist_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("entityNotExistError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_version_not_supported_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientVersionNotSupportedError", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceListArchivedWorkflowExecutionsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceListArchivedWorkflowExecutionsArgs {
  list_request: shared::ListArchivedWorkflowExecutionsRequest,
}

impl WorkflowServiceListArchivedWorkflowExecutionsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceListArchivedWorkflowExecutionsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::ListArchivedWorkflowExecutionsRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::ListArchivedWorkflowExecutionsRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WorkflowServiceListArchivedWorkflowExecutionsArgs.list_request", &f_1)?;
    let ret = WorkflowServiceListArchivedWorkflowExecutionsArgs {
      list_request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ListArchivedWorkflowExecutions_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("listRequest", TType::Struct, 1))?;
    self.list_request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceListArchivedWorkflowExecutionsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceListArchivedWorkflowExecutionsResult {
  result_value: Option<shared::ListArchivedWorkflowExecutionsResponse>,
  bad_request_error: Option<shared::BadRequestError>,
  entity_not_exist_error: Option<shared::EntityNotExistsError>,
  service_busy_error: Option<shared::ServiceBusyError>,
  client_version_not_supported_error: Option<shared::ClientVersionNotSupportedError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServiceListArchivedWorkflowExecutionsResult {
  fn ok_or(self) -> thrift::Result<shared::ListArchivedWorkflowExecutionsResponse> {
    if self.bad_request_error.is_some() {
      Err(thrift::Error::User(Box::new(self.bad_request_error.unwrap())))
    } else if self.entity_not_exist_error.is_some() {
      Err(thrift::Error::User(Box::new(self.entity_not_exist_error.unwrap())))
    } else if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.client_version_not_supported_error.is_some() {
      Err(thrift::Error::User(Box::new(self.client_version_not_supported_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for WorkflowServiceListArchivedWorkflowExecutions"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceListArchivedWorkflowExecutionsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<shared::ListArchivedWorkflowExecutionsResponse> = None;
    let mut f_1: Option<shared::BadRequestError> = None;
    let mut f_3: Option<shared::EntityNotExistsError> = None;
    let mut f_4: Option<shared::ServiceBusyError> = None;
    let mut f_5: Option<shared::ClientVersionNotSupportedError> = None;
    let mut f_6: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = shared::ListArchivedWorkflowExecutionsResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = shared::BadRequestError::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        3 => {
          let val = shared::EntityNotExistsError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = shared::ClientVersionNotSupportedError::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceListArchivedWorkflowExecutionsResult {
      result_value: f_0,
      bad_request_error: f_1,
      entity_not_exist_error: f_3,
      service_busy_error: f_4,
      client_version_not_supported_error: f_5,
      access_denied_error: f_6,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServiceListArchivedWorkflowExecutionsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.bad_request_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("badRequestError", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_not_exist_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("entityNotExistError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_version_not_supported_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientVersionNotSupportedError", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceScanWorkflowExecutionsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceScanWorkflowExecutionsArgs {
  list_request: shared::ListWorkflowExecutionsRequest,
}

impl WorkflowServiceScanWorkflowExecutionsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceScanWorkflowExecutionsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::ListWorkflowExecutionsRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::ListWorkflowExecutionsRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WorkflowServiceScanWorkflowExecutionsArgs.list_request", &f_1)?;
    let ret = WorkflowServiceScanWorkflowExecutionsArgs {
      list_request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ScanWorkflowExecutions_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("listRequest", TType::Struct, 1))?;
    self.list_request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceScanWorkflowExecutionsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceScanWorkflowExecutionsResult {
  result_value: Option<shared::ListWorkflowExecutionsResponse>,
  bad_request_error: Option<shared::BadRequestError>,
  entity_not_exist_error: Option<shared::EntityNotExistsError>,
  service_busy_error: Option<shared::ServiceBusyError>,
  client_version_not_supported_error: Option<shared::ClientVersionNotSupportedError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServiceScanWorkflowExecutionsResult {
  fn ok_or(self) -> thrift::Result<shared::ListWorkflowExecutionsResponse> {
    if self.bad_request_error.is_some() {
      Err(thrift::Error::User(Box::new(self.bad_request_error.unwrap())))
    } else if self.entity_not_exist_error.is_some() {
      Err(thrift::Error::User(Box::new(self.entity_not_exist_error.unwrap())))
    } else if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.client_version_not_supported_error.is_some() {
      Err(thrift::Error::User(Box::new(self.client_version_not_supported_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for WorkflowServiceScanWorkflowExecutions"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceScanWorkflowExecutionsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<shared::ListWorkflowExecutionsResponse> = None;
    let mut f_1: Option<shared::BadRequestError> = None;
    let mut f_3: Option<shared::EntityNotExistsError> = None;
    let mut f_4: Option<shared::ServiceBusyError> = None;
    let mut f_5: Option<shared::ClientVersionNotSupportedError> = None;
    let mut f_6: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = shared::ListWorkflowExecutionsResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = shared::BadRequestError::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        3 => {
          let val = shared::EntityNotExistsError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = shared::ClientVersionNotSupportedError::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceScanWorkflowExecutionsResult {
      result_value: f_0,
      bad_request_error: f_1,
      entity_not_exist_error: f_3,
      service_busy_error: f_4,
      client_version_not_supported_error: f_5,
      access_denied_error: f_6,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServiceScanWorkflowExecutionsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.bad_request_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("badRequestError", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_not_exist_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("entityNotExistError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_version_not_supported_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientVersionNotSupportedError", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceCountWorkflowExecutionsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceCountWorkflowExecutionsArgs {
  count_request: shared::CountWorkflowExecutionsRequest,
}

impl WorkflowServiceCountWorkflowExecutionsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceCountWorkflowExecutionsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::CountWorkflowExecutionsRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::CountWorkflowExecutionsRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WorkflowServiceCountWorkflowExecutionsArgs.count_request", &f_1)?;
    let ret = WorkflowServiceCountWorkflowExecutionsArgs {
      count_request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CountWorkflowExecutions_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("countRequest", TType::Struct, 1))?;
    self.count_request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceCountWorkflowExecutionsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceCountWorkflowExecutionsResult {
  result_value: Option<shared::CountWorkflowExecutionsResponse>,
  bad_request_error: Option<shared::BadRequestError>,
  entity_not_exist_error: Option<shared::EntityNotExistsError>,
  service_busy_error: Option<shared::ServiceBusyError>,
  client_version_not_supported_error: Option<shared::ClientVersionNotSupportedError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServiceCountWorkflowExecutionsResult {
  fn ok_or(self) -> thrift::Result<shared::CountWorkflowExecutionsResponse> {
    if self.bad_request_error.is_some() {
      Err(thrift::Error::User(Box::new(self.bad_request_error.unwrap())))
    } else if self.entity_not_exist_error.is_some() {
      Err(thrift::Error::User(Box::new(self.entity_not_exist_error.unwrap())))
    } else if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.client_version_not_supported_error.is_some() {
      Err(thrift::Error::User(Box::new(self.client_version_not_supported_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for WorkflowServiceCountWorkflowExecutions"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceCountWorkflowExecutionsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<shared::CountWorkflowExecutionsResponse> = None;
    let mut f_1: Option<shared::BadRequestError> = None;
    let mut f_3: Option<shared::EntityNotExistsError> = None;
    let mut f_4: Option<shared::ServiceBusyError> = None;
    let mut f_5: Option<shared::ClientVersionNotSupportedError> = None;
    let mut f_6: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = shared::CountWorkflowExecutionsResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = shared::BadRequestError::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        3 => {
          let val = shared::EntityNotExistsError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = shared::ClientVersionNotSupportedError::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceCountWorkflowExecutionsResult {
      result_value: f_0,
      bad_request_error: f_1,
      entity_not_exist_error: f_3,
      service_busy_error: f_4,
      client_version_not_supported_error: f_5,
      access_denied_error: f_6,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServiceCountWorkflowExecutionsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.bad_request_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("badRequestError", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_not_exist_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("entityNotExistError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_version_not_supported_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientVersionNotSupportedError", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceGetSearchAttributesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceGetSearchAttributesArgs {
}

impl WorkflowServiceGetSearchAttributesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceGetSearchAttributesArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      i_prot.skip(field_ident.field_type)?;
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceGetSearchAttributesArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetSearchAttributes_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceGetSearchAttributesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceGetSearchAttributesResult {
  result_value: Option<shared::GetSearchAttributesResponse>,
  service_busy_error: Option<shared::ServiceBusyError>,
  client_version_not_supported_error: Option<shared::ClientVersionNotSupportedError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServiceGetSearchAttributesResult {
  fn ok_or(self) -> thrift::Result<shared::GetSearchAttributesResponse> {
    if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.client_version_not_supported_error.is_some() {
      Err(thrift::Error::User(Box::new(self.client_version_not_supported_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for WorkflowServiceGetSearchAttributes"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceGetSearchAttributesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<shared::GetSearchAttributesResponse> = None;
    let mut f_2: Option<shared::ServiceBusyError> = None;
    let mut f_3: Option<shared::ClientVersionNotSupportedError> = None;
    let mut f_4: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = shared::GetSearchAttributesResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        2 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = shared::ClientVersionNotSupportedError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceGetSearchAttributesResult {
      result_value: f_0,
      service_busy_error: f_2,
      client_version_not_supported_error: f_3,
      access_denied_error: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServiceGetSearchAttributesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_version_not_supported_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientVersionNotSupportedError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceRespondQueryTaskCompletedArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceRespondQueryTaskCompletedArgs {
  complete_request: shared::RespondQueryTaskCompletedRequest,
}

impl WorkflowServiceRespondQueryTaskCompletedArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceRespondQueryTaskCompletedArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::RespondQueryTaskCompletedRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::RespondQueryTaskCompletedRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WorkflowServiceRespondQueryTaskCompletedArgs.complete_request", &f_1)?;
    let ret = WorkflowServiceRespondQueryTaskCompletedArgs {
      complete_request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RespondQueryTaskCompleted_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("completeRequest", TType::Struct, 1))?;
    self.complete_request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceRespondQueryTaskCompletedResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceRespondQueryTaskCompletedResult {
  bad_request_error: Option<shared::BadRequestError>,
  entity_not_exist_error: Option<shared::EntityNotExistsError>,
  limit_exceeded_error: Option<shared::LimitExceededError>,
  service_busy_error: Option<shared::ServiceBusyError>,
  domain_not_active_error: Option<shared::DomainNotActiveError>,
  client_version_not_supported_error: Option<shared::ClientVersionNotSupportedError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServiceRespondQueryTaskCompletedResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.bad_request_error.is_some() {
      Err(thrift::Error::User(Box::new(self.bad_request_error.unwrap())))
    } else if self.entity_not_exist_error.is_some() {
      Err(thrift::Error::User(Box::new(self.entity_not_exist_error.unwrap())))
    } else if self.limit_exceeded_error.is_some() {
      Err(thrift::Error::User(Box::new(self.limit_exceeded_error.unwrap())))
    } else if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.domain_not_active_error.is_some() {
      Err(thrift::Error::User(Box::new(self.domain_not_active_error.unwrap())))
    } else if self.client_version_not_supported_error.is_some() {
      Err(thrift::Error::User(Box::new(self.client_version_not_supported_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceRespondQueryTaskCompletedResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::BadRequestError> = None;
    let mut f_3: Option<shared::EntityNotExistsError> = None;
    let mut f_4: Option<shared::LimitExceededError> = None;
    let mut f_5: Option<shared::ServiceBusyError> = None;
    let mut f_6: Option<shared::DomainNotActiveError> = None;
    let mut f_7: Option<shared::ClientVersionNotSupportedError> = None;
    let mut f_8: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::BadRequestError::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        3 => {
          let val = shared::EntityNotExistsError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = shared::LimitExceededError::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = shared::DomainNotActiveError::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = shared::ClientVersionNotSupportedError::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceRespondQueryTaskCompletedResult {
      bad_request_error: f_1,
      entity_not_exist_error: f_3,
      limit_exceeded_error: f_4,
      service_busy_error: f_5,
      domain_not_active_error: f_6,
      client_version_not_supported_error: f_7,
      access_denied_error: f_8,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServiceRespondQueryTaskCompletedResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.bad_request_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("badRequestError", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_not_exist_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("entityNotExistError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.limit_exceeded_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("limitExceededError", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.domain_not_active_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("domainNotActiveError", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_version_not_supported_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientVersionNotSupportedError", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceResetStickyTaskListArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceResetStickyTaskListArgs {
  reset_request: shared::ResetStickyTaskListRequest,
}

impl WorkflowServiceResetStickyTaskListArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceResetStickyTaskListArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::ResetStickyTaskListRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::ResetStickyTaskListRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WorkflowServiceResetStickyTaskListArgs.reset_request", &f_1)?;
    let ret = WorkflowServiceResetStickyTaskListArgs {
      reset_request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ResetStickyTaskList_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("resetRequest", TType::Struct, 1))?;
    self.reset_request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceResetStickyTaskListResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceResetStickyTaskListResult {
  result_value: Option<shared::ResetStickyTaskListResponse>,
  bad_request_error: Option<shared::BadRequestError>,
  entity_not_exist_error: Option<shared::EntityNotExistsError>,
  limit_exceeded_error: Option<shared::LimitExceededError>,
  service_busy_error: Option<shared::ServiceBusyError>,
  domain_not_active_error: Option<shared::DomainNotActiveError>,
  client_version_not_supported_error: Option<shared::ClientVersionNotSupportedError>,
  workflow_execution_already_completed_error: Option<shared::WorkflowExecutionAlreadyCompletedError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServiceResetStickyTaskListResult {
  fn ok_or(self) -> thrift::Result<shared::ResetStickyTaskListResponse> {
    if self.bad_request_error.is_some() {
      Err(thrift::Error::User(Box::new(self.bad_request_error.unwrap())))
    } else if self.entity_not_exist_error.is_some() {
      Err(thrift::Error::User(Box::new(self.entity_not_exist_error.unwrap())))
    } else if self.limit_exceeded_error.is_some() {
      Err(thrift::Error::User(Box::new(self.limit_exceeded_error.unwrap())))
    } else if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.domain_not_active_error.is_some() {
      Err(thrift::Error::User(Box::new(self.domain_not_active_error.unwrap())))
    } else if self.client_version_not_supported_error.is_some() {
      Err(thrift::Error::User(Box::new(self.client_version_not_supported_error.unwrap())))
    } else if self.workflow_execution_already_completed_error.is_some() {
      Err(thrift::Error::User(Box::new(self.workflow_execution_already_completed_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for WorkflowServiceResetStickyTaskList"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceResetStickyTaskListResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<shared::ResetStickyTaskListResponse> = None;
    let mut f_1: Option<shared::BadRequestError> = None;
    let mut f_3: Option<shared::EntityNotExistsError> = None;
    let mut f_4: Option<shared::LimitExceededError> = None;
    let mut f_5: Option<shared::ServiceBusyError> = None;
    let mut f_6: Option<shared::DomainNotActiveError> = None;
    let mut f_7: Option<shared::ClientVersionNotSupportedError> = None;
    let mut f_8: Option<shared::WorkflowExecutionAlreadyCompletedError> = None;
    let mut f_9: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = shared::ResetStickyTaskListResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = shared::BadRequestError::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        3 => {
          let val = shared::EntityNotExistsError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = shared::LimitExceededError::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = shared::DomainNotActiveError::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = shared::ClientVersionNotSupportedError::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = shared::WorkflowExecutionAlreadyCompletedError::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        9 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceResetStickyTaskListResult {
      result_value: f_0,
      bad_request_error: f_1,
      entity_not_exist_error: f_3,
      limit_exceeded_error: f_4,
      service_busy_error: f_5,
      domain_not_active_error: f_6,
      client_version_not_supported_error: f_7,
      workflow_execution_already_completed_error: f_8,
      access_denied_error: f_9,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServiceResetStickyTaskListResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.bad_request_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("badRequestError", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_not_exist_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("entityNotExistError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.limit_exceeded_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("limitExceededError", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.domain_not_active_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("domainNotActiveError", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_version_not_supported_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientVersionNotSupportedError", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_execution_already_completed_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecutionAlreadyCompletedError", TType::Struct, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 9))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceQueryWorkflowArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceQueryWorkflowArgs {
  query_request: shared::QueryWorkflowRequest,
}

impl WorkflowServiceQueryWorkflowArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceQueryWorkflowArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::QueryWorkflowRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::QueryWorkflowRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WorkflowServiceQueryWorkflowArgs.query_request", &f_1)?;
    let ret = WorkflowServiceQueryWorkflowArgs {
      query_request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("QueryWorkflow_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("queryRequest", TType::Struct, 1))?;
    self.query_request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceQueryWorkflowResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceQueryWorkflowResult {
  result_value: Option<shared::QueryWorkflowResponse>,
  bad_request_error: Option<shared::BadRequestError>,
  entity_not_exist_error: Option<shared::EntityNotExistsError>,
  query_failed_error: Option<shared::QueryFailedError>,
  limit_exceeded_error: Option<shared::LimitExceededError>,
  service_busy_error: Option<shared::ServiceBusyError>,
  client_version_not_supported_error: Option<shared::ClientVersionNotSupportedError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServiceQueryWorkflowResult {
  fn ok_or(self) -> thrift::Result<shared::QueryWorkflowResponse> {
    if self.bad_request_error.is_some() {
      Err(thrift::Error::User(Box::new(self.bad_request_error.unwrap())))
    } else if self.entity_not_exist_error.is_some() {
      Err(thrift::Error::User(Box::new(self.entity_not_exist_error.unwrap())))
    } else if self.query_failed_error.is_some() {
      Err(thrift::Error::User(Box::new(self.query_failed_error.unwrap())))
    } else if self.limit_exceeded_error.is_some() {
      Err(thrift::Error::User(Box::new(self.limit_exceeded_error.unwrap())))
    } else if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.client_version_not_supported_error.is_some() {
      Err(thrift::Error::User(Box::new(self.client_version_not_supported_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for WorkflowServiceQueryWorkflow"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceQueryWorkflowResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<shared::QueryWorkflowResponse> = None;
    let mut f_1: Option<shared::BadRequestError> = None;
    let mut f_3: Option<shared::EntityNotExistsError> = None;
    let mut f_4: Option<shared::QueryFailedError> = None;
    let mut f_5: Option<shared::LimitExceededError> = None;
    let mut f_6: Option<shared::ServiceBusyError> = None;
    let mut f_7: Option<shared::ClientVersionNotSupportedError> = None;
    let mut f_8: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = shared::QueryWorkflowResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = shared::BadRequestError::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        3 => {
          let val = shared::EntityNotExistsError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = shared::QueryFailedError::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = shared::LimitExceededError::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = shared::ClientVersionNotSupportedError::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceQueryWorkflowResult {
      result_value: f_0,
      bad_request_error: f_1,
      entity_not_exist_error: f_3,
      query_failed_error: f_4,
      limit_exceeded_error: f_5,
      service_busy_error: f_6,
      client_version_not_supported_error: f_7,
      access_denied_error: f_8,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServiceQueryWorkflowResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.bad_request_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("badRequestError", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_not_exist_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("entityNotExistError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.query_failed_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("queryFailedError", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.limit_exceeded_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("limitExceededError", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_version_not_supported_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientVersionNotSupportedError", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceDescribeWorkflowExecutionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceDescribeWorkflowExecutionArgs {
  describe_request: shared::DescribeWorkflowExecutionRequest,
}

impl WorkflowServiceDescribeWorkflowExecutionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceDescribeWorkflowExecutionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::DescribeWorkflowExecutionRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::DescribeWorkflowExecutionRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WorkflowServiceDescribeWorkflowExecutionArgs.describe_request", &f_1)?;
    let ret = WorkflowServiceDescribeWorkflowExecutionArgs {
      describe_request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DescribeWorkflowExecution_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("describeRequest", TType::Struct, 1))?;
    self.describe_request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceDescribeWorkflowExecutionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceDescribeWorkflowExecutionResult {
  result_value: Option<shared::DescribeWorkflowExecutionResponse>,
  bad_request_error: Option<shared::BadRequestError>,
  entity_not_exist_error: Option<shared::EntityNotExistsError>,
  limit_exceeded_error: Option<shared::LimitExceededError>,
  service_busy_error: Option<shared::ServiceBusyError>,
  client_version_not_supported_error: Option<shared::ClientVersionNotSupportedError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServiceDescribeWorkflowExecutionResult {
  fn ok_or(self) -> thrift::Result<shared::DescribeWorkflowExecutionResponse> {
    if self.bad_request_error.is_some() {
      Err(thrift::Error::User(Box::new(self.bad_request_error.unwrap())))
    } else if self.entity_not_exist_error.is_some() {
      Err(thrift::Error::User(Box::new(self.entity_not_exist_error.unwrap())))
    } else if self.limit_exceeded_error.is_some() {
      Err(thrift::Error::User(Box::new(self.limit_exceeded_error.unwrap())))
    } else if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.client_version_not_supported_error.is_some() {
      Err(thrift::Error::User(Box::new(self.client_version_not_supported_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for WorkflowServiceDescribeWorkflowExecution"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceDescribeWorkflowExecutionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<shared::DescribeWorkflowExecutionResponse> = None;
    let mut f_1: Option<shared::BadRequestError> = None;
    let mut f_3: Option<shared::EntityNotExistsError> = None;
    let mut f_4: Option<shared::LimitExceededError> = None;
    let mut f_5: Option<shared::ServiceBusyError> = None;
    let mut f_6: Option<shared::ClientVersionNotSupportedError> = None;
    let mut f_7: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = shared::DescribeWorkflowExecutionResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = shared::BadRequestError::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        3 => {
          let val = shared::EntityNotExistsError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = shared::LimitExceededError::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = shared::ClientVersionNotSupportedError::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceDescribeWorkflowExecutionResult {
      result_value: f_0,
      bad_request_error: f_1,
      entity_not_exist_error: f_3,
      limit_exceeded_error: f_4,
      service_busy_error: f_5,
      client_version_not_supported_error: f_6,
      access_denied_error: f_7,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServiceDescribeWorkflowExecutionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.bad_request_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("badRequestError", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_not_exist_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("entityNotExistError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.limit_exceeded_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("limitExceededError", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_version_not_supported_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientVersionNotSupportedError", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceDescribeTaskListArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceDescribeTaskListArgs {
  request: shared::DescribeTaskListRequest,
}

impl WorkflowServiceDescribeTaskListArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceDescribeTaskListArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::DescribeTaskListRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::DescribeTaskListRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WorkflowServiceDescribeTaskListArgs.request", &f_1)?;
    let ret = WorkflowServiceDescribeTaskListArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DescribeTaskList_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceDescribeTaskListResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceDescribeTaskListResult {
  result_value: Option<shared::DescribeTaskListResponse>,
  bad_request_error: Option<shared::BadRequestError>,
  entity_not_exist_error: Option<shared::EntityNotExistsError>,
  limit_exceeded_error: Option<shared::LimitExceededError>,
  service_busy_error: Option<shared::ServiceBusyError>,
  client_version_not_supported_error: Option<shared::ClientVersionNotSupportedError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServiceDescribeTaskListResult {
  fn ok_or(self) -> thrift::Result<shared::DescribeTaskListResponse> {
    if self.bad_request_error.is_some() {
      Err(thrift::Error::User(Box::new(self.bad_request_error.unwrap())))
    } else if self.entity_not_exist_error.is_some() {
      Err(thrift::Error::User(Box::new(self.entity_not_exist_error.unwrap())))
    } else if self.limit_exceeded_error.is_some() {
      Err(thrift::Error::User(Box::new(self.limit_exceeded_error.unwrap())))
    } else if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.client_version_not_supported_error.is_some() {
      Err(thrift::Error::User(Box::new(self.client_version_not_supported_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for WorkflowServiceDescribeTaskList"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceDescribeTaskListResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<shared::DescribeTaskListResponse> = None;
    let mut f_1: Option<shared::BadRequestError> = None;
    let mut f_3: Option<shared::EntityNotExistsError> = None;
    let mut f_4: Option<shared::LimitExceededError> = None;
    let mut f_5: Option<shared::ServiceBusyError> = None;
    let mut f_6: Option<shared::ClientVersionNotSupportedError> = None;
    let mut f_7: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = shared::DescribeTaskListResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = shared::BadRequestError::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        3 => {
          let val = shared::EntityNotExistsError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = shared::LimitExceededError::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = shared::ClientVersionNotSupportedError::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceDescribeTaskListResult {
      result_value: f_0,
      bad_request_error: f_1,
      entity_not_exist_error: f_3,
      limit_exceeded_error: f_4,
      service_busy_error: f_5,
      client_version_not_supported_error: f_6,
      access_denied_error: f_7,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServiceDescribeTaskListResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.bad_request_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("badRequestError", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_not_exist_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("entityNotExistError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.limit_exceeded_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("limitExceededError", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_version_not_supported_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientVersionNotSupportedError", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceGetClusterInfoArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceGetClusterInfoArgs {
}

impl WorkflowServiceGetClusterInfoArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceGetClusterInfoArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      i_prot.skip(field_ident.field_type)?;
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceGetClusterInfoArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetClusterInfo_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceGetClusterInfoResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceGetClusterInfoResult {
  result_value: Option<shared::ClusterInfo>,
  internal_service_error: Option<shared::InternalServiceError>,
  service_busy_error: Option<shared::ServiceBusyError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServiceGetClusterInfoResult {
  fn ok_or(self) -> thrift::Result<shared::ClusterInfo> {
    if self.internal_service_error.is_some() {
      Err(thrift::Error::User(Box::new(self.internal_service_error.unwrap())))
    } else if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for WorkflowServiceGetClusterInfo"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceGetClusterInfoResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<shared::ClusterInfo> = None;
    let mut f_1: Option<shared::InternalServiceError> = None;
    let mut f_2: Option<shared::ServiceBusyError> = None;
    let mut f_3: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = shared::ClusterInfo::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = shared::InternalServiceError::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceGetClusterInfoResult {
      result_value: f_0,
      internal_service_error: f_1,
      service_busy_error: f_2,
      access_denied_error: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServiceGetClusterInfoResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.internal_service_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("internalServiceError", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceGetTaskListsByDomainArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceGetTaskListsByDomainArgs {
  request: shared::GetTaskListsByDomainRequest,
}

impl WorkflowServiceGetTaskListsByDomainArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceGetTaskListsByDomainArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::GetTaskListsByDomainRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::GetTaskListsByDomainRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WorkflowServiceGetTaskListsByDomainArgs.request", &f_1)?;
    let ret = WorkflowServiceGetTaskListsByDomainArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetTaskListsByDomain_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceGetTaskListsByDomainResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceGetTaskListsByDomainResult {
  result_value: Option<shared::GetTaskListsByDomainResponse>,
  bad_request_error: Option<shared::BadRequestError>,
  entity_not_exist_error: Option<shared::EntityNotExistsError>,
  limit_exceeded_error: Option<shared::LimitExceededError>,
  service_busy_error: Option<shared::ServiceBusyError>,
  client_version_not_supported_error: Option<shared::ClientVersionNotSupportedError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServiceGetTaskListsByDomainResult {
  fn ok_or(self) -> thrift::Result<shared::GetTaskListsByDomainResponse> {
    if self.bad_request_error.is_some() {
      Err(thrift::Error::User(Box::new(self.bad_request_error.unwrap())))
    } else if self.entity_not_exist_error.is_some() {
      Err(thrift::Error::User(Box::new(self.entity_not_exist_error.unwrap())))
    } else if self.limit_exceeded_error.is_some() {
      Err(thrift::Error::User(Box::new(self.limit_exceeded_error.unwrap())))
    } else if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.client_version_not_supported_error.is_some() {
      Err(thrift::Error::User(Box::new(self.client_version_not_supported_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for WorkflowServiceGetTaskListsByDomain"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceGetTaskListsByDomainResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<shared::GetTaskListsByDomainResponse> = None;
    let mut f_1: Option<shared::BadRequestError> = None;
    let mut f_2: Option<shared::EntityNotExistsError> = None;
    let mut f_3: Option<shared::LimitExceededError> = None;
    let mut f_4: Option<shared::ServiceBusyError> = None;
    let mut f_5: Option<shared::ClientVersionNotSupportedError> = None;
    let mut f_6: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = shared::GetTaskListsByDomainResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = shared::BadRequestError::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = shared::EntityNotExistsError::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = shared::LimitExceededError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = shared::ClientVersionNotSupportedError::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceGetTaskListsByDomainResult {
      result_value: f_0,
      bad_request_error: f_1,
      entity_not_exist_error: f_2,
      limit_exceeded_error: f_3,
      service_busy_error: f_4,
      client_version_not_supported_error: f_5,
      access_denied_error: f_6,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServiceGetTaskListsByDomainResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.bad_request_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("badRequestError", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_not_exist_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("entityNotExistError", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.limit_exceeded_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("limitExceededError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.client_version_not_supported_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("clientVersionNotSupportedError", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceListTaskListPartitionsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceListTaskListPartitionsArgs {
  request: shared::ListTaskListPartitionsRequest,
}

impl WorkflowServiceListTaskListPartitionsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceListTaskListPartitionsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::ListTaskListPartitionsRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::ListTaskListPartitionsRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WorkflowServiceListTaskListPartitionsArgs.request", &f_1)?;
    let ret = WorkflowServiceListTaskListPartitionsArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ListTaskListPartitions_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceListTaskListPartitionsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceListTaskListPartitionsResult {
  result_value: Option<shared::ListTaskListPartitionsResponse>,
  bad_request_error: Option<shared::BadRequestError>,
  entity_not_exist_error: Option<shared::EntityNotExistsError>,
  limit_exceeded_error: Option<shared::LimitExceededError>,
  service_busy_error: Option<shared::ServiceBusyError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServiceListTaskListPartitionsResult {
  fn ok_or(self) -> thrift::Result<shared::ListTaskListPartitionsResponse> {
    if self.bad_request_error.is_some() {
      Err(thrift::Error::User(Box::new(self.bad_request_error.unwrap())))
    } else if self.entity_not_exist_error.is_some() {
      Err(thrift::Error::User(Box::new(self.entity_not_exist_error.unwrap())))
    } else if self.limit_exceeded_error.is_some() {
      Err(thrift::Error::User(Box::new(self.limit_exceeded_error.unwrap())))
    } else if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for WorkflowServiceListTaskListPartitions"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceListTaskListPartitionsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<shared::ListTaskListPartitionsResponse> = None;
    let mut f_1: Option<shared::BadRequestError> = None;
    let mut f_3: Option<shared::EntityNotExistsError> = None;
    let mut f_4: Option<shared::LimitExceededError> = None;
    let mut f_5: Option<shared::ServiceBusyError> = None;
    let mut f_6: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = shared::ListTaskListPartitionsResponse::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = shared::BadRequestError::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        3 => {
          let val = shared::EntityNotExistsError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = shared::LimitExceededError::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceListTaskListPartitionsResult {
      result_value: f_0,
      bad_request_error: f_1,
      entity_not_exist_error: f_3,
      limit_exceeded_error: f_4,
      service_busy_error: f_5,
      access_denied_error: f_6,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServiceListTaskListPartitionsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.bad_request_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("badRequestError", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_not_exist_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("entityNotExistError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.limit_exceeded_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("limitExceededError", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceRefreshWorkflowTasksArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceRefreshWorkflowTasksArgs {
  request: shared::RefreshWorkflowTasksRequest,
}

impl WorkflowServiceRefreshWorkflowTasksArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceRefreshWorkflowTasksArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::RefreshWorkflowTasksRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::RefreshWorkflowTasksRequest::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WorkflowServiceRefreshWorkflowTasksArgs.request", &f_1)?;
    let ret = WorkflowServiceRefreshWorkflowTasksArgs {
      request: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RefreshWorkflowTasks_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 1))?;
    self.request.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowServiceRefreshWorkflowTasksResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct WorkflowServiceRefreshWorkflowTasksResult {
  bad_request_error: Option<shared::BadRequestError>,
  domain_not_active_error: Option<shared::DomainNotActiveError>,
  service_busy_error: Option<shared::ServiceBusyError>,
  entity_not_exist_error: Option<shared::EntityNotExistsError>,
  access_denied_error: Option<shared::AccessDeniedError>,
}

impl WorkflowServiceRefreshWorkflowTasksResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.bad_request_error.is_some() {
      Err(thrift::Error::User(Box::new(self.bad_request_error.unwrap())))
    } else if self.domain_not_active_error.is_some() {
      Err(thrift::Error::User(Box::new(self.domain_not_active_error.unwrap())))
    } else if self.service_busy_error.is_some() {
      Err(thrift::Error::User(Box::new(self.service_busy_error.unwrap())))
    } else if self.entity_not_exist_error.is_some() {
      Err(thrift::Error::User(Box::new(self.entity_not_exist_error.unwrap())))
    } else if self.access_denied_error.is_some() {
      Err(thrift::Error::User(Box::new(self.access_denied_error.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowServiceRefreshWorkflowTasksResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<shared::BadRequestError> = None;
    let mut f_2: Option<shared::DomainNotActiveError> = None;
    let mut f_3: Option<shared::ServiceBusyError> = None;
    let mut f_4: Option<shared::EntityNotExistsError> = None;
    let mut f_5: Option<shared::AccessDeniedError> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = shared::BadRequestError::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = shared::DomainNotActiveError::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = shared::ServiceBusyError::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = shared::EntityNotExistsError::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = shared::AccessDeniedError::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowServiceRefreshWorkflowTasksResult {
      bad_request_error: f_1,
      domain_not_active_error: f_2,
      service_busy_error: f_3,
      entity_not_exist_error: f_4,
      access_denied_error: f_5,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowServiceRefreshWorkflowTasksResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.bad_request_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("badRequestError", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.domain_not_active_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("domainNotActiveError", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.service_busy_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("serviceBusyError", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.entity_not_exist_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("entityNotExistError", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.access_denied_error {
      o_prot.write_field_begin(&TFieldIdentifier::new("accessDeniedError", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

