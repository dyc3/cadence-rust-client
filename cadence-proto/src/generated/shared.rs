// Autogenerated by Thrift Compiler (0.22.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(dead_code)]
#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![allow(clippy::too_many_arguments, clippy::type_complexity, clippy::vec_box, clippy::wrong_self_convention)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use thrift::OrderedFloat;
use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSerializable, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WorkflowIdReusePolicy(pub i32);

impl WorkflowIdReusePolicy {
  pub const ALLOW_DUPLICATE_FAILED_ONLY: WorkflowIdReusePolicy = WorkflowIdReusePolicy(0);
  pub const ALLOW_DUPLICATE: WorkflowIdReusePolicy = WorkflowIdReusePolicy(1);
  pub const REJECT_DUPLICATE: WorkflowIdReusePolicy = WorkflowIdReusePolicy(2);
  pub const TERMINATE_IF_RUNNING: WorkflowIdReusePolicy = WorkflowIdReusePolicy(3);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ALLOW_DUPLICATE_FAILED_ONLY,
    Self::ALLOW_DUPLICATE,
    Self::REJECT_DUPLICATE,
    Self::TERMINATE_IF_RUNNING,
  ];
}

impl TSerializable for WorkflowIdReusePolicy {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowIdReusePolicy> {
    let enum_value = i_prot.read_i32()?;
    Ok(WorkflowIdReusePolicy::from(enum_value))
  }
}

impl From<i32> for WorkflowIdReusePolicy {
  fn from(i: i32) -> Self {
    match i {
      0 => WorkflowIdReusePolicy::ALLOW_DUPLICATE_FAILED_ONLY,
      1 => WorkflowIdReusePolicy::ALLOW_DUPLICATE,
      2 => WorkflowIdReusePolicy::REJECT_DUPLICATE,
      3 => WorkflowIdReusePolicy::TERMINATE_IF_RUNNING,
      _ => WorkflowIdReusePolicy(i)
    }
  }
}

impl From<&i32> for WorkflowIdReusePolicy {
  fn from(i: &i32) -> Self {
    WorkflowIdReusePolicy::from(*i)
  }
}

impl From<WorkflowIdReusePolicy> for i32 {
  fn from(e: WorkflowIdReusePolicy) -> i32 {
    e.0
  }
}

impl From<&WorkflowIdReusePolicy> for i32 {
  fn from(e: &WorkflowIdReusePolicy) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DomainStatus(pub i32);

impl DomainStatus {
  pub const REGISTERED: DomainStatus = DomainStatus(0);
  pub const DEPRECATED: DomainStatus = DomainStatus(1);
  pub const DELETED: DomainStatus = DomainStatus(2);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REGISTERED,
    Self::DEPRECATED,
    Self::DELETED,
  ];
}

impl TSerializable for DomainStatus {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DomainStatus> {
    let enum_value = i_prot.read_i32()?;
    Ok(DomainStatus::from(enum_value))
  }
}

impl From<i32> for DomainStatus {
  fn from(i: i32) -> Self {
    match i {
      0 => DomainStatus::REGISTERED,
      1 => DomainStatus::DEPRECATED,
      2 => DomainStatus::DELETED,
      _ => DomainStatus(i)
    }
  }
}

impl From<&i32> for DomainStatus {
  fn from(i: &i32) -> Self {
    DomainStatus::from(*i)
  }
}

impl From<DomainStatus> for i32 {
  fn from(e: DomainStatus) -> i32 {
    e.0
  }
}

impl From<&DomainStatus> for i32 {
  fn from(e: &DomainStatus) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TimeoutType(pub i32);

impl TimeoutType {
  pub const START_TO_CLOSE: TimeoutType = TimeoutType(0);
  pub const SCHEDULE_TO_START: TimeoutType = TimeoutType(1);
  pub const SCHEDULE_TO_CLOSE: TimeoutType = TimeoutType(2);
  pub const HEARTBEAT: TimeoutType = TimeoutType(3);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::START_TO_CLOSE,
    Self::SCHEDULE_TO_START,
    Self::SCHEDULE_TO_CLOSE,
    Self::HEARTBEAT,
  ];
}

impl TSerializable for TimeoutType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TimeoutType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TimeoutType::from(enum_value))
  }
}

impl From<i32> for TimeoutType {
  fn from(i: i32) -> Self {
    match i {
      0 => TimeoutType::START_TO_CLOSE,
      1 => TimeoutType::SCHEDULE_TO_START,
      2 => TimeoutType::SCHEDULE_TO_CLOSE,
      3 => TimeoutType::HEARTBEAT,
      _ => TimeoutType(i)
    }
  }
}

impl From<&i32> for TimeoutType {
  fn from(i: &i32) -> Self {
    TimeoutType::from(*i)
  }
}

impl From<TimeoutType> for i32 {
  fn from(e: TimeoutType) -> i32 {
    e.0
  }
}

impl From<&TimeoutType> for i32 {
  fn from(e: &TimeoutType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ParentClosePolicy(pub i32);

impl ParentClosePolicy {
  pub const ABANDON: ParentClosePolicy = ParentClosePolicy(0);
  pub const REQUEST_CANCEL: ParentClosePolicy = ParentClosePolicy(1);
  pub const TERMINATE: ParentClosePolicy = ParentClosePolicy(2);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ABANDON,
    Self::REQUEST_CANCEL,
    Self::TERMINATE,
  ];
}

impl TSerializable for ParentClosePolicy {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ParentClosePolicy> {
    let enum_value = i_prot.read_i32()?;
    Ok(ParentClosePolicy::from(enum_value))
  }
}

impl From<i32> for ParentClosePolicy {
  fn from(i: i32) -> Self {
    match i {
      0 => ParentClosePolicy::ABANDON,
      1 => ParentClosePolicy::REQUEST_CANCEL,
      2 => ParentClosePolicy::TERMINATE,
      _ => ParentClosePolicy(i)
    }
  }
}

impl From<&i32> for ParentClosePolicy {
  fn from(i: &i32) -> Self {
    ParentClosePolicy::from(*i)
  }
}

impl From<ParentClosePolicy> for i32 {
  fn from(e: ParentClosePolicy) -> i32 {
    e.0
  }
}

impl From<&ParentClosePolicy> for i32 {
  fn from(e: &ParentClosePolicy) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DecisionType(pub i32);

impl DecisionType {
  pub const SCHEDULE_ACTIVITY_TASK: DecisionType = DecisionType(0);
  pub const REQUEST_CANCEL_ACTIVITY_TASK: DecisionType = DecisionType(1);
  pub const START_TIMER: DecisionType = DecisionType(2);
  pub const COMPLETE_WORKFLOW_EXECUTION: DecisionType = DecisionType(3);
  pub const FAIL_WORKFLOW_EXECUTION: DecisionType = DecisionType(4);
  pub const CANCEL_TIMER: DecisionType = DecisionType(5);
  pub const CANCEL_WORKFLOW_EXECUTION: DecisionType = DecisionType(6);
  pub const REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION: DecisionType = DecisionType(7);
  pub const RECORD_MARKER: DecisionType = DecisionType(8);
  pub const CONTINUE_AS_NEW_WORKFLOW_EXECUTION: DecisionType = DecisionType(9);
  pub const START_CHILD_WORKFLOW_EXECUTION: DecisionType = DecisionType(10);
  pub const SIGNAL_EXTERNAL_WORKFLOW_EXECUTION: DecisionType = DecisionType(11);
  pub const UPSERT_WORKFLOW_SEARCH_ATTRIBUTES: DecisionType = DecisionType(12);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SCHEDULE_ACTIVITY_TASK,
    Self::REQUEST_CANCEL_ACTIVITY_TASK,
    Self::START_TIMER,
    Self::COMPLETE_WORKFLOW_EXECUTION,
    Self::FAIL_WORKFLOW_EXECUTION,
    Self::CANCEL_TIMER,
    Self::CANCEL_WORKFLOW_EXECUTION,
    Self::REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION,
    Self::RECORD_MARKER,
    Self::CONTINUE_AS_NEW_WORKFLOW_EXECUTION,
    Self::START_CHILD_WORKFLOW_EXECUTION,
    Self::SIGNAL_EXTERNAL_WORKFLOW_EXECUTION,
    Self::UPSERT_WORKFLOW_SEARCH_ATTRIBUTES,
  ];
}

impl TSerializable for DecisionType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DecisionType> {
    let enum_value = i_prot.read_i32()?;
    Ok(DecisionType::from(enum_value))
  }
}

impl From<i32> for DecisionType {
  fn from(i: i32) -> Self {
    match i {
      0 => DecisionType::SCHEDULE_ACTIVITY_TASK,
      1 => DecisionType::REQUEST_CANCEL_ACTIVITY_TASK,
      2 => DecisionType::START_TIMER,
      3 => DecisionType::COMPLETE_WORKFLOW_EXECUTION,
      4 => DecisionType::FAIL_WORKFLOW_EXECUTION,
      5 => DecisionType::CANCEL_TIMER,
      6 => DecisionType::CANCEL_WORKFLOW_EXECUTION,
      7 => DecisionType::REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION,
      8 => DecisionType::RECORD_MARKER,
      9 => DecisionType::CONTINUE_AS_NEW_WORKFLOW_EXECUTION,
      10 => DecisionType::START_CHILD_WORKFLOW_EXECUTION,
      11 => DecisionType::SIGNAL_EXTERNAL_WORKFLOW_EXECUTION,
      12 => DecisionType::UPSERT_WORKFLOW_SEARCH_ATTRIBUTES,
      _ => DecisionType(i)
    }
  }
}

impl From<&i32> for DecisionType {
  fn from(i: &i32) -> Self {
    DecisionType::from(*i)
  }
}

impl From<DecisionType> for i32 {
  fn from(e: DecisionType) -> i32 {
    e.0
  }
}

impl From<&DecisionType> for i32 {
  fn from(e: &DecisionType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct EventType(pub i32);

impl EventType {
  pub const WORKFLOW_EXECUTION_STARTED: EventType = EventType(0);
  pub const WORKFLOW_EXECUTION_COMPLETED: EventType = EventType(1);
  pub const WORKFLOW_EXECUTION_FAILED: EventType = EventType(2);
  pub const WORKFLOW_EXECUTION_TIMED_OUT: EventType = EventType(3);
  pub const DECISION_TASK_SCHEDULED: EventType = EventType(4);
  pub const DECISION_TASK_STARTED: EventType = EventType(5);
  pub const DECISION_TASK_COMPLETED: EventType = EventType(6);
  pub const DECISION_TASK_TIMED_OUT: EventType = EventType(7);
  pub const DECISION_TASK_FAILED: EventType = EventType(8);
  pub const ACTIVITY_TASK_SCHEDULED: EventType = EventType(9);
  pub const ACTIVITY_TASK_STARTED: EventType = EventType(10);
  pub const ACTIVITY_TASK_COMPLETED: EventType = EventType(11);
  pub const ACTIVITY_TASK_FAILED: EventType = EventType(12);
  pub const ACTIVITY_TASK_TIMED_OUT: EventType = EventType(13);
  pub const ACTIVITY_TASK_CANCEL_REQUESTED: EventType = EventType(14);
  pub const REQUEST_CANCEL_ACTIVITY_TASK_FAILED: EventType = EventType(15);
  pub const ACTIVITY_TASK_CANCELED: EventType = EventType(16);
  pub const TIMER_STARTED: EventType = EventType(17);
  pub const TIMER_FIRED: EventType = EventType(18);
  pub const CANCEL_TIMER_FAILED: EventType = EventType(19);
  pub const TIMER_CANCELED: EventType = EventType(20);
  pub const WORKFLOW_EXECUTION_CANCEL_REQUESTED: EventType = EventType(21);
  pub const WORKFLOW_EXECUTION_CANCELED: EventType = EventType(22);
  pub const REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED: EventType = EventType(23);
  pub const REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED: EventType = EventType(24);
  pub const EXTERNAL_WORKFLOW_EXECUTION_CANCEL_REQUESTED: EventType = EventType(25);
  pub const MARKER_RECORDED: EventType = EventType(26);
  pub const WORKFLOW_EXECUTION_SIGNALED: EventType = EventType(27);
  pub const WORKFLOW_EXECUTION_TERMINATED: EventType = EventType(28);
  pub const WORKFLOW_EXECUTION_CONTINUED_AS_NEW: EventType = EventType(29);
  pub const START_CHILD_WORKFLOW_EXECUTION_INITIATED: EventType = EventType(30);
  pub const START_CHILD_WORKFLOW_EXECUTION_FAILED: EventType = EventType(31);
  pub const CHILD_WORKFLOW_EXECUTION_STARTED: EventType = EventType(32);
  pub const CHILD_WORKFLOW_EXECUTION_COMPLETED: EventType = EventType(33);
  pub const CHILD_WORKFLOW_EXECUTION_FAILED: EventType = EventType(34);
  pub const CHILD_WORKFLOW_EXECUTION_CANCELED: EventType = EventType(35);
  pub const CHILD_WORKFLOW_EXECUTION_TIMED_OUT: EventType = EventType(36);
  pub const CHILD_WORKFLOW_EXECUTION_TERMINATED: EventType = EventType(37);
  pub const SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED: EventType = EventType(38);
  pub const SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED: EventType = EventType(39);
  pub const EXTERNAL_WORKFLOW_EXECUTION_SIGNALED: EventType = EventType(40);
  pub const UPSERT_WORKFLOW_SEARCH_ATTRIBUTES: EventType = EventType(41);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::WORKFLOW_EXECUTION_STARTED,
    Self::WORKFLOW_EXECUTION_COMPLETED,
    Self::WORKFLOW_EXECUTION_FAILED,
    Self::WORKFLOW_EXECUTION_TIMED_OUT,
    Self::DECISION_TASK_SCHEDULED,
    Self::DECISION_TASK_STARTED,
    Self::DECISION_TASK_COMPLETED,
    Self::DECISION_TASK_TIMED_OUT,
    Self::DECISION_TASK_FAILED,
    Self::ACTIVITY_TASK_SCHEDULED,
    Self::ACTIVITY_TASK_STARTED,
    Self::ACTIVITY_TASK_COMPLETED,
    Self::ACTIVITY_TASK_FAILED,
    Self::ACTIVITY_TASK_TIMED_OUT,
    Self::ACTIVITY_TASK_CANCEL_REQUESTED,
    Self::REQUEST_CANCEL_ACTIVITY_TASK_FAILED,
    Self::ACTIVITY_TASK_CANCELED,
    Self::TIMER_STARTED,
    Self::TIMER_FIRED,
    Self::CANCEL_TIMER_FAILED,
    Self::TIMER_CANCELED,
    Self::WORKFLOW_EXECUTION_CANCEL_REQUESTED,
    Self::WORKFLOW_EXECUTION_CANCELED,
    Self::REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED,
    Self::REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED,
    Self::EXTERNAL_WORKFLOW_EXECUTION_CANCEL_REQUESTED,
    Self::MARKER_RECORDED,
    Self::WORKFLOW_EXECUTION_SIGNALED,
    Self::WORKFLOW_EXECUTION_TERMINATED,
    Self::WORKFLOW_EXECUTION_CONTINUED_AS_NEW,
    Self::START_CHILD_WORKFLOW_EXECUTION_INITIATED,
    Self::START_CHILD_WORKFLOW_EXECUTION_FAILED,
    Self::CHILD_WORKFLOW_EXECUTION_STARTED,
    Self::CHILD_WORKFLOW_EXECUTION_COMPLETED,
    Self::CHILD_WORKFLOW_EXECUTION_FAILED,
    Self::CHILD_WORKFLOW_EXECUTION_CANCELED,
    Self::CHILD_WORKFLOW_EXECUTION_TIMED_OUT,
    Self::CHILD_WORKFLOW_EXECUTION_TERMINATED,
    Self::SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED,
    Self::SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED,
    Self::EXTERNAL_WORKFLOW_EXECUTION_SIGNALED,
    Self::UPSERT_WORKFLOW_SEARCH_ATTRIBUTES,
  ];
}

impl TSerializable for EventType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<EventType> {
    let enum_value = i_prot.read_i32()?;
    Ok(EventType::from(enum_value))
  }
}

impl From<i32> for EventType {
  fn from(i: i32) -> Self {
    match i {
      0 => EventType::WORKFLOW_EXECUTION_STARTED,
      1 => EventType::WORKFLOW_EXECUTION_COMPLETED,
      2 => EventType::WORKFLOW_EXECUTION_FAILED,
      3 => EventType::WORKFLOW_EXECUTION_TIMED_OUT,
      4 => EventType::DECISION_TASK_SCHEDULED,
      5 => EventType::DECISION_TASK_STARTED,
      6 => EventType::DECISION_TASK_COMPLETED,
      7 => EventType::DECISION_TASK_TIMED_OUT,
      8 => EventType::DECISION_TASK_FAILED,
      9 => EventType::ACTIVITY_TASK_SCHEDULED,
      10 => EventType::ACTIVITY_TASK_STARTED,
      11 => EventType::ACTIVITY_TASK_COMPLETED,
      12 => EventType::ACTIVITY_TASK_FAILED,
      13 => EventType::ACTIVITY_TASK_TIMED_OUT,
      14 => EventType::ACTIVITY_TASK_CANCEL_REQUESTED,
      15 => EventType::REQUEST_CANCEL_ACTIVITY_TASK_FAILED,
      16 => EventType::ACTIVITY_TASK_CANCELED,
      17 => EventType::TIMER_STARTED,
      18 => EventType::TIMER_FIRED,
      19 => EventType::CANCEL_TIMER_FAILED,
      20 => EventType::TIMER_CANCELED,
      21 => EventType::WORKFLOW_EXECUTION_CANCEL_REQUESTED,
      22 => EventType::WORKFLOW_EXECUTION_CANCELED,
      23 => EventType::REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED,
      24 => EventType::REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED,
      25 => EventType::EXTERNAL_WORKFLOW_EXECUTION_CANCEL_REQUESTED,
      26 => EventType::MARKER_RECORDED,
      27 => EventType::WORKFLOW_EXECUTION_SIGNALED,
      28 => EventType::WORKFLOW_EXECUTION_TERMINATED,
      29 => EventType::WORKFLOW_EXECUTION_CONTINUED_AS_NEW,
      30 => EventType::START_CHILD_WORKFLOW_EXECUTION_INITIATED,
      31 => EventType::START_CHILD_WORKFLOW_EXECUTION_FAILED,
      32 => EventType::CHILD_WORKFLOW_EXECUTION_STARTED,
      33 => EventType::CHILD_WORKFLOW_EXECUTION_COMPLETED,
      34 => EventType::CHILD_WORKFLOW_EXECUTION_FAILED,
      35 => EventType::CHILD_WORKFLOW_EXECUTION_CANCELED,
      36 => EventType::CHILD_WORKFLOW_EXECUTION_TIMED_OUT,
      37 => EventType::CHILD_WORKFLOW_EXECUTION_TERMINATED,
      38 => EventType::SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED,
      39 => EventType::SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED,
      40 => EventType::EXTERNAL_WORKFLOW_EXECUTION_SIGNALED,
      41 => EventType::UPSERT_WORKFLOW_SEARCH_ATTRIBUTES,
      _ => EventType(i)
    }
  }
}

impl From<&i32> for EventType {
  fn from(i: &i32) -> Self {
    EventType::from(*i)
  }
}

impl From<EventType> for i32 {
  fn from(e: EventType) -> i32 {
    e.0
  }
}

impl From<&EventType> for i32 {
  fn from(e: &EventType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DecisionTaskFailedCause(pub i32);

impl DecisionTaskFailedCause {
  pub const UNHANDLED_DECISION: DecisionTaskFailedCause = DecisionTaskFailedCause(0);
  pub const BAD_SCHEDULE_ACTIVITY_ATTRIBUTES: DecisionTaskFailedCause = DecisionTaskFailedCause(1);
  pub const BAD_REQUEST_CANCEL_ACTIVITY_ATTRIBUTES: DecisionTaskFailedCause = DecisionTaskFailedCause(2);
  pub const BAD_START_TIMER_ATTRIBUTES: DecisionTaskFailedCause = DecisionTaskFailedCause(3);
  pub const BAD_CANCEL_TIMER_ATTRIBUTES: DecisionTaskFailedCause = DecisionTaskFailedCause(4);
  pub const BAD_RECORD_MARKER_ATTRIBUTES: DecisionTaskFailedCause = DecisionTaskFailedCause(5);
  pub const BAD_COMPLETE_WORKFLOW_EXECUTION_ATTRIBUTES: DecisionTaskFailedCause = DecisionTaskFailedCause(6);
  pub const BAD_FAIL_WORKFLOW_EXECUTION_ATTRIBUTES: DecisionTaskFailedCause = DecisionTaskFailedCause(7);
  pub const BAD_CANCEL_WORKFLOW_EXECUTION_ATTRIBUTES: DecisionTaskFailedCause = DecisionTaskFailedCause(8);
  pub const BAD_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_ATTRIBUTES: DecisionTaskFailedCause = DecisionTaskFailedCause(9);
  pub const BAD_CONTINUE_AS_NEW_ATTRIBUTES: DecisionTaskFailedCause = DecisionTaskFailedCause(10);
  pub const START_TIMER_DUPLICATE_ID: DecisionTaskFailedCause = DecisionTaskFailedCause(11);
  pub const RESET_STICKY_TASKLIST: DecisionTaskFailedCause = DecisionTaskFailedCause(12);
  pub const WORKFLOW_WORKER_UNHANDLED_FAILURE: DecisionTaskFailedCause = DecisionTaskFailedCause(13);
  pub const BAD_SIGNAL_WORKFLOW_EXECUTION_ATTRIBUTES: DecisionTaskFailedCause = DecisionTaskFailedCause(14);
  pub const BAD_START_CHILD_EXECUTION_ATTRIBUTES: DecisionTaskFailedCause = DecisionTaskFailedCause(15);
  pub const FORCE_CLOSE_DECISION: DecisionTaskFailedCause = DecisionTaskFailedCause(16);
  pub const FAILOVER_CLOSE_DECISION: DecisionTaskFailedCause = DecisionTaskFailedCause(17);
  pub const BAD_SIGNAL_INPUT_SIZE: DecisionTaskFailedCause = DecisionTaskFailedCause(18);
  pub const RESET_WORKFLOW: DecisionTaskFailedCause = DecisionTaskFailedCause(19);
  pub const BAD_BINARY: DecisionTaskFailedCause = DecisionTaskFailedCause(20);
  pub const SCHEDULE_ACTIVITY_DUPLICATE_ID: DecisionTaskFailedCause = DecisionTaskFailedCause(21);
  pub const BAD_SEARCH_ATTRIBUTES: DecisionTaskFailedCause = DecisionTaskFailedCause(22);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::UNHANDLED_DECISION,
    Self::BAD_SCHEDULE_ACTIVITY_ATTRIBUTES,
    Self::BAD_REQUEST_CANCEL_ACTIVITY_ATTRIBUTES,
    Self::BAD_START_TIMER_ATTRIBUTES,
    Self::BAD_CANCEL_TIMER_ATTRIBUTES,
    Self::BAD_RECORD_MARKER_ATTRIBUTES,
    Self::BAD_COMPLETE_WORKFLOW_EXECUTION_ATTRIBUTES,
    Self::BAD_FAIL_WORKFLOW_EXECUTION_ATTRIBUTES,
    Self::BAD_CANCEL_WORKFLOW_EXECUTION_ATTRIBUTES,
    Self::BAD_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_ATTRIBUTES,
    Self::BAD_CONTINUE_AS_NEW_ATTRIBUTES,
    Self::START_TIMER_DUPLICATE_ID,
    Self::RESET_STICKY_TASKLIST,
    Self::WORKFLOW_WORKER_UNHANDLED_FAILURE,
    Self::BAD_SIGNAL_WORKFLOW_EXECUTION_ATTRIBUTES,
    Self::BAD_START_CHILD_EXECUTION_ATTRIBUTES,
    Self::FORCE_CLOSE_DECISION,
    Self::FAILOVER_CLOSE_DECISION,
    Self::BAD_SIGNAL_INPUT_SIZE,
    Self::RESET_WORKFLOW,
    Self::BAD_BINARY,
    Self::SCHEDULE_ACTIVITY_DUPLICATE_ID,
    Self::BAD_SEARCH_ATTRIBUTES,
  ];
}

impl TSerializable for DecisionTaskFailedCause {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DecisionTaskFailedCause> {
    let enum_value = i_prot.read_i32()?;
    Ok(DecisionTaskFailedCause::from(enum_value))
  }
}

impl From<i32> for DecisionTaskFailedCause {
  fn from(i: i32) -> Self {
    match i {
      0 => DecisionTaskFailedCause::UNHANDLED_DECISION,
      1 => DecisionTaskFailedCause::BAD_SCHEDULE_ACTIVITY_ATTRIBUTES,
      2 => DecisionTaskFailedCause::BAD_REQUEST_CANCEL_ACTIVITY_ATTRIBUTES,
      3 => DecisionTaskFailedCause::BAD_START_TIMER_ATTRIBUTES,
      4 => DecisionTaskFailedCause::BAD_CANCEL_TIMER_ATTRIBUTES,
      5 => DecisionTaskFailedCause::BAD_RECORD_MARKER_ATTRIBUTES,
      6 => DecisionTaskFailedCause::BAD_COMPLETE_WORKFLOW_EXECUTION_ATTRIBUTES,
      7 => DecisionTaskFailedCause::BAD_FAIL_WORKFLOW_EXECUTION_ATTRIBUTES,
      8 => DecisionTaskFailedCause::BAD_CANCEL_WORKFLOW_EXECUTION_ATTRIBUTES,
      9 => DecisionTaskFailedCause::BAD_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_ATTRIBUTES,
      10 => DecisionTaskFailedCause::BAD_CONTINUE_AS_NEW_ATTRIBUTES,
      11 => DecisionTaskFailedCause::START_TIMER_DUPLICATE_ID,
      12 => DecisionTaskFailedCause::RESET_STICKY_TASKLIST,
      13 => DecisionTaskFailedCause::WORKFLOW_WORKER_UNHANDLED_FAILURE,
      14 => DecisionTaskFailedCause::BAD_SIGNAL_WORKFLOW_EXECUTION_ATTRIBUTES,
      15 => DecisionTaskFailedCause::BAD_START_CHILD_EXECUTION_ATTRIBUTES,
      16 => DecisionTaskFailedCause::FORCE_CLOSE_DECISION,
      17 => DecisionTaskFailedCause::FAILOVER_CLOSE_DECISION,
      18 => DecisionTaskFailedCause::BAD_SIGNAL_INPUT_SIZE,
      19 => DecisionTaskFailedCause::RESET_WORKFLOW,
      20 => DecisionTaskFailedCause::BAD_BINARY,
      21 => DecisionTaskFailedCause::SCHEDULE_ACTIVITY_DUPLICATE_ID,
      22 => DecisionTaskFailedCause::BAD_SEARCH_ATTRIBUTES,
      _ => DecisionTaskFailedCause(i)
    }
  }
}

impl From<&i32> for DecisionTaskFailedCause {
  fn from(i: &i32) -> Self {
    DecisionTaskFailedCause::from(*i)
  }
}

impl From<DecisionTaskFailedCause> for i32 {
  fn from(e: DecisionTaskFailedCause) -> i32 {
    e.0
  }
}

impl From<&DecisionTaskFailedCause> for i32 {
  fn from(e: &DecisionTaskFailedCause) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DecisionTaskTimedOutCause(pub i32);

impl DecisionTaskTimedOutCause {
  pub const TIMEOUT: DecisionTaskTimedOutCause = DecisionTaskTimedOutCause(0);
  pub const RESET: DecisionTaskTimedOutCause = DecisionTaskTimedOutCause(1);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::TIMEOUT,
    Self::RESET,
  ];
}

impl TSerializable for DecisionTaskTimedOutCause {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DecisionTaskTimedOutCause> {
    let enum_value = i_prot.read_i32()?;
    Ok(DecisionTaskTimedOutCause::from(enum_value))
  }
}

impl From<i32> for DecisionTaskTimedOutCause {
  fn from(i: i32) -> Self {
    match i {
      0 => DecisionTaskTimedOutCause::TIMEOUT,
      1 => DecisionTaskTimedOutCause::RESET,
      _ => DecisionTaskTimedOutCause(i)
    }
  }
}

impl From<&i32> for DecisionTaskTimedOutCause {
  fn from(i: &i32) -> Self {
    DecisionTaskTimedOutCause::from(*i)
  }
}

impl From<DecisionTaskTimedOutCause> for i32 {
  fn from(e: DecisionTaskTimedOutCause) -> i32 {
    e.0
  }
}

impl From<&DecisionTaskTimedOutCause> for i32 {
  fn from(e: &DecisionTaskTimedOutCause) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CancelExternalWorkflowExecutionFailedCause(pub i32);

impl CancelExternalWorkflowExecutionFailedCause {
  pub const UNKNOWN_EXTERNAL_WORKFLOW_EXECUTION: CancelExternalWorkflowExecutionFailedCause = CancelExternalWorkflowExecutionFailedCause(0);
  pub const WORKFLOW_ALREADY_COMPLETED: CancelExternalWorkflowExecutionFailedCause = CancelExternalWorkflowExecutionFailedCause(1);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::UNKNOWN_EXTERNAL_WORKFLOW_EXECUTION,
    Self::WORKFLOW_ALREADY_COMPLETED,
  ];
}

impl TSerializable for CancelExternalWorkflowExecutionFailedCause {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CancelExternalWorkflowExecutionFailedCause> {
    let enum_value = i_prot.read_i32()?;
    Ok(CancelExternalWorkflowExecutionFailedCause::from(enum_value))
  }
}

impl From<i32> for CancelExternalWorkflowExecutionFailedCause {
  fn from(i: i32) -> Self {
    match i {
      0 => CancelExternalWorkflowExecutionFailedCause::UNKNOWN_EXTERNAL_WORKFLOW_EXECUTION,
      1 => CancelExternalWorkflowExecutionFailedCause::WORKFLOW_ALREADY_COMPLETED,
      _ => CancelExternalWorkflowExecutionFailedCause(i)
    }
  }
}

impl From<&i32> for CancelExternalWorkflowExecutionFailedCause {
  fn from(i: &i32) -> Self {
    CancelExternalWorkflowExecutionFailedCause::from(*i)
  }
}

impl From<CancelExternalWorkflowExecutionFailedCause> for i32 {
  fn from(e: CancelExternalWorkflowExecutionFailedCause) -> i32 {
    e.0
  }
}

impl From<&CancelExternalWorkflowExecutionFailedCause> for i32 {
  fn from(e: &CancelExternalWorkflowExecutionFailedCause) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SignalExternalWorkflowExecutionFailedCause(pub i32);

impl SignalExternalWorkflowExecutionFailedCause {
  pub const UNKNOWN_EXTERNAL_WORKFLOW_EXECUTION: SignalExternalWorkflowExecutionFailedCause = SignalExternalWorkflowExecutionFailedCause(0);
  pub const WORKFLOW_ALREADY_COMPLETED: SignalExternalWorkflowExecutionFailedCause = SignalExternalWorkflowExecutionFailedCause(1);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::UNKNOWN_EXTERNAL_WORKFLOW_EXECUTION,
    Self::WORKFLOW_ALREADY_COMPLETED,
  ];
}

impl TSerializable for SignalExternalWorkflowExecutionFailedCause {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SignalExternalWorkflowExecutionFailedCause> {
    let enum_value = i_prot.read_i32()?;
    Ok(SignalExternalWorkflowExecutionFailedCause::from(enum_value))
  }
}

impl From<i32> for SignalExternalWorkflowExecutionFailedCause {
  fn from(i: i32) -> Self {
    match i {
      0 => SignalExternalWorkflowExecutionFailedCause::UNKNOWN_EXTERNAL_WORKFLOW_EXECUTION,
      1 => SignalExternalWorkflowExecutionFailedCause::WORKFLOW_ALREADY_COMPLETED,
      _ => SignalExternalWorkflowExecutionFailedCause(i)
    }
  }
}

impl From<&i32> for SignalExternalWorkflowExecutionFailedCause {
  fn from(i: &i32) -> Self {
    SignalExternalWorkflowExecutionFailedCause::from(*i)
  }
}

impl From<SignalExternalWorkflowExecutionFailedCause> for i32 {
  fn from(e: SignalExternalWorkflowExecutionFailedCause) -> i32 {
    e.0
  }
}

impl From<&SignalExternalWorkflowExecutionFailedCause> for i32 {
  fn from(e: &SignalExternalWorkflowExecutionFailedCause) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ChildWorkflowExecutionFailedCause(pub i32);

impl ChildWorkflowExecutionFailedCause {
  pub const WORKFLOW_ALREADY_RUNNING: ChildWorkflowExecutionFailedCause = ChildWorkflowExecutionFailedCause(0);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::WORKFLOW_ALREADY_RUNNING,
  ];
}

impl TSerializable for ChildWorkflowExecutionFailedCause {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChildWorkflowExecutionFailedCause> {
    let enum_value = i_prot.read_i32()?;
    Ok(ChildWorkflowExecutionFailedCause::from(enum_value))
  }
}

impl From<i32> for ChildWorkflowExecutionFailedCause {
  fn from(i: i32) -> Self {
    match i {
      0 => ChildWorkflowExecutionFailedCause::WORKFLOW_ALREADY_RUNNING,
      _ => ChildWorkflowExecutionFailedCause(i)
    }
  }
}

impl From<&i32> for ChildWorkflowExecutionFailedCause {
  fn from(i: &i32) -> Self {
    ChildWorkflowExecutionFailedCause::from(*i)
  }
}

impl From<ChildWorkflowExecutionFailedCause> for i32 {
  fn from(e: ChildWorkflowExecutionFailedCause) -> i32 {
    e.0
  }
}

impl From<&ChildWorkflowExecutionFailedCause> for i32 {
  fn from(e: &ChildWorkflowExecutionFailedCause) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WorkflowExecutionCloseStatus(pub i32);

impl WorkflowExecutionCloseStatus {
  pub const COMPLETED: WorkflowExecutionCloseStatus = WorkflowExecutionCloseStatus(0);
  pub const FAILED: WorkflowExecutionCloseStatus = WorkflowExecutionCloseStatus(1);
  pub const CANCELED: WorkflowExecutionCloseStatus = WorkflowExecutionCloseStatus(2);
  pub const TERMINATED: WorkflowExecutionCloseStatus = WorkflowExecutionCloseStatus(3);
  pub const CONTINUED_AS_NEW: WorkflowExecutionCloseStatus = WorkflowExecutionCloseStatus(4);
  pub const TIMED_OUT: WorkflowExecutionCloseStatus = WorkflowExecutionCloseStatus(5);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::COMPLETED,
    Self::FAILED,
    Self::CANCELED,
    Self::TERMINATED,
    Self::CONTINUED_AS_NEW,
    Self::TIMED_OUT,
  ];
}

impl TSerializable for WorkflowExecutionCloseStatus {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowExecutionCloseStatus> {
    let enum_value = i_prot.read_i32()?;
    Ok(WorkflowExecutionCloseStatus::from(enum_value))
  }
}

impl From<i32> for WorkflowExecutionCloseStatus {
  fn from(i: i32) -> Self {
    match i {
      0 => WorkflowExecutionCloseStatus::COMPLETED,
      1 => WorkflowExecutionCloseStatus::FAILED,
      2 => WorkflowExecutionCloseStatus::CANCELED,
      3 => WorkflowExecutionCloseStatus::TERMINATED,
      4 => WorkflowExecutionCloseStatus::CONTINUED_AS_NEW,
      5 => WorkflowExecutionCloseStatus::TIMED_OUT,
      _ => WorkflowExecutionCloseStatus(i)
    }
  }
}

impl From<&i32> for WorkflowExecutionCloseStatus {
  fn from(i: &i32) -> Self {
    WorkflowExecutionCloseStatus::from(*i)
  }
}

impl From<WorkflowExecutionCloseStatus> for i32 {
  fn from(e: WorkflowExecutionCloseStatus) -> i32 {
    e.0
  }
}

impl From<&WorkflowExecutionCloseStatus> for i32 {
  fn from(e: &WorkflowExecutionCloseStatus) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WorkflowExecutionStatus(pub i32);

impl WorkflowExecutionStatus {
  pub const PENDING: WorkflowExecutionStatus = WorkflowExecutionStatus(0);
  pub const STARTED: WorkflowExecutionStatus = WorkflowExecutionStatus(1);
  pub const COMPLETED: WorkflowExecutionStatus = WorkflowExecutionStatus(2);
  pub const FAILED: WorkflowExecutionStatus = WorkflowExecutionStatus(3);
  pub const CANCELED: WorkflowExecutionStatus = WorkflowExecutionStatus(4);
  pub const TERMINATED: WorkflowExecutionStatus = WorkflowExecutionStatus(5);
  pub const CONTINUED_AS_NEW: WorkflowExecutionStatus = WorkflowExecutionStatus(6);
  pub const TIMED_OUT: WorkflowExecutionStatus = WorkflowExecutionStatus(7);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::PENDING,
    Self::STARTED,
    Self::COMPLETED,
    Self::FAILED,
    Self::CANCELED,
    Self::TERMINATED,
    Self::CONTINUED_AS_NEW,
    Self::TIMED_OUT,
  ];
}

impl TSerializable for WorkflowExecutionStatus {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowExecutionStatus> {
    let enum_value = i_prot.read_i32()?;
    Ok(WorkflowExecutionStatus::from(enum_value))
  }
}

impl From<i32> for WorkflowExecutionStatus {
  fn from(i: i32) -> Self {
    match i {
      0 => WorkflowExecutionStatus::PENDING,
      1 => WorkflowExecutionStatus::STARTED,
      2 => WorkflowExecutionStatus::COMPLETED,
      3 => WorkflowExecutionStatus::FAILED,
      4 => WorkflowExecutionStatus::CANCELED,
      5 => WorkflowExecutionStatus::TERMINATED,
      6 => WorkflowExecutionStatus::CONTINUED_AS_NEW,
      7 => WorkflowExecutionStatus::TIMED_OUT,
      _ => WorkflowExecutionStatus(i)
    }
  }
}

impl From<&i32> for WorkflowExecutionStatus {
  fn from(i: &i32) -> Self {
    WorkflowExecutionStatus::from(*i)
  }
}

impl From<WorkflowExecutionStatus> for i32 {
  fn from(e: WorkflowExecutionStatus) -> i32 {
    e.0
  }
}

impl From<&WorkflowExecutionStatus> for i32 {
  fn from(e: &WorkflowExecutionStatus) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct QueryTaskCompletedType(pub i32);

impl QueryTaskCompletedType {
  pub const COMPLETED: QueryTaskCompletedType = QueryTaskCompletedType(0);
  pub const FAILED: QueryTaskCompletedType = QueryTaskCompletedType(1);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::COMPLETED,
    Self::FAILED,
  ];
}

impl TSerializable for QueryTaskCompletedType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<QueryTaskCompletedType> {
    let enum_value = i_prot.read_i32()?;
    Ok(QueryTaskCompletedType::from(enum_value))
  }
}

impl From<i32> for QueryTaskCompletedType {
  fn from(i: i32) -> Self {
    match i {
      0 => QueryTaskCompletedType::COMPLETED,
      1 => QueryTaskCompletedType::FAILED,
      _ => QueryTaskCompletedType(i)
    }
  }
}

impl From<&i32> for QueryTaskCompletedType {
  fn from(i: &i32) -> Self {
    QueryTaskCompletedType::from(*i)
  }
}

impl From<QueryTaskCompletedType> for i32 {
  fn from(e: QueryTaskCompletedType) -> i32 {
    e.0
  }
}

impl From<&QueryTaskCompletedType> for i32 {
  fn from(e: &QueryTaskCompletedType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct QueryResultType(pub i32);

impl QueryResultType {
  pub const ANSWERED: QueryResultType = QueryResultType(0);
  pub const FAILED: QueryResultType = QueryResultType(1);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ANSWERED,
    Self::FAILED,
  ];
}

impl TSerializable for QueryResultType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<QueryResultType> {
    let enum_value = i_prot.read_i32()?;
    Ok(QueryResultType::from(enum_value))
  }
}

impl From<i32> for QueryResultType {
  fn from(i: i32) -> Self {
    match i {
      0 => QueryResultType::ANSWERED,
      1 => QueryResultType::FAILED,
      _ => QueryResultType(i)
    }
  }
}

impl From<&i32> for QueryResultType {
  fn from(i: &i32) -> Self {
    QueryResultType::from(*i)
  }
}

impl From<QueryResultType> for i32 {
  fn from(e: QueryResultType) -> i32 {
    e.0
  }
}

impl From<&QueryResultType> for i32 {
  fn from(e: &QueryResultType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PendingActivityState(pub i32);

impl PendingActivityState {
  pub const SCHEDULED: PendingActivityState = PendingActivityState(0);
  pub const STARTED: PendingActivityState = PendingActivityState(1);
  pub const CANCEL_REQUESTED: PendingActivityState = PendingActivityState(2);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SCHEDULED,
    Self::STARTED,
    Self::CANCEL_REQUESTED,
  ];
}

impl TSerializable for PendingActivityState {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PendingActivityState> {
    let enum_value = i_prot.read_i32()?;
    Ok(PendingActivityState::from(enum_value))
  }
}

impl From<i32> for PendingActivityState {
  fn from(i: i32) -> Self {
    match i {
      0 => PendingActivityState::SCHEDULED,
      1 => PendingActivityState::STARTED,
      2 => PendingActivityState::CANCEL_REQUESTED,
      _ => PendingActivityState(i)
    }
  }
}

impl From<&i32> for PendingActivityState {
  fn from(i: &i32) -> Self {
    PendingActivityState::from(*i)
  }
}

impl From<PendingActivityState> for i32 {
  fn from(e: PendingActivityState) -> i32 {
    e.0
  }
}

impl From<&PendingActivityState> for i32 {
  fn from(e: &PendingActivityState) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PendingDecisionState(pub i32);

impl PendingDecisionState {
  pub const SCHEDULED: PendingDecisionState = PendingDecisionState(0);
  pub const STARTED: PendingDecisionState = PendingDecisionState(1);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SCHEDULED,
    Self::STARTED,
  ];
}

impl TSerializable for PendingDecisionState {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PendingDecisionState> {
    let enum_value = i_prot.read_i32()?;
    Ok(PendingDecisionState::from(enum_value))
  }
}

impl From<i32> for PendingDecisionState {
  fn from(i: i32) -> Self {
    match i {
      0 => PendingDecisionState::SCHEDULED,
      1 => PendingDecisionState::STARTED,
      _ => PendingDecisionState(i)
    }
  }
}

impl From<&i32> for PendingDecisionState {
  fn from(i: &i32) -> Self {
    PendingDecisionState::from(*i)
  }
}

impl From<PendingDecisionState> for i32 {
  fn from(e: PendingDecisionState) -> i32 {
    e.0
  }
}

impl From<&PendingDecisionState> for i32 {
  fn from(e: &PendingDecisionState) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct HistoryEventFilterType(pub i32);

impl HistoryEventFilterType {
  pub const ALL_EVENT: HistoryEventFilterType = HistoryEventFilterType(0);
  pub const CLOSE_EVENT: HistoryEventFilterType = HistoryEventFilterType(1);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ALL_EVENT,
    Self::CLOSE_EVENT,
  ];
}

impl TSerializable for HistoryEventFilterType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HistoryEventFilterType> {
    let enum_value = i_prot.read_i32()?;
    Ok(HistoryEventFilterType::from(enum_value))
  }
}

impl From<i32> for HistoryEventFilterType {
  fn from(i: i32) -> Self {
    match i {
      0 => HistoryEventFilterType::ALL_EVENT,
      1 => HistoryEventFilterType::CLOSE_EVENT,
      _ => HistoryEventFilterType(i)
    }
  }
}

impl From<&i32> for HistoryEventFilterType {
  fn from(i: &i32) -> Self {
    HistoryEventFilterType::from(*i)
  }
}

impl From<HistoryEventFilterType> for i32 {
  fn from(e: HistoryEventFilterType) -> i32 {
    e.0
  }
}

impl From<&HistoryEventFilterType> for i32 {
  fn from(e: &HistoryEventFilterType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TaskListKind(pub i32);

impl TaskListKind {
  pub const NORMAL: TaskListKind = TaskListKind(0);
  pub const STICKY: TaskListKind = TaskListKind(1);
  pub const EPHEMERAL: TaskListKind = TaskListKind(2);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NORMAL,
    Self::STICKY,
    Self::EPHEMERAL,
  ];
}

impl TSerializable for TaskListKind {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TaskListKind> {
    let enum_value = i_prot.read_i32()?;
    Ok(TaskListKind::from(enum_value))
  }
}

impl From<i32> for TaskListKind {
  fn from(i: i32) -> Self {
    match i {
      0 => TaskListKind::NORMAL,
      1 => TaskListKind::STICKY,
      2 => TaskListKind::EPHEMERAL,
      _ => TaskListKind(i)
    }
  }
}

impl From<&i32> for TaskListKind {
  fn from(i: &i32) -> Self {
    TaskListKind::from(*i)
  }
}

impl From<TaskListKind> for i32 {
  fn from(e: TaskListKind) -> i32 {
    e.0
  }
}

impl From<&TaskListKind> for i32 {
  fn from(e: &TaskListKind) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ArchivalStatus(pub i32);

impl ArchivalStatus {
  pub const DISABLED: ArchivalStatus = ArchivalStatus(0);
  pub const ENABLED: ArchivalStatus = ArchivalStatus(1);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::DISABLED,
    Self::ENABLED,
  ];
}

impl TSerializable for ArchivalStatus {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ArchivalStatus> {
    let enum_value = i_prot.read_i32()?;
    Ok(ArchivalStatus::from(enum_value))
  }
}

impl From<i32> for ArchivalStatus {
  fn from(i: i32) -> Self {
    match i {
      0 => ArchivalStatus::DISABLED,
      1 => ArchivalStatus::ENABLED,
      _ => ArchivalStatus(i)
    }
  }
}

impl From<&i32> for ArchivalStatus {
  fn from(i: &i32) -> Self {
    ArchivalStatus::from(*i)
  }
}

impl From<ArchivalStatus> for i32 {
  fn from(e: ArchivalStatus) -> i32 {
    e.0
  }
}

impl From<&ArchivalStatus> for i32 {
  fn from(e: &ArchivalStatus) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CronOverlapPolicy(pub i32);

impl CronOverlapPolicy {
  pub const SKIPPED: CronOverlapPolicy = CronOverlapPolicy(0);
  pub const BUFFERONE: CronOverlapPolicy = CronOverlapPolicy(1);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SKIPPED,
    Self::BUFFERONE,
  ];
}

impl TSerializable for CronOverlapPolicy {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CronOverlapPolicy> {
    let enum_value = i_prot.read_i32()?;
    Ok(CronOverlapPolicy::from(enum_value))
  }
}

impl From<i32> for CronOverlapPolicy {
  fn from(i: i32) -> Self {
    match i {
      0 => CronOverlapPolicy::SKIPPED,
      1 => CronOverlapPolicy::BUFFERONE,
      _ => CronOverlapPolicy(i)
    }
  }
}

impl From<&i32> for CronOverlapPolicy {
  fn from(i: &i32) -> Self {
    CronOverlapPolicy::from(*i)
  }
}

impl From<CronOverlapPolicy> for i32 {
  fn from(e: CronOverlapPolicy) -> i32 {
    e.0
  }
}

impl From<&CronOverlapPolicy> for i32 {
  fn from(e: &CronOverlapPolicy) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct IndexedValueType(pub i32);

impl IndexedValueType {
  pub const STRING: IndexedValueType = IndexedValueType(0);
  pub const KEYWORD: IndexedValueType = IndexedValueType(1);
  pub const INT: IndexedValueType = IndexedValueType(2);
  pub const DOUBLE: IndexedValueType = IndexedValueType(3);
  pub const BOOL: IndexedValueType = IndexedValueType(4);
  pub const DATETIME: IndexedValueType = IndexedValueType(5);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::STRING,
    Self::KEYWORD,
    Self::INT,
    Self::DOUBLE,
    Self::BOOL,
    Self::DATETIME,
  ];
}

impl TSerializable for IndexedValueType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IndexedValueType> {
    let enum_value = i_prot.read_i32()?;
    Ok(IndexedValueType::from(enum_value))
  }
}

impl From<i32> for IndexedValueType {
  fn from(i: i32) -> Self {
    match i {
      0 => IndexedValueType::STRING,
      1 => IndexedValueType::KEYWORD,
      2 => IndexedValueType::INT,
      3 => IndexedValueType::DOUBLE,
      4 => IndexedValueType::BOOL,
      5 => IndexedValueType::DATETIME,
      _ => IndexedValueType(i)
    }
  }
}

impl From<&i32> for IndexedValueType {
  fn from(i: &i32) -> Self {
    IndexedValueType::from(*i)
  }
}

impl From<IndexedValueType> for i32 {
  fn from(e: IndexedValueType) -> i32 {
    e.0
  }
}

impl From<&IndexedValueType> for i32 {
  fn from(e: &IndexedValueType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct EncodingType(pub i32);

impl EncodingType {
  pub const THRIFT_R_W: EncodingType = EncodingType(0);
  pub const JSON: EncodingType = EncodingType(1);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::THRIFT_R_W,
    Self::JSON,
  ];
}

impl TSerializable for EncodingType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<EncodingType> {
    let enum_value = i_prot.read_i32()?;
    Ok(EncodingType::from(enum_value))
  }
}

impl From<i32> for EncodingType {
  fn from(i: i32) -> Self {
    match i {
      0 => EncodingType::THRIFT_R_W,
      1 => EncodingType::JSON,
      _ => EncodingType(i)
    }
  }
}

impl From<&i32> for EncodingType {
  fn from(i: &i32) -> Self {
    EncodingType::from(*i)
  }
}

impl From<EncodingType> for i32 {
  fn from(e: EncodingType) -> i32 {
    e.0
  }
}

impl From<&EncodingType> for i32 {
  fn from(e: &EncodingType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct QueryRejectCondition(pub i32);

impl QueryRejectCondition {
  pub const NOT_OPEN: QueryRejectCondition = QueryRejectCondition(0);
  pub const NOT_COMPLETED_CLEANLY: QueryRejectCondition = QueryRejectCondition(1);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NOT_OPEN,
    Self::NOT_COMPLETED_CLEANLY,
  ];
}

impl TSerializable for QueryRejectCondition {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<QueryRejectCondition> {
    let enum_value = i_prot.read_i32()?;
    Ok(QueryRejectCondition::from(enum_value))
  }
}

impl From<i32> for QueryRejectCondition {
  fn from(i: i32) -> Self {
    match i {
      0 => QueryRejectCondition::NOT_OPEN,
      1 => QueryRejectCondition::NOT_COMPLETED_CLEANLY,
      _ => QueryRejectCondition(i)
    }
  }
}

impl From<&i32> for QueryRejectCondition {
  fn from(i: &i32) -> Self {
    QueryRejectCondition::from(*i)
  }
}

impl From<QueryRejectCondition> for i32 {
  fn from(e: QueryRejectCondition) -> i32 {
    e.0
  }
}

impl From<&QueryRejectCondition> for i32 {
  fn from(e: &QueryRejectCondition) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct QueryConsistencyLevel(pub i32);

impl QueryConsistencyLevel {
  pub const EVENTUAL: QueryConsistencyLevel = QueryConsistencyLevel(0);
  pub const STRONG: QueryConsistencyLevel = QueryConsistencyLevel(1);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::EVENTUAL,
    Self::STRONG,
  ];
}

impl TSerializable for QueryConsistencyLevel {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<QueryConsistencyLevel> {
    let enum_value = i_prot.read_i32()?;
    Ok(QueryConsistencyLevel::from(enum_value))
  }
}

impl From<i32> for QueryConsistencyLevel {
  fn from(i: i32) -> Self {
    match i {
      0 => QueryConsistencyLevel::EVENTUAL,
      1 => QueryConsistencyLevel::STRONG,
      _ => QueryConsistencyLevel(i)
    }
  }
}

impl From<&i32> for QueryConsistencyLevel {
  fn from(i: &i32) -> Self {
    QueryConsistencyLevel::from(*i)
  }
}

impl From<QueryConsistencyLevel> for i32 {
  fn from(e: QueryConsistencyLevel) -> i32 {
    e.0
  }
}

impl From<&QueryConsistencyLevel> for i32 {
  fn from(e: &QueryConsistencyLevel) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ContinueAsNewInitiator(pub i32);

impl ContinueAsNewInitiator {
  pub const DECIDER: ContinueAsNewInitiator = ContinueAsNewInitiator(0);
  pub const RETRY_POLICY: ContinueAsNewInitiator = ContinueAsNewInitiator(1);
  pub const CRON_SCHEDULE: ContinueAsNewInitiator = ContinueAsNewInitiator(2);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::DECIDER,
    Self::RETRY_POLICY,
    Self::CRON_SCHEDULE,
  ];
}

impl TSerializable for ContinueAsNewInitiator {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ContinueAsNewInitiator> {
    let enum_value = i_prot.read_i32()?;
    Ok(ContinueAsNewInitiator::from(enum_value))
  }
}

impl From<i32> for ContinueAsNewInitiator {
  fn from(i: i32) -> Self {
    match i {
      0 => ContinueAsNewInitiator::DECIDER,
      1 => ContinueAsNewInitiator::RETRY_POLICY,
      2 => ContinueAsNewInitiator::CRON_SCHEDULE,
      _ => ContinueAsNewInitiator(i)
    }
  }
}

impl From<&i32> for ContinueAsNewInitiator {
  fn from(i: &i32) -> Self {
    ContinueAsNewInitiator::from(*i)
  }
}

impl From<ContinueAsNewInitiator> for i32 {
  fn from(e: ContinueAsNewInitiator) -> i32 {
    e.0
  }
}

impl From<&ContinueAsNewInitiator> for i32 {
  fn from(e: &ContinueAsNewInitiator) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TaskListType(pub i32);

impl TaskListType {
  pub const DECISION: TaskListType = TaskListType(0);
  pub const ACTIVITY: TaskListType = TaskListType(1);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::DECISION,
    Self::ACTIVITY,
  ];
}

impl TSerializable for TaskListType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TaskListType> {
    let enum_value = i_prot.read_i32()?;
    Ok(TaskListType::from(enum_value))
  }
}

impl From<i32> for TaskListType {
  fn from(i: i32) -> Self {
    match i {
      0 => TaskListType::DECISION,
      1 => TaskListType::ACTIVITY,
      _ => TaskListType(i)
    }
  }
}

impl From<&i32> for TaskListType {
  fn from(i: &i32) -> Self {
    TaskListType::from(*i)
  }
}

impl From<TaskListType> for i32 {
  fn from(e: TaskListType) -> i32 {
    e.0
  }
}

impl From<&TaskListType> for i32 {
  fn from(e: &TaskListType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CrossClusterTaskType(pub i32);

impl CrossClusterTaskType {
  pub const START_CHILD_EXECUTION: CrossClusterTaskType = CrossClusterTaskType(0);
  pub const CANCEL_EXECUTION: CrossClusterTaskType = CrossClusterTaskType(1);
  pub const SIGNAL_EXECUTION: CrossClusterTaskType = CrossClusterTaskType(2);
  pub const RECORD_CHILD_WORKFLOW_EXECUTION_COMPLETE: CrossClusterTaskType = CrossClusterTaskType(3);
  pub const APPLY_PARENT_CLOSE_POLICY: CrossClusterTaskType = CrossClusterTaskType(4);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::START_CHILD_EXECUTION,
    Self::CANCEL_EXECUTION,
    Self::SIGNAL_EXECUTION,
    Self::RECORD_CHILD_WORKFLOW_EXECUTION_COMPLETE,
    Self::APPLY_PARENT_CLOSE_POLICY,
  ];
}

impl TSerializable for CrossClusterTaskType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CrossClusterTaskType> {
    let enum_value = i_prot.read_i32()?;
    Ok(CrossClusterTaskType::from(enum_value))
  }
}

impl From<i32> for CrossClusterTaskType {
  fn from(i: i32) -> Self {
    match i {
      0 => CrossClusterTaskType::START_CHILD_EXECUTION,
      1 => CrossClusterTaskType::CANCEL_EXECUTION,
      2 => CrossClusterTaskType::SIGNAL_EXECUTION,
      3 => CrossClusterTaskType::RECORD_CHILD_WORKFLOW_EXECUTION_COMPLETE,
      4 => CrossClusterTaskType::APPLY_PARENT_CLOSE_POLICY,
      _ => CrossClusterTaskType(i)
    }
  }
}

impl From<&i32> for CrossClusterTaskType {
  fn from(i: &i32) -> Self {
    CrossClusterTaskType::from(*i)
  }
}

impl From<CrossClusterTaskType> for i32 {
  fn from(e: CrossClusterTaskType) -> i32 {
    e.0
  }
}

impl From<&CrossClusterTaskType> for i32 {
  fn from(e: &CrossClusterTaskType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CrossClusterTaskFailedCause(pub i32);

impl CrossClusterTaskFailedCause {
  pub const DOMAIN_NOT_ACTIVE: CrossClusterTaskFailedCause = CrossClusterTaskFailedCause(0);
  pub const DOMAIN_NOT_EXISTS: CrossClusterTaskFailedCause = CrossClusterTaskFailedCause(1);
  pub const WORKFLOW_ALREADY_RUNNING: CrossClusterTaskFailedCause = CrossClusterTaskFailedCause(2);
  pub const WORKFLOW_NOT_EXISTS: CrossClusterTaskFailedCause = CrossClusterTaskFailedCause(3);
  pub const WORKFLOW_ALREADY_COMPLETED: CrossClusterTaskFailedCause = CrossClusterTaskFailedCause(4);
  pub const UNCATEGORIZED: CrossClusterTaskFailedCause = CrossClusterTaskFailedCause(5);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::DOMAIN_NOT_ACTIVE,
    Self::DOMAIN_NOT_EXISTS,
    Self::WORKFLOW_ALREADY_RUNNING,
    Self::WORKFLOW_NOT_EXISTS,
    Self::WORKFLOW_ALREADY_COMPLETED,
    Self::UNCATEGORIZED,
  ];
}

impl TSerializable for CrossClusterTaskFailedCause {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CrossClusterTaskFailedCause> {
    let enum_value = i_prot.read_i32()?;
    Ok(CrossClusterTaskFailedCause::from(enum_value))
  }
}

impl From<i32> for CrossClusterTaskFailedCause {
  fn from(i: i32) -> Self {
    match i {
      0 => CrossClusterTaskFailedCause::DOMAIN_NOT_ACTIVE,
      1 => CrossClusterTaskFailedCause::DOMAIN_NOT_EXISTS,
      2 => CrossClusterTaskFailedCause::WORKFLOW_ALREADY_RUNNING,
      3 => CrossClusterTaskFailedCause::WORKFLOW_NOT_EXISTS,
      4 => CrossClusterTaskFailedCause::WORKFLOW_ALREADY_COMPLETED,
      5 => CrossClusterTaskFailedCause::UNCATEGORIZED,
      _ => CrossClusterTaskFailedCause(i)
    }
  }
}

impl From<&i32> for CrossClusterTaskFailedCause {
  fn from(i: &i32) -> Self {
    CrossClusterTaskFailedCause::from(*i)
  }
}

impl From<CrossClusterTaskFailedCause> for i32 {
  fn from(e: CrossClusterTaskFailedCause) -> i32 {
    e.0
  }
}

impl From<&CrossClusterTaskFailedCause> for i32 {
  fn from(e: &CrossClusterTaskFailedCause) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GetTaskFailedCause(pub i32);

impl GetTaskFailedCause {
  pub const SERVICE_BUSY: GetTaskFailedCause = GetTaskFailedCause(0);
  pub const TIMEOUT: GetTaskFailedCause = GetTaskFailedCause(1);
  pub const SHARD_OWNERSHIP_LOST: GetTaskFailedCause = GetTaskFailedCause(2);
  pub const UNCATEGORIZED: GetTaskFailedCause = GetTaskFailedCause(3);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SERVICE_BUSY,
    Self::TIMEOUT,
    Self::SHARD_OWNERSHIP_LOST,
    Self::UNCATEGORIZED,
  ];
}

impl TSerializable for GetTaskFailedCause {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GetTaskFailedCause> {
    let enum_value = i_prot.read_i32()?;
    Ok(GetTaskFailedCause::from(enum_value))
  }
}

impl From<i32> for GetTaskFailedCause {
  fn from(i: i32) -> Self {
    match i {
      0 => GetTaskFailedCause::SERVICE_BUSY,
      1 => GetTaskFailedCause::TIMEOUT,
      2 => GetTaskFailedCause::SHARD_OWNERSHIP_LOST,
      3 => GetTaskFailedCause::UNCATEGORIZED,
      _ => GetTaskFailedCause(i)
    }
  }
}

impl From<&i32> for GetTaskFailedCause {
  fn from(i: &i32) -> Self {
    GetTaskFailedCause::from(*i)
  }
}

impl From<GetTaskFailedCause> for i32 {
  fn from(e: GetTaskFailedCause) -> i32 {
    e.0
  }
}

impl From<&GetTaskFailedCause> for i32 {
  fn from(e: &GetTaskFailedCause) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct IsolationGroupState(pub i32);

impl IsolationGroupState {
  pub const INVALID: IsolationGroupState = IsolationGroupState(0);
  pub const HEALTHY: IsolationGroupState = IsolationGroupState(1);
  pub const DRAINED: IsolationGroupState = IsolationGroupState(2);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::INVALID,
    Self::HEALTHY,
    Self::DRAINED,
  ];
}

impl TSerializable for IsolationGroupState {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IsolationGroupState> {
    let enum_value = i_prot.read_i32()?;
    Ok(IsolationGroupState::from(enum_value))
  }
}

impl From<i32> for IsolationGroupState {
  fn from(i: i32) -> Self {
    match i {
      0 => IsolationGroupState::INVALID,
      1 => IsolationGroupState::HEALTHY,
      2 => IsolationGroupState::DRAINED,
      _ => IsolationGroupState(i)
    }
  }
}

impl From<&i32> for IsolationGroupState {
  fn from(i: &i32) -> Self {
    IsolationGroupState::from(*i)
  }
}

impl From<IsolationGroupState> for i32 {
  fn from(e: IsolationGroupState) -> i32 {
    e.0
  }
}

impl From<&IsolationGroupState> for i32 {
  fn from(e: &IsolationGroupState) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct FailoverType(pub i32);

impl FailoverType {
  pub const INVALID: FailoverType = FailoverType(0);
  pub const FORCE: FailoverType = FailoverType(1);
  pub const GRACEFUL: FailoverType = FailoverType(2);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::INVALID,
    Self::FORCE,
    Self::GRACEFUL,
  ];
}

impl TSerializable for FailoverType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<FailoverType> {
    let enum_value = i_prot.read_i32()?;
    Ok(FailoverType::from(enum_value))
  }
}

impl From<i32> for FailoverType {
  fn from(i: i32) -> Self {
    match i {
      0 => FailoverType::INVALID,
      1 => FailoverType::FORCE,
      2 => FailoverType::GRACEFUL,
      _ => FailoverType(i)
    }
  }
}

impl From<&i32> for FailoverType {
  fn from(i: &i32) -> Self {
    FailoverType::from(*i)
  }
}

impl From<FailoverType> for i32 {
  fn from(e: FailoverType) -> i32 {
    e.0
  }
}

impl From<&FailoverType> for i32 {
  fn from(e: &FailoverType) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ActiveClusterSelectionStrategy(pub i32);

impl ActiveClusterSelectionStrategy {
  pub const REGION_STICKY: ActiveClusterSelectionStrategy = ActiveClusterSelectionStrategy(0);
  pub const EXTERNAL_ENTITY: ActiveClusterSelectionStrategy = ActiveClusterSelectionStrategy(1);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REGION_STICKY,
    Self::EXTERNAL_ENTITY,
  ];
}

impl TSerializable for ActiveClusterSelectionStrategy {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ActiveClusterSelectionStrategy> {
    let enum_value = i_prot.read_i32()?;
    Ok(ActiveClusterSelectionStrategy::from(enum_value))
  }
}

impl From<i32> for ActiveClusterSelectionStrategy {
  fn from(i: i32) -> Self {
    match i {
      0 => ActiveClusterSelectionStrategy::REGION_STICKY,
      1 => ActiveClusterSelectionStrategy::EXTERNAL_ENTITY,
      _ => ActiveClusterSelectionStrategy(i)
    }
  }
}

impl From<&i32> for ActiveClusterSelectionStrategy {
  fn from(i: &i32) -> Self {
    ActiveClusterSelectionStrategy::from(*i)
  }
}

impl From<ActiveClusterSelectionStrategy> for i32 {
  fn from(e: ActiveClusterSelectionStrategy) -> i32 {
    e.0
  }
}

impl From<&ActiveClusterSelectionStrategy> for i32 {
  fn from(e: &ActiveClusterSelectionStrategy) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PredicateType(pub i32);

impl PredicateType {
  pub const UNIVERSAL: PredicateType = PredicateType(0);
  pub const EMPTY: PredicateType = PredicateType(1);
  pub const DOMAIN_I_D: PredicateType = PredicateType(2);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::UNIVERSAL,
    Self::EMPTY,
    Self::DOMAIN_I_D,
  ];
}

impl TSerializable for PredicateType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PredicateType> {
    let enum_value = i_prot.read_i32()?;
    Ok(PredicateType::from(enum_value))
  }
}

impl From<i32> for PredicateType {
  fn from(i: i32) -> Self {
    match i {
      0 => PredicateType::UNIVERSAL,
      1 => PredicateType::EMPTY,
      2 => PredicateType::DOMAIN_I_D,
      _ => PredicateType(i)
    }
  }
}

impl From<&i32> for PredicateType {
  fn from(i: &i32) -> Self {
    PredicateType::from(*i)
  }
}

impl From<PredicateType> for i32 {
  fn from(e: PredicateType) -> i32 {
    e.0
  }
}

impl From<&PredicateType> for i32 {
  fn from(e: &PredicateType) -> i32 {
    e.0
  }
}

//
// BadRequestError
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct BadRequestError {
  pub message: String,
}

impl BadRequestError {
  pub fn new(message: String) -> BadRequestError {
    BadRequestError {
      message,
    }
  }
}

impl TSerializable for BadRequestError {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BadRequestError> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BadRequestError.message", &f_1)?;
    let ret = BadRequestError {
      message: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BadRequestError");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 1))?;
    o_prot.write_string(&self.message)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Error for BadRequestError {}

impl From<BadRequestError> for thrift::Error {
  fn from(e: BadRequestError) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for BadRequestError {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    write!(f, "remote service threw BadRequestError")
  }
}

//
// InternalServiceError
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct InternalServiceError {
  pub message: String,
}

impl InternalServiceError {
  pub fn new(message: String) -> InternalServiceError {
    InternalServiceError {
      message,
    }
  }
}

impl TSerializable for InternalServiceError {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<InternalServiceError> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("InternalServiceError.message", &f_1)?;
    let ret = InternalServiceError {
      message: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("InternalServiceError");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 1))?;
    o_prot.write_string(&self.message)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Error for InternalServiceError {}

impl From<InternalServiceError> for thrift::Error {
  fn from(e: InternalServiceError) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for InternalServiceError {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    write!(f, "remote service threw InternalServiceError")
  }
}

//
// InternalDataInconsistencyError
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct InternalDataInconsistencyError {
  pub message: String,
}

impl InternalDataInconsistencyError {
  pub fn new(message: String) -> InternalDataInconsistencyError {
    InternalDataInconsistencyError {
      message,
    }
  }
}

impl TSerializable for InternalDataInconsistencyError {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<InternalDataInconsistencyError> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("InternalDataInconsistencyError.message", &f_1)?;
    let ret = InternalDataInconsistencyError {
      message: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("InternalDataInconsistencyError");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 1))?;
    o_prot.write_string(&self.message)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Error for InternalDataInconsistencyError {}

impl From<InternalDataInconsistencyError> for thrift::Error {
  fn from(e: InternalDataInconsistencyError) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for InternalDataInconsistencyError {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    write!(f, "remote service threw InternalDataInconsistencyError")
  }
}

//
// DomainAlreadyExistsError
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DomainAlreadyExistsError {
  pub message: String,
}

impl DomainAlreadyExistsError {
  pub fn new(message: String) -> DomainAlreadyExistsError {
    DomainAlreadyExistsError {
      message,
    }
  }
}

impl TSerializable for DomainAlreadyExistsError {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DomainAlreadyExistsError> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DomainAlreadyExistsError.message", &f_1)?;
    let ret = DomainAlreadyExistsError {
      message: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DomainAlreadyExistsError");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 1))?;
    o_prot.write_string(&self.message)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Error for DomainAlreadyExistsError {}

impl From<DomainAlreadyExistsError> for thrift::Error {
  fn from(e: DomainAlreadyExistsError) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for DomainAlreadyExistsError {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    write!(f, "remote service threw DomainAlreadyExistsError")
  }
}

//
// WorkflowExecutionAlreadyStartedError
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WorkflowExecutionAlreadyStartedError {
  pub message: Option<String>,
  pub start_request_id: Option<String>,
  pub run_id: Option<String>,
}

impl WorkflowExecutionAlreadyStartedError {
  pub fn new<F10, F20, F30>(message: F10, start_request_id: F20, run_id: F30) -> WorkflowExecutionAlreadyStartedError where F10: Into<Option<String>>, F20: Into<Option<String>>, F30: Into<Option<String>> {
    WorkflowExecutionAlreadyStartedError {
      message: message.into(),
      start_request_id: start_request_id.into(),
      run_id: run_id.into(),
    }
  }
}

impl TSerializable for WorkflowExecutionAlreadyStartedError {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowExecutionAlreadyStartedError> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<String> = None;
    let mut f_30: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_string()?;
          f_30 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowExecutionAlreadyStartedError {
      message: f_10,
      start_request_id: f_20,
      run_id: f_30,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowExecutionAlreadyStartedError");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.message {
      o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.start_request_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("startRequestId", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.run_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("runId", TType::String, 30))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Error for WorkflowExecutionAlreadyStartedError {}

impl From<WorkflowExecutionAlreadyStartedError> for thrift::Error {
  fn from(e: WorkflowExecutionAlreadyStartedError) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for WorkflowExecutionAlreadyStartedError {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    write!(f, "remote service threw WorkflowExecutionAlreadyStartedError")
  }
}

//
// WorkflowExecutionAlreadyCompletedError
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WorkflowExecutionAlreadyCompletedError {
  pub message: String,
}

impl WorkflowExecutionAlreadyCompletedError {
  pub fn new(message: String) -> WorkflowExecutionAlreadyCompletedError {
    WorkflowExecutionAlreadyCompletedError {
      message,
    }
  }
}

impl TSerializable for WorkflowExecutionAlreadyCompletedError {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowExecutionAlreadyCompletedError> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("WorkflowExecutionAlreadyCompletedError.message", &f_1)?;
    let ret = WorkflowExecutionAlreadyCompletedError {
      message: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowExecutionAlreadyCompletedError");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 1))?;
    o_prot.write_string(&self.message)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Error for WorkflowExecutionAlreadyCompletedError {}

impl From<WorkflowExecutionAlreadyCompletedError> for thrift::Error {
  fn from(e: WorkflowExecutionAlreadyCompletedError) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for WorkflowExecutionAlreadyCompletedError {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    write!(f, "remote service threw WorkflowExecutionAlreadyCompletedError")
  }
}

//
// EntityNotExistsError
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct EntityNotExistsError {
  pub message: String,
  pub current_cluster: Option<String>,
  pub active_cluster: Option<String>,
  pub active_clusters: Vec<String>,
}

impl EntityNotExistsError {
  pub fn new<F2, F3>(message: String, current_cluster: F2, active_cluster: F3, active_clusters: Vec<String>) -> EntityNotExistsError where F2: Into<Option<String>>, F3: Into<Option<String>> {
    EntityNotExistsError {
      message,
      current_cluster: current_cluster.into(),
      active_cluster: active_cluster.into(),
      active_clusters,
    }
  }
}

impl TSerializable for EntityNotExistsError {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<EntityNotExistsError> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_0 = i_prot.read_string()?;
            val.push(list_elem_0);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("EntityNotExistsError.message", &f_1)?;
    verify_required_field_exists("EntityNotExistsError.active_clusters", &f_4)?;
    let ret = EntityNotExistsError {
      message: f_1.expect("auto-generated code should have checked for presence of required fields"),
      current_cluster: f_2,
      active_cluster: f_3,
      active_clusters: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("EntityNotExistsError");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 1))?;
    o_prot.write_string(&self.message)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.current_cluster {
      o_prot.write_field_begin(&TFieldIdentifier::new("currentCluster", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.active_cluster {
      o_prot.write_field_begin(&TFieldIdentifier::new("activeCluster", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_begin(&TFieldIdentifier::new("activeClusters", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.active_clusters.len() as i32))?;
    for e in &self.active_clusters {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Error for EntityNotExistsError {}

impl From<EntityNotExistsError> for thrift::Error {
  fn from(e: EntityNotExistsError) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for EntityNotExistsError {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    write!(f, "remote service threw EntityNotExistsError")
  }
}

//
// ServiceBusyError
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ServiceBusyError {
  pub message: String,
  pub reason: Option<String>,
}

impl ServiceBusyError {
  pub fn new<F2>(message: String, reason: F2) -> ServiceBusyError where F2: Into<Option<String>> {
    ServiceBusyError {
      message,
      reason: reason.into(),
    }
  }
}

impl TSerializable for ServiceBusyError {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceBusyError> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceBusyError.message", &f_1)?;
    let ret = ServiceBusyError {
      message: f_1.expect("auto-generated code should have checked for presence of required fields"),
      reason: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceBusyError");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 1))?;
    o_prot.write_string(&self.message)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.reason {
      o_prot.write_field_begin(&TFieldIdentifier::new("reason", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Error for ServiceBusyError {}

impl From<ServiceBusyError> for thrift::Error {
  fn from(e: ServiceBusyError) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for ServiceBusyError {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    write!(f, "remote service threw ServiceBusyError")
  }
}

//
// CancellationAlreadyRequestedError
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CancellationAlreadyRequestedError {
  pub message: String,
}

impl CancellationAlreadyRequestedError {
  pub fn new(message: String) -> CancellationAlreadyRequestedError {
    CancellationAlreadyRequestedError {
      message,
    }
  }
}

impl TSerializable for CancellationAlreadyRequestedError {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CancellationAlreadyRequestedError> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("CancellationAlreadyRequestedError.message", &f_1)?;
    let ret = CancellationAlreadyRequestedError {
      message: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CancellationAlreadyRequestedError");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 1))?;
    o_prot.write_string(&self.message)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Error for CancellationAlreadyRequestedError {}

impl From<CancellationAlreadyRequestedError> for thrift::Error {
  fn from(e: CancellationAlreadyRequestedError) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for CancellationAlreadyRequestedError {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    write!(f, "remote service threw CancellationAlreadyRequestedError")
  }
}

//
// QueryFailedError
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct QueryFailedError {
  pub message: String,
}

impl QueryFailedError {
  pub fn new(message: String) -> QueryFailedError {
    QueryFailedError {
      message,
    }
  }
}

impl TSerializable for QueryFailedError {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<QueryFailedError> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("QueryFailedError.message", &f_1)?;
    let ret = QueryFailedError {
      message: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("QueryFailedError");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 1))?;
    o_prot.write_string(&self.message)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Error for QueryFailedError {}

impl From<QueryFailedError> for thrift::Error {
  fn from(e: QueryFailedError) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for QueryFailedError {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    write!(f, "remote service threw QueryFailedError")
  }
}

//
// DomainNotActiveError
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DomainNotActiveError {
  pub message: String,
  pub domain_name: String,
  pub current_cluster: String,
  pub active_cluster: String,
  pub active_clusters: Vec<String>,
}

impl DomainNotActiveError {
  pub fn new(message: String, domain_name: String, current_cluster: String, active_cluster: String, active_clusters: Vec<String>) -> DomainNotActiveError {
    DomainNotActiveError {
      message,
      domain_name,
      current_cluster,
      active_cluster,
      active_clusters,
    }
  }
}

impl TSerializable for DomainNotActiveError {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DomainNotActiveError> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_1 = i_prot.read_string()?;
            val.push(list_elem_1);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DomainNotActiveError.message", &f_1)?;
    verify_required_field_exists("DomainNotActiveError.domain_name", &f_2)?;
    verify_required_field_exists("DomainNotActiveError.current_cluster", &f_3)?;
    verify_required_field_exists("DomainNotActiveError.active_cluster", &f_4)?;
    verify_required_field_exists("DomainNotActiveError.active_clusters", &f_5)?;
    let ret = DomainNotActiveError {
      message: f_1.expect("auto-generated code should have checked for presence of required fields"),
      domain_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      current_cluster: f_3.expect("auto-generated code should have checked for presence of required fields"),
      active_cluster: f_4.expect("auto-generated code should have checked for presence of required fields"),
      active_clusters: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DomainNotActiveError");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 1))?;
    o_prot.write_string(&self.message)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("domainName", TType::String, 2))?;
    o_prot.write_string(&self.domain_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("currentCluster", TType::String, 3))?;
    o_prot.write_string(&self.current_cluster)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("activeCluster", TType::String, 4))?;
    o_prot.write_string(&self.active_cluster)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("activeClusters", TType::List, 5))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.active_clusters.len() as i32))?;
    for e in &self.active_clusters {
      o_prot.write_string(e)?;
    }
    o_prot.write_list_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Error for DomainNotActiveError {}

impl From<DomainNotActiveError> for thrift::Error {
  fn from(e: DomainNotActiveError) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for DomainNotActiveError {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    write!(f, "remote service threw DomainNotActiveError")
  }
}

//
// LimitExceededError
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct LimitExceededError {
  pub message: String,
}

impl LimitExceededError {
  pub fn new(message: String) -> LimitExceededError {
    LimitExceededError {
      message,
    }
  }
}

impl TSerializable for LimitExceededError {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<LimitExceededError> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("LimitExceededError.message", &f_1)?;
    let ret = LimitExceededError {
      message: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("LimitExceededError");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 1))?;
    o_prot.write_string(&self.message)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Error for LimitExceededError {}

impl From<LimitExceededError> for thrift::Error {
  fn from(e: LimitExceededError) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for LimitExceededError {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    write!(f, "remote service threw LimitExceededError")
  }
}

//
// AccessDeniedError
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AccessDeniedError {
  pub message: String,
}

impl AccessDeniedError {
  pub fn new(message: String) -> AccessDeniedError {
    AccessDeniedError {
      message,
    }
  }
}

impl TSerializable for AccessDeniedError {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AccessDeniedError> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("AccessDeniedError.message", &f_1)?;
    let ret = AccessDeniedError {
      message: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AccessDeniedError");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 1))?;
    o_prot.write_string(&self.message)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Error for AccessDeniedError {}

impl From<AccessDeniedError> for thrift::Error {
  fn from(e: AccessDeniedError) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for AccessDeniedError {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    write!(f, "remote service threw AccessDeniedError")
  }
}

//
// RetryTaskV2Error
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RetryTaskV2Error {
  pub message: String,
  pub domain_id: Option<String>,
  pub workflow_id: Option<String>,
  pub run_id: Option<String>,
  pub start_event_id: Option<i64>,
  pub start_event_version: Option<i64>,
  pub end_event_id: Option<i64>,
  pub end_event_version: Option<i64>,
}

impl RetryTaskV2Error {
  pub fn new<F2, F3, F4, F5, F6, F7, F8>(message: String, domain_id: F2, workflow_id: F3, run_id: F4, start_event_id: F5, start_event_version: F6, end_event_id: F7, end_event_version: F8) -> RetryTaskV2Error where F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<i64>>, F6: Into<Option<i64>>, F7: Into<Option<i64>>, F8: Into<Option<i64>> {
    RetryTaskV2Error {
      message,
      domain_id: domain_id.into(),
      workflow_id: workflow_id.into(),
      run_id: run_id.into(),
      start_event_id: start_event_id.into(),
      start_event_version: start_event_version.into(),
      end_event_id: end_event_id.into(),
      end_event_version: end_event_version.into(),
    }
  }
}

impl TSerializable for RetryTaskV2Error {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RetryTaskV2Error> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<i64> = None;
    let mut f_6: Option<i64> = None;
    let mut f_7: Option<i64> = None;
    let mut f_8: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i64()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i64()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i64()?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("RetryTaskV2Error.message", &f_1)?;
    let ret = RetryTaskV2Error {
      message: f_1.expect("auto-generated code should have checked for presence of required fields"),
      domain_id: f_2,
      workflow_id: f_3,
      run_id: f_4,
      start_event_id: f_5,
      start_event_version: f_6,
      end_event_id: f_7,
      end_event_version: f_8,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RetryTaskV2Error");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 1))?;
    o_prot.write_string(&self.message)?;
    o_prot.write_field_end()?;
    if let Some(ref fld_var) = self.domain_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("domainId", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowId", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.run_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("runId", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.start_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("startEventId", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.start_event_version {
      o_prot.write_field_begin(&TFieldIdentifier::new("startEventVersion", TType::I64, 6))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.end_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("endEventId", TType::I64, 7))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.end_event_version {
      o_prot.write_field_begin(&TFieldIdentifier::new("endEventVersion", TType::I64, 8))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Error for RetryTaskV2Error {}

impl From<RetryTaskV2Error> for thrift::Error {
  fn from(e: RetryTaskV2Error) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for RetryTaskV2Error {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    write!(f, "remote service threw RetryTaskV2Error")
  }
}

//
// ClientVersionNotSupportedError
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ClientVersionNotSupportedError {
  pub feature_version: String,
  pub client_impl: String,
  pub supported_versions: String,
}

impl ClientVersionNotSupportedError {
  pub fn new(feature_version: String, client_impl: String, supported_versions: String) -> ClientVersionNotSupportedError {
    ClientVersionNotSupportedError {
      feature_version,
      client_impl,
      supported_versions,
    }
  }
}

impl TSerializable for ClientVersionNotSupportedError {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ClientVersionNotSupportedError> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ClientVersionNotSupportedError.feature_version", &f_1)?;
    verify_required_field_exists("ClientVersionNotSupportedError.client_impl", &f_2)?;
    verify_required_field_exists("ClientVersionNotSupportedError.supported_versions", &f_3)?;
    let ret = ClientVersionNotSupportedError {
      feature_version: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_impl: f_2.expect("auto-generated code should have checked for presence of required fields"),
      supported_versions: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ClientVersionNotSupportedError");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("featureVersion", TType::String, 1))?;
    o_prot.write_string(&self.feature_version)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientImpl", TType::String, 2))?;
    o_prot.write_string(&self.client_impl)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("supportedVersions", TType::String, 3))?;
    o_prot.write_string(&self.supported_versions)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Error for ClientVersionNotSupportedError {}

impl From<ClientVersionNotSupportedError> for thrift::Error {
  fn from(e: ClientVersionNotSupportedError) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for ClientVersionNotSupportedError {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    write!(f, "remote service threw ClientVersionNotSupportedError")
  }
}

//
// FeatureNotEnabledError
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct FeatureNotEnabledError {
  pub feature_flag: String,
}

impl FeatureNotEnabledError {
  pub fn new(feature_flag: String) -> FeatureNotEnabledError {
    FeatureNotEnabledError {
      feature_flag,
    }
  }
}

impl TSerializable for FeatureNotEnabledError {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<FeatureNotEnabledError> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("FeatureNotEnabledError.feature_flag", &f_1)?;
    let ret = FeatureNotEnabledError {
      feature_flag: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("FeatureNotEnabledError");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("featureFlag", TType::String, 1))?;
    o_prot.write_string(&self.feature_flag)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Error for FeatureNotEnabledError {}

impl From<FeatureNotEnabledError> for thrift::Error {
  fn from(e: FeatureNotEnabledError) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for FeatureNotEnabledError {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    write!(f, "remote service threw FeatureNotEnabledError")
  }
}

//
// CurrentBranchChangedError
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CurrentBranchChangedError {
  pub message: String,
  pub current_branch_token: Vec<u8>,
}

impl CurrentBranchChangedError {
  pub fn new(message: String, current_branch_token: Vec<u8>) -> CurrentBranchChangedError {
    CurrentBranchChangedError {
      message,
      current_branch_token,
    }
  }
}

impl TSerializable for CurrentBranchChangedError {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CurrentBranchChangedError> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_bytes()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("CurrentBranchChangedError.message", &f_10)?;
    verify_required_field_exists("CurrentBranchChangedError.current_branch_token", &f_20)?;
    let ret = CurrentBranchChangedError {
      message: f_10.expect("auto-generated code should have checked for presence of required fields"),
      current_branch_token: f_20.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CurrentBranchChangedError");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 10))?;
    o_prot.write_string(&self.message)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("currentBranchToken", TType::String, 20))?;
    o_prot.write_bytes(&self.current_branch_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Error for CurrentBranchChangedError {}

impl From<CurrentBranchChangedError> for thrift::Error {
  fn from(e: CurrentBranchChangedError) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for CurrentBranchChangedError {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    write!(f, "remote service threw CurrentBranchChangedError")
  }
}

//
// RemoteSyncMatchedError
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RemoteSyncMatchedError {
  pub message: String,
}

impl RemoteSyncMatchedError {
  pub fn new(message: String) -> RemoteSyncMatchedError {
    RemoteSyncMatchedError {
      message,
    }
  }
}

impl TSerializable for RemoteSyncMatchedError {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RemoteSyncMatchedError> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("RemoteSyncMatchedError.message", &f_10)?;
    let ret = RemoteSyncMatchedError {
      message: f_10.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RemoteSyncMatchedError");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 10))?;
    o_prot.write_string(&self.message)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Error for RemoteSyncMatchedError {}

impl From<RemoteSyncMatchedError> for thrift::Error {
  fn from(e: RemoteSyncMatchedError) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for RemoteSyncMatchedError {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    write!(f, "remote service threw RemoteSyncMatchedError")
  }
}

//
// StickyWorkerUnavailableError
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct StickyWorkerUnavailableError {
  pub message: String,
}

impl StickyWorkerUnavailableError {
  pub fn new(message: String) -> StickyWorkerUnavailableError {
    StickyWorkerUnavailableError {
      message,
    }
  }
}

impl TSerializable for StickyWorkerUnavailableError {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<StickyWorkerUnavailableError> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("StickyWorkerUnavailableError.message", &f_1)?;
    let ret = StickyWorkerUnavailableError {
      message: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("StickyWorkerUnavailableError");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 1))?;
    o_prot.write_string(&self.message)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Error for StickyWorkerUnavailableError {}

impl From<StickyWorkerUnavailableError> for thrift::Error {
  fn from(e: StickyWorkerUnavailableError) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for StickyWorkerUnavailableError {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    write!(f, "remote service threw StickyWorkerUnavailableError")
  }
}

//
// TaskListNotOwnedByHostError
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TaskListNotOwnedByHostError {
  pub owned_by_identity: String,
  pub my_identity: String,
  pub tasklist_name: String,
}

impl TaskListNotOwnedByHostError {
  pub fn new(owned_by_identity: String, my_identity: String, tasklist_name: String) -> TaskListNotOwnedByHostError {
    TaskListNotOwnedByHostError {
      owned_by_identity,
      my_identity,
      tasklist_name,
    }
  }
}

impl TSerializable for TaskListNotOwnedByHostError {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TaskListNotOwnedByHostError> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("TaskListNotOwnedByHostError.owned_by_identity", &f_1)?;
    verify_required_field_exists("TaskListNotOwnedByHostError.my_identity", &f_2)?;
    verify_required_field_exists("TaskListNotOwnedByHostError.tasklist_name", &f_3)?;
    let ret = TaskListNotOwnedByHostError {
      owned_by_identity: f_1.expect("auto-generated code should have checked for presence of required fields"),
      my_identity: f_2.expect("auto-generated code should have checked for presence of required fields"),
      tasklist_name: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TaskListNotOwnedByHostError");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("ownedByIdentity", TType::String, 1))?;
    o_prot.write_string(&self.owned_by_identity)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("myIdentity", TType::String, 2))?;
    o_prot.write_string(&self.my_identity)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tasklistName", TType::String, 3))?;
    o_prot.write_string(&self.tasklist_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Error for TaskListNotOwnedByHostError {}

impl From<TaskListNotOwnedByHostError> for thrift::Error {
  fn from(e: TaskListNotOwnedByHostError) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for TaskListNotOwnedByHostError {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    write!(f, "remote service threw TaskListNotOwnedByHostError")
  }
}

//
// Header
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Header {
  pub fields: Option<BTreeMap<String, Vec<u8>>>,
}

impl Header {
  pub fn new<F10>(fields: F10) -> Header where F10: Into<Option<BTreeMap<String, Vec<u8>>>> {
    Header {
      fields: fields.into(),
    }
  }
}

impl TSerializable for Header {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Header> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<BTreeMap<String, Vec<u8>>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, Vec<u8>> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_2 = i_prot.read_string()?;
            let map_val_3 = i_prot.read_bytes()?;
            val.insert(map_key_2, map_val_3);
          }
          i_prot.read_map_end()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Header {
      fields: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Header");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.fields {
      o_prot.write_field_begin(&TFieldIdentifier::new("fields", TType::Map, 10))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_bytes(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowType
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WorkflowType {
  pub name: Option<String>,
}

impl WorkflowType {
  pub fn new<F10>(name: F10) -> WorkflowType where F10: Into<Option<String>> {
    WorkflowType {
      name: name.into(),
    }
  }
}

impl TSerializable for WorkflowType {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowType> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowType {
      name: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowType");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ActivityType
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ActivityType {
  pub name: Option<String>,
}

impl ActivityType {
  pub fn new<F10>(name: F10) -> ActivityType where F10: Into<Option<String>> {
    ActivityType {
      name: name.into(),
    }
  }
}

impl TSerializable for ActivityType {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ActivityType> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ActivityType {
      name: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ActivityType");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TaskList
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TaskList {
  pub name: Option<String>,
  pub kind: Option<TaskListKind>,
}

impl TaskList {
  pub fn new<F10, F20>(name: F10, kind: F20) -> TaskList where F10: Into<Option<String>>, F20: Into<Option<TaskListKind>> {
    TaskList {
      name: name.into(),
      kind: kind.into(),
    }
  }
}

impl TSerializable for TaskList {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TaskList> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<TaskListKind> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = TaskListKind::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TaskList {
      name: f_10,
      kind: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TaskList");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.kind {
      o_prot.write_field_begin(&TFieldIdentifier::new("kind", TType::I32, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DataBlob
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DataBlob {
  pub encoding_type: Option<EncodingType>,
  pub data: Option<Vec<u8>>,
}

impl DataBlob {
  pub fn new<F10, F20>(encoding_type: F10, data: F20) -> DataBlob where F10: Into<Option<EncodingType>>, F20: Into<Option<Vec<u8>>> {
    DataBlob {
      encoding_type: encoding_type.into(),
      data: data.into(),
    }
  }
}

impl TSerializable for DataBlob {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DataBlob> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<EncodingType> = None;
    let mut f_20: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = EncodingType::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_bytes()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DataBlob {
      encoding_type: f_10,
      data: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DataBlob");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.encoding_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("EncodingType", TType::I32, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.data {
      o_prot.write_field_begin(&TFieldIdentifier::new("Data", TType::String, 20))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TaskListMetadata
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TaskListMetadata {
  pub max_tasks_per_second: Option<OrderedFloat<f64>>,
}

impl TaskListMetadata {
  pub fn new<F10>(max_tasks_per_second: F10) -> TaskListMetadata where F10: Into<Option<OrderedFloat<f64>>> {
    TaskListMetadata {
      max_tasks_per_second: max_tasks_per_second.into(),
    }
  }
}

impl TSerializable for TaskListMetadata {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TaskListMetadata> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<OrderedFloat<f64>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TaskListMetadata {
      max_tasks_per_second: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TaskListMetadata");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.max_tasks_per_second {
      o_prot.write_field_begin(&TFieldIdentifier::new("maxTasksPerSecond", TType::Double, 10))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowExecution
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WorkflowExecution {
  pub workflow_id: Option<String>,
  pub run_id: Option<String>,
}

impl WorkflowExecution {
  pub fn new<F10, F20>(workflow_id: F10, run_id: F20) -> WorkflowExecution where F10: Into<Option<String>>, F20: Into<Option<String>> {
    WorkflowExecution {
      workflow_id: workflow_id.into(),
      run_id: run_id.into(),
    }
  }
}

impl TSerializable for WorkflowExecution {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowExecution> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowExecution {
      workflow_id: f_10,
      run_id: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowExecution");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.workflow_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowId", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.run_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("runId", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// Memo
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Memo {
  pub fields: Option<BTreeMap<String, Vec<u8>>>,
}

impl Memo {
  pub fn new<F10>(fields: F10) -> Memo where F10: Into<Option<BTreeMap<String, Vec<u8>>>> {
    Memo {
      fields: fields.into(),
    }
  }
}

impl TSerializable for Memo {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Memo> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<BTreeMap<String, Vec<u8>>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, Vec<u8>> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_4 = i_prot.read_string()?;
            let map_val_5 = i_prot.read_bytes()?;
            val.insert(map_key_4, map_val_5);
          }
          i_prot.read_map_end()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Memo {
      fields: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Memo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.fields {
      o_prot.write_field_begin(&TFieldIdentifier::new("fields", TType::Map, 10))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_bytes(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SearchAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SearchAttributes {
  pub indexed_fields: Option<BTreeMap<String, Vec<u8>>>,
}

impl SearchAttributes {
  pub fn new<F10>(indexed_fields: F10) -> SearchAttributes where F10: Into<Option<BTreeMap<String, Vec<u8>>>> {
    SearchAttributes {
      indexed_fields: indexed_fields.into(),
    }
  }
}

impl TSerializable for SearchAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SearchAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<BTreeMap<String, Vec<u8>>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, Vec<u8>> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_6 = i_prot.read_string()?;
            let map_val_7 = i_prot.read_bytes()?;
            val.insert(map_key_6, map_val_7);
          }
          i_prot.read_map_end()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SearchAttributes {
      indexed_fields: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SearchAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.indexed_fields {
      o_prot.write_field_begin(&TFieldIdentifier::new("indexedFields", TType::Map, 10))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_bytes(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkerVersionInfo
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WorkerVersionInfo {
  pub impl_: Option<String>,
  pub feature_version: Option<String>,
}

impl WorkerVersionInfo {
  pub fn new<F10, F20>(impl_: F10, feature_version: F20) -> WorkerVersionInfo where F10: Into<Option<String>>, F20: Into<Option<String>> {
    WorkerVersionInfo {
      impl_: impl_.into(),
      feature_version: feature_version.into(),
    }
  }
}

impl TSerializable for WorkerVersionInfo {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkerVersionInfo> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkerVersionInfo {
      impl_: f_10,
      feature_version: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkerVersionInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.impl_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("impl", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.feature_version {
      o_prot.write_field_begin(&TFieldIdentifier::new("featureVersion", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowExecutionInfo
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WorkflowExecutionInfo {
  pub execution: Option<WorkflowExecution>,
  pub type_: Option<WorkflowType>,
  pub start_time: Option<i64>,
  pub close_time: Option<i64>,
  pub close_status: Option<WorkflowExecutionCloseStatus>,
  pub history_length: Option<i64>,
  pub parent_domain_id: Option<String>,
  pub parent_domain_name: Option<String>,
  pub parent_initated_id: Option<i64>,
  pub parent_execution: Option<WorkflowExecution>,
  pub execution_time: Option<i64>,
  pub memo: Option<Memo>,
  pub search_attributes: Option<SearchAttributes>,
  pub auto_reset_points: Option<Box<ResetPoints>>,
  pub task_list: Option<String>,
  pub task_list_info: Option<TaskList>,
  pub is_cron: Option<bool>,
  pub update_time: Option<i64>,
  pub partition_config: Option<BTreeMap<String, String>>,
  pub cron_overlap_policy: Option<CronOverlapPolicy>,
  pub active_cluster_selection_policy: Option<Box<ActiveClusterSelectionPolicy>>,
  pub cron_schedule: Option<String>,
  pub execution_status: Option<WorkflowExecutionStatus>,
  pub scheduled_execution_time: Option<i64>,
}

impl WorkflowExecutionInfo {
  pub fn new<F10, F20, F30, F40, F50, F60, F70, F71, F72, F80, F90, F100, F101, F110, F120, F121, F130, F140, F150, F160, F170, F180, F190, F200>(execution: F10, type_: F20, start_time: F30, close_time: F40, close_status: F50, history_length: F60, parent_domain_id: F70, parent_domain_name: F71, parent_initated_id: F72, parent_execution: F80, execution_time: F90, memo: F100, search_attributes: F101, auto_reset_points: F110, task_list: F120, task_list_info: F121, is_cron: F130, update_time: F140, partition_config: F150, cron_overlap_policy: F160, active_cluster_selection_policy: F170, cron_schedule: F180, execution_status: F190, scheduled_execution_time: F200) -> WorkflowExecutionInfo where F10: Into<Option<WorkflowExecution>>, F20: Into<Option<WorkflowType>>, F30: Into<Option<i64>>, F40: Into<Option<i64>>, F50: Into<Option<WorkflowExecutionCloseStatus>>, F60: Into<Option<i64>>, F70: Into<Option<String>>, F71: Into<Option<String>>, F72: Into<Option<i64>>, F80: Into<Option<WorkflowExecution>>, F90: Into<Option<i64>>, F100: Into<Option<Memo>>, F101: Into<Option<SearchAttributes>>, F110: Into<Option<Box<ResetPoints>>>, F120: Into<Option<String>>, F121: Into<Option<TaskList>>, F130: Into<Option<bool>>, F140: Into<Option<i64>>, F150: Into<Option<BTreeMap<String, String>>>, F160: Into<Option<CronOverlapPolicy>>, F170: Into<Option<Box<ActiveClusterSelectionPolicy>>>, F180: Into<Option<String>>, F190: Into<Option<WorkflowExecutionStatus>>, F200: Into<Option<i64>> {
    WorkflowExecutionInfo {
      execution: execution.into(),
      type_: type_.into(),
      start_time: start_time.into(),
      close_time: close_time.into(),
      close_status: close_status.into(),
      history_length: history_length.into(),
      parent_domain_id: parent_domain_id.into(),
      parent_domain_name: parent_domain_name.into(),
      parent_initated_id: parent_initated_id.into(),
      parent_execution: parent_execution.into(),
      execution_time: execution_time.into(),
      memo: memo.into(),
      search_attributes: search_attributes.into(),
      auto_reset_points: auto_reset_points.into(),
      task_list: task_list.into(),
      task_list_info: task_list_info.into(),
      is_cron: is_cron.into(),
      update_time: update_time.into(),
      partition_config: partition_config.into(),
      cron_overlap_policy: cron_overlap_policy.into(),
      active_cluster_selection_policy: active_cluster_selection_policy.into(),
      cron_schedule: cron_schedule.into(),
      execution_status: execution_status.into(),
      scheduled_execution_time: scheduled_execution_time.into(),
    }
  }
}

impl TSerializable for WorkflowExecutionInfo {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowExecutionInfo> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<WorkflowExecution> = None;
    let mut f_20: Option<WorkflowType> = None;
    let mut f_30: Option<i64> = None;
    let mut f_40: Option<i64> = None;
    let mut f_50: Option<WorkflowExecutionCloseStatus> = None;
    let mut f_60: Option<i64> = None;
    let mut f_70: Option<String> = None;
    let mut f_71: Option<String> = None;
    let mut f_72: Option<i64> = None;
    let mut f_80: Option<WorkflowExecution> = None;
    let mut f_90: Option<i64> = None;
    let mut f_100: Option<Memo> = None;
    let mut f_101: Option<SearchAttributes> = None;
    let mut f_110: Option<Box<ResetPoints>> = None;
    let mut f_120: Option<String> = None;
    let mut f_121: Option<TaskList> = None;
    let mut f_130: Option<bool> = None;
    let mut f_140: Option<i64> = None;
    let mut f_150: Option<BTreeMap<String, String>> = None;
    let mut f_160: Option<CronOverlapPolicy> = None;
    let mut f_170: Option<Box<ActiveClusterSelectionPolicy>> = None;
    let mut f_180: Option<String> = None;
    let mut f_190: Option<WorkflowExecutionStatus> = None;
    let mut f_200: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = WorkflowExecution::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        20 => {
          let val = WorkflowType::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_i64()?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_i64()?;
          f_40 = Some(val);
        },
        50 => {
          let val = WorkflowExecutionCloseStatus::read_from_in_protocol(i_prot)?;
          f_50 = Some(val);
        },
        60 => {
          let val = i_prot.read_i64()?;
          f_60 = Some(val);
        },
        70 => {
          let val = i_prot.read_string()?;
          f_70 = Some(val);
        },
        71 => {
          let val = i_prot.read_string()?;
          f_71 = Some(val);
        },
        72 => {
          let val = i_prot.read_i64()?;
          f_72 = Some(val);
        },
        80 => {
          let val = WorkflowExecution::read_from_in_protocol(i_prot)?;
          f_80 = Some(val);
        },
        90 => {
          let val = i_prot.read_i64()?;
          f_90 = Some(val);
        },
        100 => {
          let val = Memo::read_from_in_protocol(i_prot)?;
          f_100 = Some(val);
        },
        101 => {
          let val = SearchAttributes::read_from_in_protocol(i_prot)?;
          f_101 = Some(val);
        },
        110 => {
          let val = Box::new(ResetPoints::read_from_in_protocol(i_prot)?);
          f_110 = Some(val);
        },
        120 => {
          let val = i_prot.read_string()?;
          f_120 = Some(val);
        },
        121 => {
          let val = TaskList::read_from_in_protocol(i_prot)?;
          f_121 = Some(val);
        },
        130 => {
          let val = i_prot.read_bool()?;
          f_130 = Some(val);
        },
        140 => {
          let val = i_prot.read_i64()?;
          f_140 = Some(val);
        },
        150 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_8 = i_prot.read_string()?;
            let map_val_9 = i_prot.read_string()?;
            val.insert(map_key_8, map_val_9);
          }
          i_prot.read_map_end()?;
          f_150 = Some(val);
        },
        160 => {
          let val = CronOverlapPolicy::read_from_in_protocol(i_prot)?;
          f_160 = Some(val);
        },
        170 => {
          let val = Box::new(ActiveClusterSelectionPolicy::read_from_in_protocol(i_prot)?);
          f_170 = Some(val);
        },
        180 => {
          let val = i_prot.read_string()?;
          f_180 = Some(val);
        },
        190 => {
          let val = WorkflowExecutionStatus::read_from_in_protocol(i_prot)?;
          f_190 = Some(val);
        },
        200 => {
          let val = i_prot.read_i64()?;
          f_200 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowExecutionInfo {
      execution: f_10,
      type_: f_20,
      start_time: f_30,
      close_time: f_40,
      close_status: f_50,
      history_length: f_60,
      parent_domain_id: f_70,
      parent_domain_name: f_71,
      parent_initated_id: f_72,
      parent_execution: f_80,
      execution_time: f_90,
      memo: f_100,
      search_attributes: f_101,
      auto_reset_points: f_110,
      task_list: f_120,
      task_list_info: f_121,
      is_cron: f_130,
      update_time: f_140,
      partition_config: f_150,
      cron_overlap_policy: f_160,
      active_cluster_selection_policy: f_170,
      cron_schedule: f_180,
      execution_status: f_190,
      scheduled_execution_time: f_200,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowExecutionInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.execution {
      o_prot.write_field_begin(&TFieldIdentifier::new("execution", TType::Struct, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.type_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.start_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("startTime", TType::I64, 30))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.close_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("closeTime", TType::I64, 40))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.close_status {
      o_prot.write_field_begin(&TFieldIdentifier::new("closeStatus", TType::I32, 50))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.history_length {
      o_prot.write_field_begin(&TFieldIdentifier::new("historyLength", TType::I64, 60))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.parent_domain_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("parentDomainId", TType::String, 70))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.parent_domain_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("parentDomainName", TType::String, 71))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.parent_initated_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("parentInitatedId", TType::I64, 72))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.parent_execution {
      o_prot.write_field_begin(&TFieldIdentifier::new("parentExecution", TType::Struct, 80))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.execution_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("executionTime", TType::I64, 90))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.memo {
      o_prot.write_field_begin(&TFieldIdentifier::new("memo", TType::Struct, 100))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.search_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("searchAttributes", TType::Struct, 101))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.auto_reset_points {
      o_prot.write_field_begin(&TFieldIdentifier::new("autoResetPoints", TType::Struct, 110))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.task_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskList", TType::String, 120))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.task_list_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskListInfo", TType::Struct, 121))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_cron {
      o_prot.write_field_begin(&TFieldIdentifier::new("isCron", TType::Bool, 130))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.update_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("updateTime", TType::I64, 140))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.partition_config {
      o_prot.write_field_begin(&TFieldIdentifier::new("partitionConfig", TType::Map, 150))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cron_overlap_policy {
      o_prot.write_field_begin(&TFieldIdentifier::new("cronOverlapPolicy", TType::I32, 160))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.active_cluster_selection_policy {
      o_prot.write_field_begin(&TFieldIdentifier::new("activeClusterSelectionPolicy", TType::Struct, 170))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cron_schedule {
      o_prot.write_field_begin(&TFieldIdentifier::new("cronSchedule", TType::String, 180))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.execution_status {
      o_prot.write_field_begin(&TFieldIdentifier::new("executionStatus", TType::I32, 190))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.scheduled_execution_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("scheduledExecutionTime", TType::I64, 200))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowExecutionConfiguration
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WorkflowExecutionConfiguration {
  pub task_list: Option<TaskList>,
  pub execution_start_to_close_timeout_seconds: Option<i32>,
  pub task_start_to_close_timeout_seconds: Option<i32>,
}

impl WorkflowExecutionConfiguration {
  pub fn new<F10, F20, F30>(task_list: F10, execution_start_to_close_timeout_seconds: F20, task_start_to_close_timeout_seconds: F30) -> WorkflowExecutionConfiguration where F10: Into<Option<TaskList>>, F20: Into<Option<i32>>, F30: Into<Option<i32>> {
    WorkflowExecutionConfiguration {
      task_list: task_list.into(),
      execution_start_to_close_timeout_seconds: execution_start_to_close_timeout_seconds.into(),
      task_start_to_close_timeout_seconds: task_start_to_close_timeout_seconds.into(),
    }
  }
}

impl TSerializable for WorkflowExecutionConfiguration {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowExecutionConfiguration> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<TaskList> = None;
    let mut f_20: Option<i32> = None;
    let mut f_30: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = TaskList::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_i32()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_i32()?;
          f_30 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowExecutionConfiguration {
      task_list: f_10,
      execution_start_to_close_timeout_seconds: f_20,
      task_start_to_close_timeout_seconds: f_30,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowExecutionConfiguration");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.task_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskList", TType::Struct, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.execution_start_to_close_timeout_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("executionStartToCloseTimeoutSeconds", TType::I32, 20))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.task_start_to_close_timeout_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskStartToCloseTimeoutSeconds", TType::I32, 30))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TransientDecisionInfo
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TransientDecisionInfo {
  pub scheduled_event: Option<Box<HistoryEvent>>,
  pub started_event: Option<Box<HistoryEvent>>,
}

impl TransientDecisionInfo {
  pub fn new<F10, F20>(scheduled_event: F10, started_event: F20) -> TransientDecisionInfo where F10: Into<Option<Box<HistoryEvent>>>, F20: Into<Option<Box<HistoryEvent>>> {
    TransientDecisionInfo {
      scheduled_event: scheduled_event.into(),
      started_event: started_event.into(),
    }
  }
}

impl TSerializable for TransientDecisionInfo {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TransientDecisionInfo> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<Box<HistoryEvent>> = None;
    let mut f_20: Option<Box<HistoryEvent>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = Box::new(HistoryEvent::read_from_in_protocol(i_prot)?);
          f_10 = Some(val);
        },
        20 => {
          let val = Box::new(HistoryEvent::read_from_in_protocol(i_prot)?);
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TransientDecisionInfo {
      scheduled_event: f_10,
      started_event: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TransientDecisionInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.scheduled_event {
      o_prot.write_field_begin(&TFieldIdentifier::new("scheduledEvent", TType::Struct, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.started_event {
      o_prot.write_field_begin(&TFieldIdentifier::new("startedEvent", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ScheduleActivityTaskDecisionAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ScheduleActivityTaskDecisionAttributes {
  pub activity_id: Option<String>,
  pub activity_type: Option<ActivityType>,
  pub domain: Option<String>,
  pub task_list: Option<TaskList>,
  pub input: Option<Vec<u8>>,
  pub schedule_to_close_timeout_seconds: Option<i32>,
  pub schedule_to_start_timeout_seconds: Option<i32>,
  pub start_to_close_timeout_seconds: Option<i32>,
  pub heartbeat_timeout_seconds: Option<i32>,
  pub retry_policy: Option<Box<RetryPolicy>>,
  pub header: Option<Header>,
  pub request_local_dispatch: Option<bool>,
}

impl ScheduleActivityTaskDecisionAttributes {
  pub fn new<F10, F20, F25, F30, F40, F45, F50, F55, F60, F70, F80, F90>(activity_id: F10, activity_type: F20, domain: F25, task_list: F30, input: F40, schedule_to_close_timeout_seconds: F45, schedule_to_start_timeout_seconds: F50, start_to_close_timeout_seconds: F55, heartbeat_timeout_seconds: F60, retry_policy: F70, header: F80, request_local_dispatch: F90) -> ScheduleActivityTaskDecisionAttributes where F10: Into<Option<String>>, F20: Into<Option<ActivityType>>, F25: Into<Option<String>>, F30: Into<Option<TaskList>>, F40: Into<Option<Vec<u8>>>, F45: Into<Option<i32>>, F50: Into<Option<i32>>, F55: Into<Option<i32>>, F60: Into<Option<i32>>, F70: Into<Option<Box<RetryPolicy>>>, F80: Into<Option<Header>>, F90: Into<Option<bool>> {
    ScheduleActivityTaskDecisionAttributes {
      activity_id: activity_id.into(),
      activity_type: activity_type.into(),
      domain: domain.into(),
      task_list: task_list.into(),
      input: input.into(),
      schedule_to_close_timeout_seconds: schedule_to_close_timeout_seconds.into(),
      schedule_to_start_timeout_seconds: schedule_to_start_timeout_seconds.into(),
      start_to_close_timeout_seconds: start_to_close_timeout_seconds.into(),
      heartbeat_timeout_seconds: heartbeat_timeout_seconds.into(),
      retry_policy: retry_policy.into(),
      header: header.into(),
      request_local_dispatch: request_local_dispatch.into(),
    }
  }
}

impl TSerializable for ScheduleActivityTaskDecisionAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ScheduleActivityTaskDecisionAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<ActivityType> = None;
    let mut f_25: Option<String> = None;
    let mut f_30: Option<TaskList> = None;
    let mut f_40: Option<Vec<u8>> = None;
    let mut f_45: Option<i32> = None;
    let mut f_50: Option<i32> = None;
    let mut f_55: Option<i32> = None;
    let mut f_60: Option<i32> = None;
    let mut f_70: Option<Box<RetryPolicy>> = None;
    let mut f_80: Option<Header> = None;
    let mut f_90: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = ActivityType::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        25 => {
          let val = i_prot.read_string()?;
          f_25 = Some(val);
        },
        30 => {
          let val = TaskList::read_from_in_protocol(i_prot)?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_bytes()?;
          f_40 = Some(val);
        },
        45 => {
          let val = i_prot.read_i32()?;
          f_45 = Some(val);
        },
        50 => {
          let val = i_prot.read_i32()?;
          f_50 = Some(val);
        },
        55 => {
          let val = i_prot.read_i32()?;
          f_55 = Some(val);
        },
        60 => {
          let val = i_prot.read_i32()?;
          f_60 = Some(val);
        },
        70 => {
          let val = Box::new(RetryPolicy::read_from_in_protocol(i_prot)?);
          f_70 = Some(val);
        },
        80 => {
          let val = Header::read_from_in_protocol(i_prot)?;
          f_80 = Some(val);
        },
        90 => {
          let val = i_prot.read_bool()?;
          f_90 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ScheduleActivityTaskDecisionAttributes {
      activity_id: f_10,
      activity_type: f_20,
      domain: f_25,
      task_list: f_30,
      input: f_40,
      schedule_to_close_timeout_seconds: f_45,
      schedule_to_start_timeout_seconds: f_50,
      start_to_close_timeout_seconds: f_55,
      heartbeat_timeout_seconds: f_60,
      retry_policy: f_70,
      header: f_80,
      request_local_dispatch: f_90,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ScheduleActivityTaskDecisionAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.activity_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("activityId", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.activity_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("activityType", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 25))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.task_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskList", TType::Struct, 30))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.input {
      o_prot.write_field_begin(&TFieldIdentifier::new("input", TType::String, 40))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.schedule_to_close_timeout_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("scheduleToCloseTimeoutSeconds", TType::I32, 45))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.schedule_to_start_timeout_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("scheduleToStartTimeoutSeconds", TType::I32, 50))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.start_to_close_timeout_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("startToCloseTimeoutSeconds", TType::I32, 55))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.heartbeat_timeout_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("heartbeatTimeoutSeconds", TType::I32, 60))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.retry_policy {
      o_prot.write_field_begin(&TFieldIdentifier::new("retryPolicy", TType::Struct, 70))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.header {
      o_prot.write_field_begin(&TFieldIdentifier::new("header", TType::Struct, 80))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.request_local_dispatch {
      o_prot.write_field_begin(&TFieldIdentifier::new("requestLocalDispatch", TType::Bool, 90))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ActivityLocalDispatchInfo
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ActivityLocalDispatchInfo {
  pub activity_id: Option<String>,
  pub scheduled_timestamp: Option<i64>,
  pub started_timestamp: Option<i64>,
  pub scheduled_timestamp_of_this_attempt: Option<i64>,
  pub task_token: Option<Vec<u8>>,
}

impl ActivityLocalDispatchInfo {
  pub fn new<F10, F20, F30, F40, F50>(activity_id: F10, scheduled_timestamp: F20, started_timestamp: F30, scheduled_timestamp_of_this_attempt: F40, task_token: F50) -> ActivityLocalDispatchInfo where F10: Into<Option<String>>, F20: Into<Option<i64>>, F30: Into<Option<i64>>, F40: Into<Option<i64>>, F50: Into<Option<Vec<u8>>> {
    ActivityLocalDispatchInfo {
      activity_id: activity_id.into(),
      scheduled_timestamp: scheduled_timestamp.into(),
      started_timestamp: started_timestamp.into(),
      scheduled_timestamp_of_this_attempt: scheduled_timestamp_of_this_attempt.into(),
      task_token: task_token.into(),
    }
  }
}

impl TSerializable for ActivityLocalDispatchInfo {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ActivityLocalDispatchInfo> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<i64> = None;
    let mut f_30: Option<i64> = None;
    let mut f_40: Option<i64> = None;
    let mut f_50: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_i64()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_i64()?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_i64()?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_bytes()?;
          f_50 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ActivityLocalDispatchInfo {
      activity_id: f_10,
      scheduled_timestamp: f_20,
      started_timestamp: f_30,
      scheduled_timestamp_of_this_attempt: f_40,
      task_token: f_50,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ActivityLocalDispatchInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.activity_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("activityId", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.scheduled_timestamp {
      o_prot.write_field_begin(&TFieldIdentifier::new("scheduledTimestamp", TType::I64, 20))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.started_timestamp {
      o_prot.write_field_begin(&TFieldIdentifier::new("startedTimestamp", TType::I64, 30))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.scheduled_timestamp_of_this_attempt {
      o_prot.write_field_begin(&TFieldIdentifier::new("scheduledTimestampOfThisAttempt", TType::I64, 40))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.task_token {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskToken", TType::String, 50))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// RequestCancelActivityTaskDecisionAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RequestCancelActivityTaskDecisionAttributes {
  pub activity_id: Option<String>,
}

impl RequestCancelActivityTaskDecisionAttributes {
  pub fn new<F10>(activity_id: F10) -> RequestCancelActivityTaskDecisionAttributes where F10: Into<Option<String>> {
    RequestCancelActivityTaskDecisionAttributes {
      activity_id: activity_id.into(),
    }
  }
}

impl TSerializable for RequestCancelActivityTaskDecisionAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RequestCancelActivityTaskDecisionAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RequestCancelActivityTaskDecisionAttributes {
      activity_id: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RequestCancelActivityTaskDecisionAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.activity_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("activityId", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// StartTimerDecisionAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct StartTimerDecisionAttributes {
  pub timer_id: Option<String>,
  pub start_to_fire_timeout_seconds: Option<i64>,
}

impl StartTimerDecisionAttributes {
  pub fn new<F10, F20>(timer_id: F10, start_to_fire_timeout_seconds: F20) -> StartTimerDecisionAttributes where F10: Into<Option<String>>, F20: Into<Option<i64>> {
    StartTimerDecisionAttributes {
      timer_id: timer_id.into(),
      start_to_fire_timeout_seconds: start_to_fire_timeout_seconds.into(),
    }
  }
}

impl TSerializable for StartTimerDecisionAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<StartTimerDecisionAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_i64()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = StartTimerDecisionAttributes {
      timer_id: f_10,
      start_to_fire_timeout_seconds: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("StartTimerDecisionAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.timer_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("timerId", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.start_to_fire_timeout_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("startToFireTimeoutSeconds", TType::I64, 20))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// CompleteWorkflowExecutionDecisionAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CompleteWorkflowExecutionDecisionAttributes {
  pub result: Option<Vec<u8>>,
}

impl CompleteWorkflowExecutionDecisionAttributes {
  pub fn new<F10>(result: F10) -> CompleteWorkflowExecutionDecisionAttributes where F10: Into<Option<Vec<u8>>> {
    CompleteWorkflowExecutionDecisionAttributes {
      result: result.into(),
    }
  }
}

impl TSerializable for CompleteWorkflowExecutionDecisionAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CompleteWorkflowExecutionDecisionAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_bytes()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CompleteWorkflowExecutionDecisionAttributes {
      result: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CompleteWorkflowExecutionDecisionAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result {
      o_prot.write_field_begin(&TFieldIdentifier::new("result", TType::String, 10))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// FailWorkflowExecutionDecisionAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct FailWorkflowExecutionDecisionAttributes {
  pub reason: Option<String>,
  pub details: Option<Vec<u8>>,
}

impl FailWorkflowExecutionDecisionAttributes {
  pub fn new<F10, F20>(reason: F10, details: F20) -> FailWorkflowExecutionDecisionAttributes where F10: Into<Option<String>>, F20: Into<Option<Vec<u8>>> {
    FailWorkflowExecutionDecisionAttributes {
      reason: reason.into(),
      details: details.into(),
    }
  }
}

impl TSerializable for FailWorkflowExecutionDecisionAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<FailWorkflowExecutionDecisionAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_bytes()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = FailWorkflowExecutionDecisionAttributes {
      reason: f_10,
      details: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("FailWorkflowExecutionDecisionAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.reason {
      o_prot.write_field_begin(&TFieldIdentifier::new("reason", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.details {
      o_prot.write_field_begin(&TFieldIdentifier::new("details", TType::String, 20))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// CancelTimerDecisionAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CancelTimerDecisionAttributes {
  pub timer_id: Option<String>,
}

impl CancelTimerDecisionAttributes {
  pub fn new<F10>(timer_id: F10) -> CancelTimerDecisionAttributes where F10: Into<Option<String>> {
    CancelTimerDecisionAttributes {
      timer_id: timer_id.into(),
    }
  }
}

impl TSerializable for CancelTimerDecisionAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CancelTimerDecisionAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CancelTimerDecisionAttributes {
      timer_id: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CancelTimerDecisionAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.timer_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("timerId", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// CancelWorkflowExecutionDecisionAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CancelWorkflowExecutionDecisionAttributes {
  pub details: Option<Vec<u8>>,
}

impl CancelWorkflowExecutionDecisionAttributes {
  pub fn new<F10>(details: F10) -> CancelWorkflowExecutionDecisionAttributes where F10: Into<Option<Vec<u8>>> {
    CancelWorkflowExecutionDecisionAttributes {
      details: details.into(),
    }
  }
}

impl TSerializable for CancelWorkflowExecutionDecisionAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CancelWorkflowExecutionDecisionAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_bytes()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CancelWorkflowExecutionDecisionAttributes {
      details: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CancelWorkflowExecutionDecisionAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.details {
      o_prot.write_field_begin(&TFieldIdentifier::new("details", TType::String, 10))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// RequestCancelExternalWorkflowExecutionDecisionAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RequestCancelExternalWorkflowExecutionDecisionAttributes {
  pub domain: Option<String>,
  pub workflow_id: Option<String>,
  pub run_id: Option<String>,
  pub control: Option<Vec<u8>>,
  pub child_workflow_only: Option<bool>,
}

impl RequestCancelExternalWorkflowExecutionDecisionAttributes {
  pub fn new<F10, F20, F30, F40, F50>(domain: F10, workflow_id: F20, run_id: F30, control: F40, child_workflow_only: F50) -> RequestCancelExternalWorkflowExecutionDecisionAttributes where F10: Into<Option<String>>, F20: Into<Option<String>>, F30: Into<Option<String>>, F40: Into<Option<Vec<u8>>>, F50: Into<Option<bool>> {
    RequestCancelExternalWorkflowExecutionDecisionAttributes {
      domain: domain.into(),
      workflow_id: workflow_id.into(),
      run_id: run_id.into(),
      control: control.into(),
      child_workflow_only: child_workflow_only.into(),
    }
  }
}

impl TSerializable for RequestCancelExternalWorkflowExecutionDecisionAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RequestCancelExternalWorkflowExecutionDecisionAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<String> = None;
    let mut f_30: Option<String> = None;
    let mut f_40: Option<Vec<u8>> = None;
    let mut f_50: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_string()?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_bytes()?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_bool()?;
          f_50 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RequestCancelExternalWorkflowExecutionDecisionAttributes {
      domain: f_10,
      workflow_id: f_20,
      run_id: f_30,
      control: f_40,
      child_workflow_only: f_50,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RequestCancelExternalWorkflowExecutionDecisionAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowId", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.run_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("runId", TType::String, 30))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.control {
      o_prot.write_field_begin(&TFieldIdentifier::new("control", TType::String, 40))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.child_workflow_only {
      o_prot.write_field_begin(&TFieldIdentifier::new("childWorkflowOnly", TType::Bool, 50))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SignalExternalWorkflowExecutionDecisionAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SignalExternalWorkflowExecutionDecisionAttributes {
  pub domain: Option<String>,
  pub execution: Option<WorkflowExecution>,
  pub signal_name: Option<String>,
  pub input: Option<Vec<u8>>,
  pub control: Option<Vec<u8>>,
  pub child_workflow_only: Option<bool>,
}

impl SignalExternalWorkflowExecutionDecisionAttributes {
  pub fn new<F10, F20, F30, F40, F50, F60>(domain: F10, execution: F20, signal_name: F30, input: F40, control: F50, child_workflow_only: F60) -> SignalExternalWorkflowExecutionDecisionAttributes where F10: Into<Option<String>>, F20: Into<Option<WorkflowExecution>>, F30: Into<Option<String>>, F40: Into<Option<Vec<u8>>>, F50: Into<Option<Vec<u8>>>, F60: Into<Option<bool>> {
    SignalExternalWorkflowExecutionDecisionAttributes {
      domain: domain.into(),
      execution: execution.into(),
      signal_name: signal_name.into(),
      input: input.into(),
      control: control.into(),
      child_workflow_only: child_workflow_only.into(),
    }
  }
}

impl TSerializable for SignalExternalWorkflowExecutionDecisionAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SignalExternalWorkflowExecutionDecisionAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<WorkflowExecution> = None;
    let mut f_30: Option<String> = None;
    let mut f_40: Option<Vec<u8>> = None;
    let mut f_50: Option<Vec<u8>> = None;
    let mut f_60: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = WorkflowExecution::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_string()?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_bytes()?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_bytes()?;
          f_50 = Some(val);
        },
        60 => {
          let val = i_prot.read_bool()?;
          f_60 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SignalExternalWorkflowExecutionDecisionAttributes {
      domain: f_10,
      execution: f_20,
      signal_name: f_30,
      input: f_40,
      control: f_50,
      child_workflow_only: f_60,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SignalExternalWorkflowExecutionDecisionAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.execution {
      o_prot.write_field_begin(&TFieldIdentifier::new("execution", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.signal_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("signalName", TType::String, 30))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.input {
      o_prot.write_field_begin(&TFieldIdentifier::new("input", TType::String, 40))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.control {
      o_prot.write_field_begin(&TFieldIdentifier::new("control", TType::String, 50))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.child_workflow_only {
      o_prot.write_field_begin(&TFieldIdentifier::new("childWorkflowOnly", TType::Bool, 60))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// UpsertWorkflowSearchAttributesDecisionAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct UpsertWorkflowSearchAttributesDecisionAttributes {
  pub search_attributes: Option<SearchAttributes>,
}

impl UpsertWorkflowSearchAttributesDecisionAttributes {
  pub fn new<F10>(search_attributes: F10) -> UpsertWorkflowSearchAttributesDecisionAttributes where F10: Into<Option<SearchAttributes>> {
    UpsertWorkflowSearchAttributesDecisionAttributes {
      search_attributes: search_attributes.into(),
    }
  }
}

impl TSerializable for UpsertWorkflowSearchAttributesDecisionAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UpsertWorkflowSearchAttributesDecisionAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<SearchAttributes> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = SearchAttributes::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = UpsertWorkflowSearchAttributesDecisionAttributes {
      search_attributes: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UpsertWorkflowSearchAttributesDecisionAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.search_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("searchAttributes", TType::Struct, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// RecordMarkerDecisionAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RecordMarkerDecisionAttributes {
  pub marker_name: Option<String>,
  pub details: Option<Vec<u8>>,
  pub header: Option<Header>,
}

impl RecordMarkerDecisionAttributes {
  pub fn new<F10, F20, F30>(marker_name: F10, details: F20, header: F30) -> RecordMarkerDecisionAttributes where F10: Into<Option<String>>, F20: Into<Option<Vec<u8>>>, F30: Into<Option<Header>> {
    RecordMarkerDecisionAttributes {
      marker_name: marker_name.into(),
      details: details.into(),
      header: header.into(),
    }
  }
}

impl TSerializable for RecordMarkerDecisionAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RecordMarkerDecisionAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<Vec<u8>> = None;
    let mut f_30: Option<Header> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_bytes()?;
          f_20 = Some(val);
        },
        30 => {
          let val = Header::read_from_in_protocol(i_prot)?;
          f_30 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RecordMarkerDecisionAttributes {
      marker_name: f_10,
      details: f_20,
      header: f_30,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RecordMarkerDecisionAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.marker_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("markerName", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.details {
      o_prot.write_field_begin(&TFieldIdentifier::new("details", TType::String, 20))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.header {
      o_prot.write_field_begin(&TFieldIdentifier::new("header", TType::Struct, 30))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ContinueAsNewWorkflowExecutionDecisionAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ContinueAsNewWorkflowExecutionDecisionAttributes {
  pub workflow_type: Option<WorkflowType>,
  pub task_list: Option<TaskList>,
  pub input: Option<Vec<u8>>,
  pub execution_start_to_close_timeout_seconds: Option<i32>,
  pub task_start_to_close_timeout_seconds: Option<i32>,
  pub backoff_start_interval_in_seconds: Option<i32>,
  pub retry_policy: Option<Box<RetryPolicy>>,
  pub initiator: Option<Box<ContinueAsNewInitiator>>,
  pub failure_reason: Option<String>,
  pub failure_details: Option<Vec<u8>>,
  pub last_completion_result: Option<Vec<u8>>,
  pub cron_schedule: Option<String>,
  pub header: Option<Header>,
  pub memo: Option<Memo>,
  pub search_attributes: Option<SearchAttributes>,
  pub jitter_start_seconds: Option<i32>,
  pub cron_overlap_policy: Option<CronOverlapPolicy>,
  pub active_cluster_selection_policy: Option<Box<ActiveClusterSelectionPolicy>>,
}

impl ContinueAsNewWorkflowExecutionDecisionAttributes {
  pub fn new<F10, F20, F30, F40, F50, F60, F70, F80, F90, F100, F110, F120, F130, F140, F150, F160, F170, F180>(workflow_type: F10, task_list: F20, input: F30, execution_start_to_close_timeout_seconds: F40, task_start_to_close_timeout_seconds: F50, backoff_start_interval_in_seconds: F60, retry_policy: F70, initiator: F80, failure_reason: F90, failure_details: F100, last_completion_result: F110, cron_schedule: F120, header: F130, memo: F140, search_attributes: F150, jitter_start_seconds: F160, cron_overlap_policy: F170, active_cluster_selection_policy: F180) -> ContinueAsNewWorkflowExecutionDecisionAttributes where F10: Into<Option<WorkflowType>>, F20: Into<Option<TaskList>>, F30: Into<Option<Vec<u8>>>, F40: Into<Option<i32>>, F50: Into<Option<i32>>, F60: Into<Option<i32>>, F70: Into<Option<Box<RetryPolicy>>>, F80: Into<Option<Box<ContinueAsNewInitiator>>>, F90: Into<Option<String>>, F100: Into<Option<Vec<u8>>>, F110: Into<Option<Vec<u8>>>, F120: Into<Option<String>>, F130: Into<Option<Header>>, F140: Into<Option<Memo>>, F150: Into<Option<SearchAttributes>>, F160: Into<Option<i32>>, F170: Into<Option<CronOverlapPolicy>>, F180: Into<Option<Box<ActiveClusterSelectionPolicy>>> {
    ContinueAsNewWorkflowExecutionDecisionAttributes {
      workflow_type: workflow_type.into(),
      task_list: task_list.into(),
      input: input.into(),
      execution_start_to_close_timeout_seconds: execution_start_to_close_timeout_seconds.into(),
      task_start_to_close_timeout_seconds: task_start_to_close_timeout_seconds.into(),
      backoff_start_interval_in_seconds: backoff_start_interval_in_seconds.into(),
      retry_policy: retry_policy.into(),
      initiator: initiator.into(),
      failure_reason: failure_reason.into(),
      failure_details: failure_details.into(),
      last_completion_result: last_completion_result.into(),
      cron_schedule: cron_schedule.into(),
      header: header.into(),
      memo: memo.into(),
      search_attributes: search_attributes.into(),
      jitter_start_seconds: jitter_start_seconds.into(),
      cron_overlap_policy: cron_overlap_policy.into(),
      active_cluster_selection_policy: active_cluster_selection_policy.into(),
    }
  }
}

impl TSerializable for ContinueAsNewWorkflowExecutionDecisionAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ContinueAsNewWorkflowExecutionDecisionAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<WorkflowType> = None;
    let mut f_20: Option<TaskList> = None;
    let mut f_30: Option<Vec<u8>> = None;
    let mut f_40: Option<i32> = None;
    let mut f_50: Option<i32> = None;
    let mut f_60: Option<i32> = None;
    let mut f_70: Option<Box<RetryPolicy>> = None;
    let mut f_80: Option<Box<ContinueAsNewInitiator>> = None;
    let mut f_90: Option<String> = None;
    let mut f_100: Option<Vec<u8>> = None;
    let mut f_110: Option<Vec<u8>> = None;
    let mut f_120: Option<String> = None;
    let mut f_130: Option<Header> = None;
    let mut f_140: Option<Memo> = None;
    let mut f_150: Option<SearchAttributes> = None;
    let mut f_160: Option<i32> = None;
    let mut f_170: Option<CronOverlapPolicy> = None;
    let mut f_180: Option<Box<ActiveClusterSelectionPolicy>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = WorkflowType::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        20 => {
          let val = TaskList::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_bytes()?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_i32()?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_i32()?;
          f_50 = Some(val);
        },
        60 => {
          let val = i_prot.read_i32()?;
          f_60 = Some(val);
        },
        70 => {
          let val = Box::new(RetryPolicy::read_from_in_protocol(i_prot)?);
          f_70 = Some(val);
        },
        80 => {
          let val = Box::new(ContinueAsNewInitiator::read_from_in_protocol(i_prot)?);
          f_80 = Some(val);
        },
        90 => {
          let val = i_prot.read_string()?;
          f_90 = Some(val);
        },
        100 => {
          let val = i_prot.read_bytes()?;
          f_100 = Some(val);
        },
        110 => {
          let val = i_prot.read_bytes()?;
          f_110 = Some(val);
        },
        120 => {
          let val = i_prot.read_string()?;
          f_120 = Some(val);
        },
        130 => {
          let val = Header::read_from_in_protocol(i_prot)?;
          f_130 = Some(val);
        },
        140 => {
          let val = Memo::read_from_in_protocol(i_prot)?;
          f_140 = Some(val);
        },
        150 => {
          let val = SearchAttributes::read_from_in_protocol(i_prot)?;
          f_150 = Some(val);
        },
        160 => {
          let val = i_prot.read_i32()?;
          f_160 = Some(val);
        },
        170 => {
          let val = CronOverlapPolicy::read_from_in_protocol(i_prot)?;
          f_170 = Some(val);
        },
        180 => {
          let val = Box::new(ActiveClusterSelectionPolicy::read_from_in_protocol(i_prot)?);
          f_180 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ContinueAsNewWorkflowExecutionDecisionAttributes {
      workflow_type: f_10,
      task_list: f_20,
      input: f_30,
      execution_start_to_close_timeout_seconds: f_40,
      task_start_to_close_timeout_seconds: f_50,
      backoff_start_interval_in_seconds: f_60,
      retry_policy: f_70,
      initiator: f_80,
      failure_reason: f_90,
      failure_details: f_100,
      last_completion_result: f_110,
      cron_schedule: f_120,
      header: f_130,
      memo: f_140,
      search_attributes: f_150,
      jitter_start_seconds: f_160,
      cron_overlap_policy: f_170,
      active_cluster_selection_policy: f_180,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ContinueAsNewWorkflowExecutionDecisionAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.workflow_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowType", TType::Struct, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.task_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskList", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.input {
      o_prot.write_field_begin(&TFieldIdentifier::new("input", TType::String, 30))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.execution_start_to_close_timeout_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("executionStartToCloseTimeoutSeconds", TType::I32, 40))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.task_start_to_close_timeout_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskStartToCloseTimeoutSeconds", TType::I32, 50))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.backoff_start_interval_in_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("backoffStartIntervalInSeconds", TType::I32, 60))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.retry_policy {
      o_prot.write_field_begin(&TFieldIdentifier::new("retryPolicy", TType::Struct, 70))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.initiator {
      o_prot.write_field_begin(&TFieldIdentifier::new("initiator", TType::I32, 80))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.failure_reason {
      o_prot.write_field_begin(&TFieldIdentifier::new("failureReason", TType::String, 90))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.failure_details {
      o_prot.write_field_begin(&TFieldIdentifier::new("failureDetails", TType::String, 100))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.last_completion_result {
      o_prot.write_field_begin(&TFieldIdentifier::new("lastCompletionResult", TType::String, 110))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cron_schedule {
      o_prot.write_field_begin(&TFieldIdentifier::new("cronSchedule", TType::String, 120))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.header {
      o_prot.write_field_begin(&TFieldIdentifier::new("header", TType::Struct, 130))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.memo {
      o_prot.write_field_begin(&TFieldIdentifier::new("memo", TType::Struct, 140))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.search_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("searchAttributes", TType::Struct, 150))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.jitter_start_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("jitterStartSeconds", TType::I32, 160))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cron_overlap_policy {
      o_prot.write_field_begin(&TFieldIdentifier::new("cronOverlapPolicy", TType::I32, 170))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.active_cluster_selection_policy {
      o_prot.write_field_begin(&TFieldIdentifier::new("activeClusterSelectionPolicy", TType::Struct, 180))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// StartChildWorkflowExecutionDecisionAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct StartChildWorkflowExecutionDecisionAttributes {
  pub domain: Option<String>,
  pub workflow_id: Option<String>,
  pub workflow_type: Option<WorkflowType>,
  pub task_list: Option<TaskList>,
  pub input: Option<Vec<u8>>,
  pub execution_start_to_close_timeout_seconds: Option<i32>,
  pub task_start_to_close_timeout_seconds: Option<i32>,
  pub parent_close_policy: Option<ParentClosePolicy>,
  pub control: Option<Vec<u8>>,
  pub workflow_id_reuse_policy: Option<WorkflowIdReusePolicy>,
  pub retry_policy: Option<Box<RetryPolicy>>,
  pub cron_schedule: Option<String>,
  pub header: Option<Header>,
  pub memo: Option<Memo>,
  pub search_attributes: Option<SearchAttributes>,
  pub cron_overlap_policy: Option<CronOverlapPolicy>,
  pub active_cluster_selection_policy: Option<Box<ActiveClusterSelectionPolicy>>,
}

impl StartChildWorkflowExecutionDecisionAttributes {
  pub fn new<F10, F20, F30, F40, F50, F60, F70, F81, F90, F100, F110, F120, F130, F140, F150, F160, F170>(domain: F10, workflow_id: F20, workflow_type: F30, task_list: F40, input: F50, execution_start_to_close_timeout_seconds: F60, task_start_to_close_timeout_seconds: F70, parent_close_policy: F81, control: F90, workflow_id_reuse_policy: F100, retry_policy: F110, cron_schedule: F120, header: F130, memo: F140, search_attributes: F150, cron_overlap_policy: F160, active_cluster_selection_policy: F170) -> StartChildWorkflowExecutionDecisionAttributes where F10: Into<Option<String>>, F20: Into<Option<String>>, F30: Into<Option<WorkflowType>>, F40: Into<Option<TaskList>>, F50: Into<Option<Vec<u8>>>, F60: Into<Option<i32>>, F70: Into<Option<i32>>, F81: Into<Option<ParentClosePolicy>>, F90: Into<Option<Vec<u8>>>, F100: Into<Option<WorkflowIdReusePolicy>>, F110: Into<Option<Box<RetryPolicy>>>, F120: Into<Option<String>>, F130: Into<Option<Header>>, F140: Into<Option<Memo>>, F150: Into<Option<SearchAttributes>>, F160: Into<Option<CronOverlapPolicy>>, F170: Into<Option<Box<ActiveClusterSelectionPolicy>>> {
    StartChildWorkflowExecutionDecisionAttributes {
      domain: domain.into(),
      workflow_id: workflow_id.into(),
      workflow_type: workflow_type.into(),
      task_list: task_list.into(),
      input: input.into(),
      execution_start_to_close_timeout_seconds: execution_start_to_close_timeout_seconds.into(),
      task_start_to_close_timeout_seconds: task_start_to_close_timeout_seconds.into(),
      parent_close_policy: parent_close_policy.into(),
      control: control.into(),
      workflow_id_reuse_policy: workflow_id_reuse_policy.into(),
      retry_policy: retry_policy.into(),
      cron_schedule: cron_schedule.into(),
      header: header.into(),
      memo: memo.into(),
      search_attributes: search_attributes.into(),
      cron_overlap_policy: cron_overlap_policy.into(),
      active_cluster_selection_policy: active_cluster_selection_policy.into(),
    }
  }
}

impl TSerializable for StartChildWorkflowExecutionDecisionAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<StartChildWorkflowExecutionDecisionAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<String> = None;
    let mut f_30: Option<WorkflowType> = None;
    let mut f_40: Option<TaskList> = None;
    let mut f_50: Option<Vec<u8>> = None;
    let mut f_60: Option<i32> = None;
    let mut f_70: Option<i32> = None;
    let mut f_81: Option<ParentClosePolicy> = None;
    let mut f_90: Option<Vec<u8>> = None;
    let mut f_100: Option<WorkflowIdReusePolicy> = None;
    let mut f_110: Option<Box<RetryPolicy>> = None;
    let mut f_120: Option<String> = None;
    let mut f_130: Option<Header> = None;
    let mut f_140: Option<Memo> = None;
    let mut f_150: Option<SearchAttributes> = None;
    let mut f_160: Option<CronOverlapPolicy> = None;
    let mut f_170: Option<Box<ActiveClusterSelectionPolicy>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        30 => {
          let val = WorkflowType::read_from_in_protocol(i_prot)?;
          f_30 = Some(val);
        },
        40 => {
          let val = TaskList::read_from_in_protocol(i_prot)?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_bytes()?;
          f_50 = Some(val);
        },
        60 => {
          let val = i_prot.read_i32()?;
          f_60 = Some(val);
        },
        70 => {
          let val = i_prot.read_i32()?;
          f_70 = Some(val);
        },
        81 => {
          let val = ParentClosePolicy::read_from_in_protocol(i_prot)?;
          f_81 = Some(val);
        },
        90 => {
          let val = i_prot.read_bytes()?;
          f_90 = Some(val);
        },
        100 => {
          let val = WorkflowIdReusePolicy::read_from_in_protocol(i_prot)?;
          f_100 = Some(val);
        },
        110 => {
          let val = Box::new(RetryPolicy::read_from_in_protocol(i_prot)?);
          f_110 = Some(val);
        },
        120 => {
          let val = i_prot.read_string()?;
          f_120 = Some(val);
        },
        130 => {
          let val = Header::read_from_in_protocol(i_prot)?;
          f_130 = Some(val);
        },
        140 => {
          let val = Memo::read_from_in_protocol(i_prot)?;
          f_140 = Some(val);
        },
        150 => {
          let val = SearchAttributes::read_from_in_protocol(i_prot)?;
          f_150 = Some(val);
        },
        160 => {
          let val = CronOverlapPolicy::read_from_in_protocol(i_prot)?;
          f_160 = Some(val);
        },
        170 => {
          let val = Box::new(ActiveClusterSelectionPolicy::read_from_in_protocol(i_prot)?);
          f_170 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = StartChildWorkflowExecutionDecisionAttributes {
      domain: f_10,
      workflow_id: f_20,
      workflow_type: f_30,
      task_list: f_40,
      input: f_50,
      execution_start_to_close_timeout_seconds: f_60,
      task_start_to_close_timeout_seconds: f_70,
      parent_close_policy: f_81,
      control: f_90,
      workflow_id_reuse_policy: f_100,
      retry_policy: f_110,
      cron_schedule: f_120,
      header: f_130,
      memo: f_140,
      search_attributes: f_150,
      cron_overlap_policy: f_160,
      active_cluster_selection_policy: f_170,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("StartChildWorkflowExecutionDecisionAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowId", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowType", TType::Struct, 30))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.task_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskList", TType::Struct, 40))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.input {
      o_prot.write_field_begin(&TFieldIdentifier::new("input", TType::String, 50))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.execution_start_to_close_timeout_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("executionStartToCloseTimeoutSeconds", TType::I32, 60))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.task_start_to_close_timeout_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskStartToCloseTimeoutSeconds", TType::I32, 70))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.parent_close_policy {
      o_prot.write_field_begin(&TFieldIdentifier::new("parentClosePolicy", TType::I32, 81))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.control {
      o_prot.write_field_begin(&TFieldIdentifier::new("control", TType::String, 90))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_id_reuse_policy {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowIdReusePolicy", TType::I32, 100))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.retry_policy {
      o_prot.write_field_begin(&TFieldIdentifier::new("retryPolicy", TType::Struct, 110))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cron_schedule {
      o_prot.write_field_begin(&TFieldIdentifier::new("cronSchedule", TType::String, 120))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.header {
      o_prot.write_field_begin(&TFieldIdentifier::new("header", TType::Struct, 130))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.memo {
      o_prot.write_field_begin(&TFieldIdentifier::new("memo", TType::Struct, 140))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.search_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("searchAttributes", TType::Struct, 150))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cron_overlap_policy {
      o_prot.write_field_begin(&TFieldIdentifier::new("cronOverlapPolicy", TType::I32, 160))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.active_cluster_selection_policy {
      o_prot.write_field_begin(&TFieldIdentifier::new("activeClusterSelectionPolicy", TType::Struct, 170))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// Decision
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Decision {
  pub decision_type: Option<DecisionType>,
  pub schedule_activity_task_decision_attributes: Option<ScheduleActivityTaskDecisionAttributes>,
  pub start_timer_decision_attributes: Option<StartTimerDecisionAttributes>,
  pub complete_workflow_execution_decision_attributes: Option<CompleteWorkflowExecutionDecisionAttributes>,
  pub fail_workflow_execution_decision_attributes: Option<FailWorkflowExecutionDecisionAttributes>,
  pub request_cancel_activity_task_decision_attributes: Option<RequestCancelActivityTaskDecisionAttributes>,
  pub cancel_timer_decision_attributes: Option<CancelTimerDecisionAttributes>,
  pub cancel_workflow_execution_decision_attributes: Option<CancelWorkflowExecutionDecisionAttributes>,
  pub request_cancel_external_workflow_execution_decision_attributes: Option<RequestCancelExternalWorkflowExecutionDecisionAttributes>,
  pub record_marker_decision_attributes: Option<RecordMarkerDecisionAttributes>,
  pub continue_as_new_workflow_execution_decision_attributes: Option<ContinueAsNewWorkflowExecutionDecisionAttributes>,
  pub start_child_workflow_execution_decision_attributes: Option<StartChildWorkflowExecutionDecisionAttributes>,
  pub signal_external_workflow_execution_decision_attributes: Option<SignalExternalWorkflowExecutionDecisionAttributes>,
  pub upsert_workflow_search_attributes_decision_attributes: Option<UpsertWorkflowSearchAttributesDecisionAttributes>,
}

impl Decision {
  pub fn new<F10, F20, F25, F30, F35, F40, F50, F60, F70, F80, F90, F100, F110, F120>(decision_type: F10, schedule_activity_task_decision_attributes: F20, start_timer_decision_attributes: F25, complete_workflow_execution_decision_attributes: F30, fail_workflow_execution_decision_attributes: F35, request_cancel_activity_task_decision_attributes: F40, cancel_timer_decision_attributes: F50, cancel_workflow_execution_decision_attributes: F60, request_cancel_external_workflow_execution_decision_attributes: F70, record_marker_decision_attributes: F80, continue_as_new_workflow_execution_decision_attributes: F90, start_child_workflow_execution_decision_attributes: F100, signal_external_workflow_execution_decision_attributes: F110, upsert_workflow_search_attributes_decision_attributes: F120) -> Decision where F10: Into<Option<DecisionType>>, F20: Into<Option<ScheduleActivityTaskDecisionAttributes>>, F25: Into<Option<StartTimerDecisionAttributes>>, F30: Into<Option<CompleteWorkflowExecutionDecisionAttributes>>, F35: Into<Option<FailWorkflowExecutionDecisionAttributes>>, F40: Into<Option<RequestCancelActivityTaskDecisionAttributes>>, F50: Into<Option<CancelTimerDecisionAttributes>>, F60: Into<Option<CancelWorkflowExecutionDecisionAttributes>>, F70: Into<Option<RequestCancelExternalWorkflowExecutionDecisionAttributes>>, F80: Into<Option<RecordMarkerDecisionAttributes>>, F90: Into<Option<ContinueAsNewWorkflowExecutionDecisionAttributes>>, F100: Into<Option<StartChildWorkflowExecutionDecisionAttributes>>, F110: Into<Option<SignalExternalWorkflowExecutionDecisionAttributes>>, F120: Into<Option<UpsertWorkflowSearchAttributesDecisionAttributes>> {
    Decision {
      decision_type: decision_type.into(),
      schedule_activity_task_decision_attributes: schedule_activity_task_decision_attributes.into(),
      start_timer_decision_attributes: start_timer_decision_attributes.into(),
      complete_workflow_execution_decision_attributes: complete_workflow_execution_decision_attributes.into(),
      fail_workflow_execution_decision_attributes: fail_workflow_execution_decision_attributes.into(),
      request_cancel_activity_task_decision_attributes: request_cancel_activity_task_decision_attributes.into(),
      cancel_timer_decision_attributes: cancel_timer_decision_attributes.into(),
      cancel_workflow_execution_decision_attributes: cancel_workflow_execution_decision_attributes.into(),
      request_cancel_external_workflow_execution_decision_attributes: request_cancel_external_workflow_execution_decision_attributes.into(),
      record_marker_decision_attributes: record_marker_decision_attributes.into(),
      continue_as_new_workflow_execution_decision_attributes: continue_as_new_workflow_execution_decision_attributes.into(),
      start_child_workflow_execution_decision_attributes: start_child_workflow_execution_decision_attributes.into(),
      signal_external_workflow_execution_decision_attributes: signal_external_workflow_execution_decision_attributes.into(),
      upsert_workflow_search_attributes_decision_attributes: upsert_workflow_search_attributes_decision_attributes.into(),
    }
  }
}

impl TSerializable for Decision {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Decision> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<DecisionType> = None;
    let mut f_20: Option<ScheduleActivityTaskDecisionAttributes> = None;
    let mut f_25: Option<StartTimerDecisionAttributes> = None;
    let mut f_30: Option<CompleteWorkflowExecutionDecisionAttributes> = None;
    let mut f_35: Option<FailWorkflowExecutionDecisionAttributes> = None;
    let mut f_40: Option<RequestCancelActivityTaskDecisionAttributes> = None;
    let mut f_50: Option<CancelTimerDecisionAttributes> = None;
    let mut f_60: Option<CancelWorkflowExecutionDecisionAttributes> = None;
    let mut f_70: Option<RequestCancelExternalWorkflowExecutionDecisionAttributes> = None;
    let mut f_80: Option<RecordMarkerDecisionAttributes> = None;
    let mut f_90: Option<ContinueAsNewWorkflowExecutionDecisionAttributes> = None;
    let mut f_100: Option<StartChildWorkflowExecutionDecisionAttributes> = None;
    let mut f_110: Option<SignalExternalWorkflowExecutionDecisionAttributes> = None;
    let mut f_120: Option<UpsertWorkflowSearchAttributesDecisionAttributes> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = DecisionType::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        20 => {
          let val = ScheduleActivityTaskDecisionAttributes::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        25 => {
          let val = StartTimerDecisionAttributes::read_from_in_protocol(i_prot)?;
          f_25 = Some(val);
        },
        30 => {
          let val = CompleteWorkflowExecutionDecisionAttributes::read_from_in_protocol(i_prot)?;
          f_30 = Some(val);
        },
        35 => {
          let val = FailWorkflowExecutionDecisionAttributes::read_from_in_protocol(i_prot)?;
          f_35 = Some(val);
        },
        40 => {
          let val = RequestCancelActivityTaskDecisionAttributes::read_from_in_protocol(i_prot)?;
          f_40 = Some(val);
        },
        50 => {
          let val = CancelTimerDecisionAttributes::read_from_in_protocol(i_prot)?;
          f_50 = Some(val);
        },
        60 => {
          let val = CancelWorkflowExecutionDecisionAttributes::read_from_in_protocol(i_prot)?;
          f_60 = Some(val);
        },
        70 => {
          let val = RequestCancelExternalWorkflowExecutionDecisionAttributes::read_from_in_protocol(i_prot)?;
          f_70 = Some(val);
        },
        80 => {
          let val = RecordMarkerDecisionAttributes::read_from_in_protocol(i_prot)?;
          f_80 = Some(val);
        },
        90 => {
          let val = ContinueAsNewWorkflowExecutionDecisionAttributes::read_from_in_protocol(i_prot)?;
          f_90 = Some(val);
        },
        100 => {
          let val = StartChildWorkflowExecutionDecisionAttributes::read_from_in_protocol(i_prot)?;
          f_100 = Some(val);
        },
        110 => {
          let val = SignalExternalWorkflowExecutionDecisionAttributes::read_from_in_protocol(i_prot)?;
          f_110 = Some(val);
        },
        120 => {
          let val = UpsertWorkflowSearchAttributesDecisionAttributes::read_from_in_protocol(i_prot)?;
          f_120 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Decision {
      decision_type: f_10,
      schedule_activity_task_decision_attributes: f_20,
      start_timer_decision_attributes: f_25,
      complete_workflow_execution_decision_attributes: f_30,
      fail_workflow_execution_decision_attributes: f_35,
      request_cancel_activity_task_decision_attributes: f_40,
      cancel_timer_decision_attributes: f_50,
      cancel_workflow_execution_decision_attributes: f_60,
      request_cancel_external_workflow_execution_decision_attributes: f_70,
      record_marker_decision_attributes: f_80,
      continue_as_new_workflow_execution_decision_attributes: f_90,
      start_child_workflow_execution_decision_attributes: f_100,
      signal_external_workflow_execution_decision_attributes: f_110,
      upsert_workflow_search_attributes_decision_attributes: f_120,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Decision");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.decision_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("decisionType", TType::I32, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.schedule_activity_task_decision_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("scheduleActivityTaskDecisionAttributes", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.start_timer_decision_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("startTimerDecisionAttributes", TType::Struct, 25))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.complete_workflow_execution_decision_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("completeWorkflowExecutionDecisionAttributes", TType::Struct, 30))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.fail_workflow_execution_decision_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("failWorkflowExecutionDecisionAttributes", TType::Struct, 35))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.request_cancel_activity_task_decision_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("requestCancelActivityTaskDecisionAttributes", TType::Struct, 40))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cancel_timer_decision_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("cancelTimerDecisionAttributes", TType::Struct, 50))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cancel_workflow_execution_decision_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("cancelWorkflowExecutionDecisionAttributes", TType::Struct, 60))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.request_cancel_external_workflow_execution_decision_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("requestCancelExternalWorkflowExecutionDecisionAttributes", TType::Struct, 70))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.record_marker_decision_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("recordMarkerDecisionAttributes", TType::Struct, 80))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.continue_as_new_workflow_execution_decision_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("continueAsNewWorkflowExecutionDecisionAttributes", TType::Struct, 90))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.start_child_workflow_execution_decision_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("startChildWorkflowExecutionDecisionAttributes", TType::Struct, 100))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.signal_external_workflow_execution_decision_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("signalExternalWorkflowExecutionDecisionAttributes", TType::Struct, 110))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.upsert_workflow_search_attributes_decision_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("upsertWorkflowSearchAttributesDecisionAttributes", TType::Struct, 120))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowExecutionStartedEventAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WorkflowExecutionStartedEventAttributes {
  pub workflow_type: Option<WorkflowType>,
  pub parent_workflow_domain: Option<String>,
  pub parent_workflow_execution: Option<WorkflowExecution>,
  pub parent_initiated_event_id: Option<i64>,
  pub task_list: Option<TaskList>,
  pub input: Option<Vec<u8>>,
  pub execution_start_to_close_timeout_seconds: Option<i32>,
  pub task_start_to_close_timeout_seconds: Option<i32>,
  pub continued_execution_run_id: Option<String>,
  pub initiator: Option<Box<ContinueAsNewInitiator>>,
  pub continued_failure_reason: Option<String>,
  pub continued_failure_details: Option<Vec<u8>>,
  pub last_completion_result: Option<Vec<u8>>,
  pub original_execution_run_id: Option<String>,
  pub identity: Option<String>,
  pub first_execution_run_id: Option<String>,
  pub first_scheduled_time_nano: Option<i64>,
  pub retry_policy: Option<Box<RetryPolicy>>,
  pub attempt: Option<i32>,
  pub expiration_timestamp: Option<i64>,
  pub cron_schedule: Option<String>,
  pub first_decision_task_backoff_seconds: Option<i32>,
  pub memo: Option<Memo>,
  pub search_attributes: Option<SearchAttributes>,
  pub prev_auto_reset_points: Option<Box<ResetPoints>>,
  pub header: Option<Header>,
  pub partition_config: Option<BTreeMap<String, String>>,
  pub request_id: Option<String>,
  pub cron_overlap_policy: Option<CronOverlapPolicy>,
  pub active_cluster_selection_policy: Option<Box<ActiveClusterSelectionPolicy>>,
}

impl WorkflowExecutionStartedEventAttributes {
  pub fn new<F10, F12, F14, F16, F20, F30, F40, F50, F54, F55, F56, F57, F58, F59, F60, F61, F62, F70, F80, F90, F100, F110, F120, F121, F130, F140, F150, F160, F170, F180>(workflow_type: F10, parent_workflow_domain: F12, parent_workflow_execution: F14, parent_initiated_event_id: F16, task_list: F20, input: F30, execution_start_to_close_timeout_seconds: F40, task_start_to_close_timeout_seconds: F50, continued_execution_run_id: F54, initiator: F55, continued_failure_reason: F56, continued_failure_details: F57, last_completion_result: F58, original_execution_run_id: F59, identity: F60, first_execution_run_id: F61, first_scheduled_time_nano: F62, retry_policy: F70, attempt: F80, expiration_timestamp: F90, cron_schedule: F100, first_decision_task_backoff_seconds: F110, memo: F120, search_attributes: F121, prev_auto_reset_points: F130, header: F140, partition_config: F150, request_id: F160, cron_overlap_policy: F170, active_cluster_selection_policy: F180) -> WorkflowExecutionStartedEventAttributes where F10: Into<Option<WorkflowType>>, F12: Into<Option<String>>, F14: Into<Option<WorkflowExecution>>, F16: Into<Option<i64>>, F20: Into<Option<TaskList>>, F30: Into<Option<Vec<u8>>>, F40: Into<Option<i32>>, F50: Into<Option<i32>>, F54: Into<Option<String>>, F55: Into<Option<Box<ContinueAsNewInitiator>>>, F56: Into<Option<String>>, F57: Into<Option<Vec<u8>>>, F58: Into<Option<Vec<u8>>>, F59: Into<Option<String>>, F60: Into<Option<String>>, F61: Into<Option<String>>, F62: Into<Option<i64>>, F70: Into<Option<Box<RetryPolicy>>>, F80: Into<Option<i32>>, F90: Into<Option<i64>>, F100: Into<Option<String>>, F110: Into<Option<i32>>, F120: Into<Option<Memo>>, F121: Into<Option<SearchAttributes>>, F130: Into<Option<Box<ResetPoints>>>, F140: Into<Option<Header>>, F150: Into<Option<BTreeMap<String, String>>>, F160: Into<Option<String>>, F170: Into<Option<CronOverlapPolicy>>, F180: Into<Option<Box<ActiveClusterSelectionPolicy>>> {
    WorkflowExecutionStartedEventAttributes {
      workflow_type: workflow_type.into(),
      parent_workflow_domain: parent_workflow_domain.into(),
      parent_workflow_execution: parent_workflow_execution.into(),
      parent_initiated_event_id: parent_initiated_event_id.into(),
      task_list: task_list.into(),
      input: input.into(),
      execution_start_to_close_timeout_seconds: execution_start_to_close_timeout_seconds.into(),
      task_start_to_close_timeout_seconds: task_start_to_close_timeout_seconds.into(),
      continued_execution_run_id: continued_execution_run_id.into(),
      initiator: initiator.into(),
      continued_failure_reason: continued_failure_reason.into(),
      continued_failure_details: continued_failure_details.into(),
      last_completion_result: last_completion_result.into(),
      original_execution_run_id: original_execution_run_id.into(),
      identity: identity.into(),
      first_execution_run_id: first_execution_run_id.into(),
      first_scheduled_time_nano: first_scheduled_time_nano.into(),
      retry_policy: retry_policy.into(),
      attempt: attempt.into(),
      expiration_timestamp: expiration_timestamp.into(),
      cron_schedule: cron_schedule.into(),
      first_decision_task_backoff_seconds: first_decision_task_backoff_seconds.into(),
      memo: memo.into(),
      search_attributes: search_attributes.into(),
      prev_auto_reset_points: prev_auto_reset_points.into(),
      header: header.into(),
      partition_config: partition_config.into(),
      request_id: request_id.into(),
      cron_overlap_policy: cron_overlap_policy.into(),
      active_cluster_selection_policy: active_cluster_selection_policy.into(),
    }
  }
}

impl TSerializable for WorkflowExecutionStartedEventAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowExecutionStartedEventAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<WorkflowType> = None;
    let mut f_12: Option<String> = None;
    let mut f_14: Option<WorkflowExecution> = None;
    let mut f_16: Option<i64> = None;
    let mut f_20: Option<TaskList> = None;
    let mut f_30: Option<Vec<u8>> = None;
    let mut f_40: Option<i32> = None;
    let mut f_50: Option<i32> = None;
    let mut f_54: Option<String> = None;
    let mut f_55: Option<Box<ContinueAsNewInitiator>> = None;
    let mut f_56: Option<String> = None;
    let mut f_57: Option<Vec<u8>> = None;
    let mut f_58: Option<Vec<u8>> = None;
    let mut f_59: Option<String> = None;
    let mut f_60: Option<String> = None;
    let mut f_61: Option<String> = None;
    let mut f_62: Option<i64> = None;
    let mut f_70: Option<Box<RetryPolicy>> = None;
    let mut f_80: Option<i32> = None;
    let mut f_90: Option<i64> = None;
    let mut f_100: Option<String> = None;
    let mut f_110: Option<i32> = None;
    let mut f_120: Option<Memo> = None;
    let mut f_121: Option<SearchAttributes> = None;
    let mut f_130: Option<Box<ResetPoints>> = None;
    let mut f_140: Option<Header> = None;
    let mut f_150: Option<BTreeMap<String, String>> = None;
    let mut f_160: Option<String> = None;
    let mut f_170: Option<CronOverlapPolicy> = None;
    let mut f_180: Option<Box<ActiveClusterSelectionPolicy>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = WorkflowType::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        12 => {
          let val = i_prot.read_string()?;
          f_12 = Some(val);
        },
        14 => {
          let val = WorkflowExecution::read_from_in_protocol(i_prot)?;
          f_14 = Some(val);
        },
        16 => {
          let val = i_prot.read_i64()?;
          f_16 = Some(val);
        },
        20 => {
          let val = TaskList::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_bytes()?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_i32()?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_i32()?;
          f_50 = Some(val);
        },
        54 => {
          let val = i_prot.read_string()?;
          f_54 = Some(val);
        },
        55 => {
          let val = Box::new(ContinueAsNewInitiator::read_from_in_protocol(i_prot)?);
          f_55 = Some(val);
        },
        56 => {
          let val = i_prot.read_string()?;
          f_56 = Some(val);
        },
        57 => {
          let val = i_prot.read_bytes()?;
          f_57 = Some(val);
        },
        58 => {
          let val = i_prot.read_bytes()?;
          f_58 = Some(val);
        },
        59 => {
          let val = i_prot.read_string()?;
          f_59 = Some(val);
        },
        60 => {
          let val = i_prot.read_string()?;
          f_60 = Some(val);
        },
        61 => {
          let val = i_prot.read_string()?;
          f_61 = Some(val);
        },
        62 => {
          let val = i_prot.read_i64()?;
          f_62 = Some(val);
        },
        70 => {
          let val = Box::new(RetryPolicy::read_from_in_protocol(i_prot)?);
          f_70 = Some(val);
        },
        80 => {
          let val = i_prot.read_i32()?;
          f_80 = Some(val);
        },
        90 => {
          let val = i_prot.read_i64()?;
          f_90 = Some(val);
        },
        100 => {
          let val = i_prot.read_string()?;
          f_100 = Some(val);
        },
        110 => {
          let val = i_prot.read_i32()?;
          f_110 = Some(val);
        },
        120 => {
          let val = Memo::read_from_in_protocol(i_prot)?;
          f_120 = Some(val);
        },
        121 => {
          let val = SearchAttributes::read_from_in_protocol(i_prot)?;
          f_121 = Some(val);
        },
        130 => {
          let val = Box::new(ResetPoints::read_from_in_protocol(i_prot)?);
          f_130 = Some(val);
        },
        140 => {
          let val = Header::read_from_in_protocol(i_prot)?;
          f_140 = Some(val);
        },
        150 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_10 = i_prot.read_string()?;
            let map_val_11 = i_prot.read_string()?;
            val.insert(map_key_10, map_val_11);
          }
          i_prot.read_map_end()?;
          f_150 = Some(val);
        },
        160 => {
          let val = i_prot.read_string()?;
          f_160 = Some(val);
        },
        170 => {
          let val = CronOverlapPolicy::read_from_in_protocol(i_prot)?;
          f_170 = Some(val);
        },
        180 => {
          let val = Box::new(ActiveClusterSelectionPolicy::read_from_in_protocol(i_prot)?);
          f_180 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowExecutionStartedEventAttributes {
      workflow_type: f_10,
      parent_workflow_domain: f_12,
      parent_workflow_execution: f_14,
      parent_initiated_event_id: f_16,
      task_list: f_20,
      input: f_30,
      execution_start_to_close_timeout_seconds: f_40,
      task_start_to_close_timeout_seconds: f_50,
      continued_execution_run_id: f_54,
      initiator: f_55,
      continued_failure_reason: f_56,
      continued_failure_details: f_57,
      last_completion_result: f_58,
      original_execution_run_id: f_59,
      identity: f_60,
      first_execution_run_id: f_61,
      first_scheduled_time_nano: f_62,
      retry_policy: f_70,
      attempt: f_80,
      expiration_timestamp: f_90,
      cron_schedule: f_100,
      first_decision_task_backoff_seconds: f_110,
      memo: f_120,
      search_attributes: f_121,
      prev_auto_reset_points: f_130,
      header: f_140,
      partition_config: f_150,
      request_id: f_160,
      cron_overlap_policy: f_170,
      active_cluster_selection_policy: f_180,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowExecutionStartedEventAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.workflow_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowType", TType::Struct, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.parent_workflow_domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("parentWorkflowDomain", TType::String, 12))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.parent_workflow_execution {
      o_prot.write_field_begin(&TFieldIdentifier::new("parentWorkflowExecution", TType::Struct, 14))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.parent_initiated_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("parentInitiatedEventId", TType::I64, 16))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.task_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskList", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.input {
      o_prot.write_field_begin(&TFieldIdentifier::new("input", TType::String, 30))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.execution_start_to_close_timeout_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("executionStartToCloseTimeoutSeconds", TType::I32, 40))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.task_start_to_close_timeout_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskStartToCloseTimeoutSeconds", TType::I32, 50))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.continued_execution_run_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("continuedExecutionRunId", TType::String, 54))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.initiator {
      o_prot.write_field_begin(&TFieldIdentifier::new("initiator", TType::I32, 55))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.continued_failure_reason {
      o_prot.write_field_begin(&TFieldIdentifier::new("continuedFailureReason", TType::String, 56))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.continued_failure_details {
      o_prot.write_field_begin(&TFieldIdentifier::new("continuedFailureDetails", TType::String, 57))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.last_completion_result {
      o_prot.write_field_begin(&TFieldIdentifier::new("lastCompletionResult", TType::String, 58))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.original_execution_run_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("originalExecutionRunId", TType::String, 59))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.identity {
      o_prot.write_field_begin(&TFieldIdentifier::new("identity", TType::String, 60))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.first_execution_run_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("firstExecutionRunId", TType::String, 61))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.first_scheduled_time_nano {
      o_prot.write_field_begin(&TFieldIdentifier::new("firstScheduledTimeNano", TType::I64, 62))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.retry_policy {
      o_prot.write_field_begin(&TFieldIdentifier::new("retryPolicy", TType::Struct, 70))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.attempt {
      o_prot.write_field_begin(&TFieldIdentifier::new("attempt", TType::I32, 80))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.expiration_timestamp {
      o_prot.write_field_begin(&TFieldIdentifier::new("expirationTimestamp", TType::I64, 90))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cron_schedule {
      o_prot.write_field_begin(&TFieldIdentifier::new("cronSchedule", TType::String, 100))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.first_decision_task_backoff_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("firstDecisionTaskBackoffSeconds", TType::I32, 110))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.memo {
      o_prot.write_field_begin(&TFieldIdentifier::new("memo", TType::Struct, 120))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.search_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("searchAttributes", TType::Struct, 121))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.prev_auto_reset_points {
      o_prot.write_field_begin(&TFieldIdentifier::new("prevAutoResetPoints", TType::Struct, 130))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.header {
      o_prot.write_field_begin(&TFieldIdentifier::new("header", TType::Struct, 140))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.partition_config {
      o_prot.write_field_begin(&TFieldIdentifier::new("partitionConfig", TType::Map, 150))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.request_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 160))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cron_overlap_policy {
      o_prot.write_field_begin(&TFieldIdentifier::new("cronOverlapPolicy", TType::I32, 170))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.active_cluster_selection_policy {
      o_prot.write_field_begin(&TFieldIdentifier::new("activeClusterSelectionPolicy", TType::Struct, 180))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ResetPoints
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ResetPoints {
  pub points: Option<Vec<Box<ResetPointInfo>>>,
}

impl ResetPoints {
  pub fn new<F10>(points: F10) -> ResetPoints where F10: Into<Option<Vec<Box<ResetPointInfo>>>> {
    ResetPoints {
      points: points.into(),
    }
  }
}

impl TSerializable for ResetPoints {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ResetPoints> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<Vec<Box<ResetPointInfo>>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Box<ResetPointInfo>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_12 = Box::new(ResetPointInfo::read_from_in_protocol(i_prot)?);
            val.push(list_elem_12);
          }
          i_prot.read_list_end()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ResetPoints {
      points: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ResetPoints");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.points {
      o_prot.write_field_begin(&TFieldIdentifier::new("points", TType::List, 10))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ResetPointInfo
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ResetPointInfo {
  pub binary_checksum: Option<String>,
  pub run_id: Option<String>,
  pub first_decision_completed_id: Option<i64>,
  pub created_time_nano: Option<i64>,
  pub expiring_time_nano: Option<i64>,
  pub resettable: Option<bool>,
}

impl ResetPointInfo {
  pub fn new<F10, F20, F30, F40, F50, F60>(binary_checksum: F10, run_id: F20, first_decision_completed_id: F30, created_time_nano: F40, expiring_time_nano: F50, resettable: F60) -> ResetPointInfo where F10: Into<Option<String>>, F20: Into<Option<String>>, F30: Into<Option<i64>>, F40: Into<Option<i64>>, F50: Into<Option<i64>>, F60: Into<Option<bool>> {
    ResetPointInfo {
      binary_checksum: binary_checksum.into(),
      run_id: run_id.into(),
      first_decision_completed_id: first_decision_completed_id.into(),
      created_time_nano: created_time_nano.into(),
      expiring_time_nano: expiring_time_nano.into(),
      resettable: resettable.into(),
    }
  }
}

impl TSerializable for ResetPointInfo {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ResetPointInfo> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<String> = None;
    let mut f_30: Option<i64> = None;
    let mut f_40: Option<i64> = None;
    let mut f_50: Option<i64> = None;
    let mut f_60: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_i64()?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_i64()?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_i64()?;
          f_50 = Some(val);
        },
        60 => {
          let val = i_prot.read_bool()?;
          f_60 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ResetPointInfo {
      binary_checksum: f_10,
      run_id: f_20,
      first_decision_completed_id: f_30,
      created_time_nano: f_40,
      expiring_time_nano: f_50,
      resettable: f_60,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ResetPointInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.binary_checksum {
      o_prot.write_field_begin(&TFieldIdentifier::new("binaryChecksum", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.run_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("runId", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.first_decision_completed_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("firstDecisionCompletedId", TType::I64, 30))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.created_time_nano {
      o_prot.write_field_begin(&TFieldIdentifier::new("createdTimeNano", TType::I64, 40))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.expiring_time_nano {
      o_prot.write_field_begin(&TFieldIdentifier::new("expiringTimeNano", TType::I64, 50))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.resettable {
      o_prot.write_field_begin(&TFieldIdentifier::new("resettable", TType::Bool, 60))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowExecutionCompletedEventAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WorkflowExecutionCompletedEventAttributes {
  pub result: Option<Vec<u8>>,
  pub decision_task_completed_event_id: Option<i64>,
}

impl WorkflowExecutionCompletedEventAttributes {
  pub fn new<F10, F20>(result: F10, decision_task_completed_event_id: F20) -> WorkflowExecutionCompletedEventAttributes where F10: Into<Option<Vec<u8>>>, F20: Into<Option<i64>> {
    WorkflowExecutionCompletedEventAttributes {
      result: result.into(),
      decision_task_completed_event_id: decision_task_completed_event_id.into(),
    }
  }
}

impl TSerializable for WorkflowExecutionCompletedEventAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowExecutionCompletedEventAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<Vec<u8>> = None;
    let mut f_20: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_bytes()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_i64()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowExecutionCompletedEventAttributes {
      result: f_10,
      decision_task_completed_event_id: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowExecutionCompletedEventAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result {
      o_prot.write_field_begin(&TFieldIdentifier::new("result", TType::String, 10))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.decision_task_completed_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("decisionTaskCompletedEventId", TType::I64, 20))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowExecutionFailedEventAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WorkflowExecutionFailedEventAttributes {
  pub reason: Option<String>,
  pub details: Option<Vec<u8>>,
  pub decision_task_completed_event_id: Option<i64>,
}

impl WorkflowExecutionFailedEventAttributes {
  pub fn new<F10, F20, F30>(reason: F10, details: F20, decision_task_completed_event_id: F30) -> WorkflowExecutionFailedEventAttributes where F10: Into<Option<String>>, F20: Into<Option<Vec<u8>>>, F30: Into<Option<i64>> {
    WorkflowExecutionFailedEventAttributes {
      reason: reason.into(),
      details: details.into(),
      decision_task_completed_event_id: decision_task_completed_event_id.into(),
    }
  }
}

impl TSerializable for WorkflowExecutionFailedEventAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowExecutionFailedEventAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<Vec<u8>> = None;
    let mut f_30: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_bytes()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_i64()?;
          f_30 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowExecutionFailedEventAttributes {
      reason: f_10,
      details: f_20,
      decision_task_completed_event_id: f_30,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowExecutionFailedEventAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.reason {
      o_prot.write_field_begin(&TFieldIdentifier::new("reason", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.details {
      o_prot.write_field_begin(&TFieldIdentifier::new("details", TType::String, 20))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.decision_task_completed_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("decisionTaskCompletedEventId", TType::I64, 30))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowExecutionTimedOutEventAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WorkflowExecutionTimedOutEventAttributes {
  pub timeout_type: Option<TimeoutType>,
}

impl WorkflowExecutionTimedOutEventAttributes {
  pub fn new<F10>(timeout_type: F10) -> WorkflowExecutionTimedOutEventAttributes where F10: Into<Option<TimeoutType>> {
    WorkflowExecutionTimedOutEventAttributes {
      timeout_type: timeout_type.into(),
    }
  }
}

impl TSerializable for WorkflowExecutionTimedOutEventAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowExecutionTimedOutEventAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<TimeoutType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = TimeoutType::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowExecutionTimedOutEventAttributes {
      timeout_type: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowExecutionTimedOutEventAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.timeout_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("timeoutType", TType::I32, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowExecutionContinuedAsNewEventAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WorkflowExecutionContinuedAsNewEventAttributes {
  pub new_execution_run_id: Option<String>,
  pub workflow_type: Option<WorkflowType>,
  pub task_list: Option<TaskList>,
  pub input: Option<Vec<u8>>,
  pub execution_start_to_close_timeout_seconds: Option<i32>,
  pub task_start_to_close_timeout_seconds: Option<i32>,
  pub decision_task_completed_event_id: Option<i64>,
  pub backoff_start_interval_in_seconds: Option<i32>,
  pub initiator: Option<ContinueAsNewInitiator>,
  pub failure_reason: Option<String>,
  pub failure_details: Option<Vec<u8>>,
  pub last_completion_result: Option<Vec<u8>>,
  pub header: Option<Header>,
  pub memo: Option<Memo>,
  pub search_attributes: Option<SearchAttributes>,
  pub cron_overlap_policy: Option<CronOverlapPolicy>,
  pub active_cluster_selection_policy: Option<Box<ActiveClusterSelectionPolicy>>,
}

impl WorkflowExecutionContinuedAsNewEventAttributes {
  pub fn new<F10, F20, F30, F40, F50, F60, F70, F80, F90, F100, F110, F120, F130, F140, F150, F160, F170>(new_execution_run_id: F10, workflow_type: F20, task_list: F30, input: F40, execution_start_to_close_timeout_seconds: F50, task_start_to_close_timeout_seconds: F60, decision_task_completed_event_id: F70, backoff_start_interval_in_seconds: F80, initiator: F90, failure_reason: F100, failure_details: F110, last_completion_result: F120, header: F130, memo: F140, search_attributes: F150, cron_overlap_policy: F160, active_cluster_selection_policy: F170) -> WorkflowExecutionContinuedAsNewEventAttributes where F10: Into<Option<String>>, F20: Into<Option<WorkflowType>>, F30: Into<Option<TaskList>>, F40: Into<Option<Vec<u8>>>, F50: Into<Option<i32>>, F60: Into<Option<i32>>, F70: Into<Option<i64>>, F80: Into<Option<i32>>, F90: Into<Option<ContinueAsNewInitiator>>, F100: Into<Option<String>>, F110: Into<Option<Vec<u8>>>, F120: Into<Option<Vec<u8>>>, F130: Into<Option<Header>>, F140: Into<Option<Memo>>, F150: Into<Option<SearchAttributes>>, F160: Into<Option<CronOverlapPolicy>>, F170: Into<Option<Box<ActiveClusterSelectionPolicy>>> {
    WorkflowExecutionContinuedAsNewEventAttributes {
      new_execution_run_id: new_execution_run_id.into(),
      workflow_type: workflow_type.into(),
      task_list: task_list.into(),
      input: input.into(),
      execution_start_to_close_timeout_seconds: execution_start_to_close_timeout_seconds.into(),
      task_start_to_close_timeout_seconds: task_start_to_close_timeout_seconds.into(),
      decision_task_completed_event_id: decision_task_completed_event_id.into(),
      backoff_start_interval_in_seconds: backoff_start_interval_in_seconds.into(),
      initiator: initiator.into(),
      failure_reason: failure_reason.into(),
      failure_details: failure_details.into(),
      last_completion_result: last_completion_result.into(),
      header: header.into(),
      memo: memo.into(),
      search_attributes: search_attributes.into(),
      cron_overlap_policy: cron_overlap_policy.into(),
      active_cluster_selection_policy: active_cluster_selection_policy.into(),
    }
  }
}

impl TSerializable for WorkflowExecutionContinuedAsNewEventAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowExecutionContinuedAsNewEventAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<WorkflowType> = None;
    let mut f_30: Option<TaskList> = None;
    let mut f_40: Option<Vec<u8>> = None;
    let mut f_50: Option<i32> = None;
    let mut f_60: Option<i32> = None;
    let mut f_70: Option<i64> = None;
    let mut f_80: Option<i32> = None;
    let mut f_90: Option<ContinueAsNewInitiator> = None;
    let mut f_100: Option<String> = None;
    let mut f_110: Option<Vec<u8>> = None;
    let mut f_120: Option<Vec<u8>> = None;
    let mut f_130: Option<Header> = None;
    let mut f_140: Option<Memo> = None;
    let mut f_150: Option<SearchAttributes> = None;
    let mut f_160: Option<CronOverlapPolicy> = None;
    let mut f_170: Option<Box<ActiveClusterSelectionPolicy>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = WorkflowType::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        30 => {
          let val = TaskList::read_from_in_protocol(i_prot)?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_bytes()?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_i32()?;
          f_50 = Some(val);
        },
        60 => {
          let val = i_prot.read_i32()?;
          f_60 = Some(val);
        },
        70 => {
          let val = i_prot.read_i64()?;
          f_70 = Some(val);
        },
        80 => {
          let val = i_prot.read_i32()?;
          f_80 = Some(val);
        },
        90 => {
          let val = ContinueAsNewInitiator::read_from_in_protocol(i_prot)?;
          f_90 = Some(val);
        },
        100 => {
          let val = i_prot.read_string()?;
          f_100 = Some(val);
        },
        110 => {
          let val = i_prot.read_bytes()?;
          f_110 = Some(val);
        },
        120 => {
          let val = i_prot.read_bytes()?;
          f_120 = Some(val);
        },
        130 => {
          let val = Header::read_from_in_protocol(i_prot)?;
          f_130 = Some(val);
        },
        140 => {
          let val = Memo::read_from_in_protocol(i_prot)?;
          f_140 = Some(val);
        },
        150 => {
          let val = SearchAttributes::read_from_in_protocol(i_prot)?;
          f_150 = Some(val);
        },
        160 => {
          let val = CronOverlapPolicy::read_from_in_protocol(i_prot)?;
          f_160 = Some(val);
        },
        170 => {
          let val = Box::new(ActiveClusterSelectionPolicy::read_from_in_protocol(i_prot)?);
          f_170 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowExecutionContinuedAsNewEventAttributes {
      new_execution_run_id: f_10,
      workflow_type: f_20,
      task_list: f_30,
      input: f_40,
      execution_start_to_close_timeout_seconds: f_50,
      task_start_to_close_timeout_seconds: f_60,
      decision_task_completed_event_id: f_70,
      backoff_start_interval_in_seconds: f_80,
      initiator: f_90,
      failure_reason: f_100,
      failure_details: f_110,
      last_completion_result: f_120,
      header: f_130,
      memo: f_140,
      search_attributes: f_150,
      cron_overlap_policy: f_160,
      active_cluster_selection_policy: f_170,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowExecutionContinuedAsNewEventAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.new_execution_run_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("newExecutionRunId", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowType", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.task_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskList", TType::Struct, 30))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.input {
      o_prot.write_field_begin(&TFieldIdentifier::new("input", TType::String, 40))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.execution_start_to_close_timeout_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("executionStartToCloseTimeoutSeconds", TType::I32, 50))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.task_start_to_close_timeout_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskStartToCloseTimeoutSeconds", TType::I32, 60))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.decision_task_completed_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("decisionTaskCompletedEventId", TType::I64, 70))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.backoff_start_interval_in_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("backoffStartIntervalInSeconds", TType::I32, 80))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.initiator {
      o_prot.write_field_begin(&TFieldIdentifier::new("initiator", TType::I32, 90))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.failure_reason {
      o_prot.write_field_begin(&TFieldIdentifier::new("failureReason", TType::String, 100))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.failure_details {
      o_prot.write_field_begin(&TFieldIdentifier::new("failureDetails", TType::String, 110))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.last_completion_result {
      o_prot.write_field_begin(&TFieldIdentifier::new("lastCompletionResult", TType::String, 120))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.header {
      o_prot.write_field_begin(&TFieldIdentifier::new("header", TType::Struct, 130))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.memo {
      o_prot.write_field_begin(&TFieldIdentifier::new("memo", TType::Struct, 140))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.search_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("searchAttributes", TType::Struct, 150))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cron_overlap_policy {
      o_prot.write_field_begin(&TFieldIdentifier::new("cronOverlapPolicy", TType::I32, 160))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.active_cluster_selection_policy {
      o_prot.write_field_begin(&TFieldIdentifier::new("activeClusterSelectionPolicy", TType::Struct, 170))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DecisionTaskScheduledEventAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DecisionTaskScheduledEventAttributes {
  pub task_list: Option<TaskList>,
  pub start_to_close_timeout_seconds: Option<i32>,
  pub attempt: Option<i64>,
}

impl DecisionTaskScheduledEventAttributes {
  pub fn new<F10, F20, F30>(task_list: F10, start_to_close_timeout_seconds: F20, attempt: F30) -> DecisionTaskScheduledEventAttributes where F10: Into<Option<TaskList>>, F20: Into<Option<i32>>, F30: Into<Option<i64>> {
    DecisionTaskScheduledEventAttributes {
      task_list: task_list.into(),
      start_to_close_timeout_seconds: start_to_close_timeout_seconds.into(),
      attempt: attempt.into(),
    }
  }
}

impl TSerializable for DecisionTaskScheduledEventAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DecisionTaskScheduledEventAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<TaskList> = None;
    let mut f_20: Option<i32> = None;
    let mut f_30: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = TaskList::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_i32()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_i64()?;
          f_30 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DecisionTaskScheduledEventAttributes {
      task_list: f_10,
      start_to_close_timeout_seconds: f_20,
      attempt: f_30,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DecisionTaskScheduledEventAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.task_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskList", TType::Struct, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.start_to_close_timeout_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("startToCloseTimeoutSeconds", TType::I32, 20))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.attempt {
      o_prot.write_field_begin(&TFieldIdentifier::new("attempt", TType::I64, 30))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DecisionTaskStartedEventAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DecisionTaskStartedEventAttributes {
  pub scheduled_event_id: Option<i64>,
  pub identity: Option<String>,
  pub request_id: Option<String>,
}

impl DecisionTaskStartedEventAttributes {
  pub fn new<F10, F20, F30>(scheduled_event_id: F10, identity: F20, request_id: F30) -> DecisionTaskStartedEventAttributes where F10: Into<Option<i64>>, F20: Into<Option<String>>, F30: Into<Option<String>> {
    DecisionTaskStartedEventAttributes {
      scheduled_event_id: scheduled_event_id.into(),
      identity: identity.into(),
      request_id: request_id.into(),
    }
  }
}

impl TSerializable for DecisionTaskStartedEventAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DecisionTaskStartedEventAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<i64> = None;
    let mut f_20: Option<String> = None;
    let mut f_30: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_i64()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_string()?;
          f_30 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DecisionTaskStartedEventAttributes {
      scheduled_event_id: f_10,
      identity: f_20,
      request_id: f_30,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DecisionTaskStartedEventAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.scheduled_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("scheduledEventId", TType::I64, 10))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.identity {
      o_prot.write_field_begin(&TFieldIdentifier::new("identity", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.request_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 30))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DecisionTaskCompletedEventAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DecisionTaskCompletedEventAttributes {
  pub execution_context: Option<Vec<u8>>,
  pub scheduled_event_id: Option<i64>,
  pub started_event_id: Option<i64>,
  pub identity: Option<String>,
  pub binary_checksum: Option<String>,
}

impl DecisionTaskCompletedEventAttributes {
  pub fn new<F10, F20, F30, F40, F50>(execution_context: F10, scheduled_event_id: F20, started_event_id: F30, identity: F40, binary_checksum: F50) -> DecisionTaskCompletedEventAttributes where F10: Into<Option<Vec<u8>>>, F20: Into<Option<i64>>, F30: Into<Option<i64>>, F40: Into<Option<String>>, F50: Into<Option<String>> {
    DecisionTaskCompletedEventAttributes {
      execution_context: execution_context.into(),
      scheduled_event_id: scheduled_event_id.into(),
      started_event_id: started_event_id.into(),
      identity: identity.into(),
      binary_checksum: binary_checksum.into(),
    }
  }
}

impl TSerializable for DecisionTaskCompletedEventAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DecisionTaskCompletedEventAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<Vec<u8>> = None;
    let mut f_20: Option<i64> = None;
    let mut f_30: Option<i64> = None;
    let mut f_40: Option<String> = None;
    let mut f_50: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_bytes()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_i64()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_i64()?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_string()?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_string()?;
          f_50 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DecisionTaskCompletedEventAttributes {
      execution_context: f_10,
      scheduled_event_id: f_20,
      started_event_id: f_30,
      identity: f_40,
      binary_checksum: f_50,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DecisionTaskCompletedEventAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.execution_context {
      o_prot.write_field_begin(&TFieldIdentifier::new("executionContext", TType::String, 10))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.scheduled_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("scheduledEventId", TType::I64, 20))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.started_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("startedEventId", TType::I64, 30))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.identity {
      o_prot.write_field_begin(&TFieldIdentifier::new("identity", TType::String, 40))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.binary_checksum {
      o_prot.write_field_begin(&TFieldIdentifier::new("binaryChecksum", TType::String, 50))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DecisionTaskTimedOutEventAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DecisionTaskTimedOutEventAttributes {
  pub scheduled_event_id: Option<i64>,
  pub started_event_id: Option<i64>,
  pub timeout_type: Option<TimeoutType>,
  pub base_run_id: Option<String>,
  pub new_run_id: Option<String>,
  pub fork_event_version: Option<i64>,
  pub reason: Option<String>,
  pub cause: Option<DecisionTaskTimedOutCause>,
  pub request_id: Option<String>,
}

impl DecisionTaskTimedOutEventAttributes {
  pub fn new<F10, F20, F30, F40, F50, F60, F70, F80, F90>(scheduled_event_id: F10, started_event_id: F20, timeout_type: F30, base_run_id: F40, new_run_id: F50, fork_event_version: F60, reason: F70, cause: F80, request_id: F90) -> DecisionTaskTimedOutEventAttributes where F10: Into<Option<i64>>, F20: Into<Option<i64>>, F30: Into<Option<TimeoutType>>, F40: Into<Option<String>>, F50: Into<Option<String>>, F60: Into<Option<i64>>, F70: Into<Option<String>>, F80: Into<Option<DecisionTaskTimedOutCause>>, F90: Into<Option<String>> {
    DecisionTaskTimedOutEventAttributes {
      scheduled_event_id: scheduled_event_id.into(),
      started_event_id: started_event_id.into(),
      timeout_type: timeout_type.into(),
      base_run_id: base_run_id.into(),
      new_run_id: new_run_id.into(),
      fork_event_version: fork_event_version.into(),
      reason: reason.into(),
      cause: cause.into(),
      request_id: request_id.into(),
    }
  }
}

impl TSerializable for DecisionTaskTimedOutEventAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DecisionTaskTimedOutEventAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<i64> = None;
    let mut f_20: Option<i64> = None;
    let mut f_30: Option<TimeoutType> = None;
    let mut f_40: Option<String> = None;
    let mut f_50: Option<String> = None;
    let mut f_60: Option<i64> = None;
    let mut f_70: Option<String> = None;
    let mut f_80: Option<DecisionTaskTimedOutCause> = None;
    let mut f_90: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_i64()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_i64()?;
          f_20 = Some(val);
        },
        30 => {
          let val = TimeoutType::read_from_in_protocol(i_prot)?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_string()?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_string()?;
          f_50 = Some(val);
        },
        60 => {
          let val = i_prot.read_i64()?;
          f_60 = Some(val);
        },
        70 => {
          let val = i_prot.read_string()?;
          f_70 = Some(val);
        },
        80 => {
          let val = DecisionTaskTimedOutCause::read_from_in_protocol(i_prot)?;
          f_80 = Some(val);
        },
        90 => {
          let val = i_prot.read_string()?;
          f_90 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DecisionTaskTimedOutEventAttributes {
      scheduled_event_id: f_10,
      started_event_id: f_20,
      timeout_type: f_30,
      base_run_id: f_40,
      new_run_id: f_50,
      fork_event_version: f_60,
      reason: f_70,
      cause: f_80,
      request_id: f_90,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DecisionTaskTimedOutEventAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.scheduled_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("scheduledEventId", TType::I64, 10))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.started_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("startedEventId", TType::I64, 20))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.timeout_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("timeoutType", TType::I32, 30))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.base_run_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("baseRunId", TType::String, 40))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.new_run_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("newRunId", TType::String, 50))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.fork_event_version {
      o_prot.write_field_begin(&TFieldIdentifier::new("forkEventVersion", TType::I64, 60))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.reason {
      o_prot.write_field_begin(&TFieldIdentifier::new("reason", TType::String, 70))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cause {
      o_prot.write_field_begin(&TFieldIdentifier::new("cause", TType::I32, 80))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.request_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 90))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DecisionTaskFailedEventAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DecisionTaskFailedEventAttributes {
  pub scheduled_event_id: Option<i64>,
  pub started_event_id: Option<i64>,
  pub cause: Option<DecisionTaskFailedCause>,
  pub details: Option<Vec<u8>>,
  pub identity: Option<String>,
  pub reason: Option<String>,
  pub base_run_id: Option<String>,
  pub new_run_id: Option<String>,
  pub fork_event_version: Option<i64>,
  pub binary_checksum: Option<String>,
  pub request_id: Option<String>,
}

impl DecisionTaskFailedEventAttributes {
  pub fn new<F10, F20, F30, F35, F40, F50, F60, F70, F80, F90, F100>(scheduled_event_id: F10, started_event_id: F20, cause: F30, details: F35, identity: F40, reason: F50, base_run_id: F60, new_run_id: F70, fork_event_version: F80, binary_checksum: F90, request_id: F100) -> DecisionTaskFailedEventAttributes where F10: Into<Option<i64>>, F20: Into<Option<i64>>, F30: Into<Option<DecisionTaskFailedCause>>, F35: Into<Option<Vec<u8>>>, F40: Into<Option<String>>, F50: Into<Option<String>>, F60: Into<Option<String>>, F70: Into<Option<String>>, F80: Into<Option<i64>>, F90: Into<Option<String>>, F100: Into<Option<String>> {
    DecisionTaskFailedEventAttributes {
      scheduled_event_id: scheduled_event_id.into(),
      started_event_id: started_event_id.into(),
      cause: cause.into(),
      details: details.into(),
      identity: identity.into(),
      reason: reason.into(),
      base_run_id: base_run_id.into(),
      new_run_id: new_run_id.into(),
      fork_event_version: fork_event_version.into(),
      binary_checksum: binary_checksum.into(),
      request_id: request_id.into(),
    }
  }
}

impl TSerializable for DecisionTaskFailedEventAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DecisionTaskFailedEventAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<i64> = None;
    let mut f_20: Option<i64> = None;
    let mut f_30: Option<DecisionTaskFailedCause> = None;
    let mut f_35: Option<Vec<u8>> = None;
    let mut f_40: Option<String> = None;
    let mut f_50: Option<String> = None;
    let mut f_60: Option<String> = None;
    let mut f_70: Option<String> = None;
    let mut f_80: Option<i64> = None;
    let mut f_90: Option<String> = None;
    let mut f_100: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_i64()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_i64()?;
          f_20 = Some(val);
        },
        30 => {
          let val = DecisionTaskFailedCause::read_from_in_protocol(i_prot)?;
          f_30 = Some(val);
        },
        35 => {
          let val = i_prot.read_bytes()?;
          f_35 = Some(val);
        },
        40 => {
          let val = i_prot.read_string()?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_string()?;
          f_50 = Some(val);
        },
        60 => {
          let val = i_prot.read_string()?;
          f_60 = Some(val);
        },
        70 => {
          let val = i_prot.read_string()?;
          f_70 = Some(val);
        },
        80 => {
          let val = i_prot.read_i64()?;
          f_80 = Some(val);
        },
        90 => {
          let val = i_prot.read_string()?;
          f_90 = Some(val);
        },
        100 => {
          let val = i_prot.read_string()?;
          f_100 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DecisionTaskFailedEventAttributes {
      scheduled_event_id: f_10,
      started_event_id: f_20,
      cause: f_30,
      details: f_35,
      identity: f_40,
      reason: f_50,
      base_run_id: f_60,
      new_run_id: f_70,
      fork_event_version: f_80,
      binary_checksum: f_90,
      request_id: f_100,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DecisionTaskFailedEventAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.scheduled_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("scheduledEventId", TType::I64, 10))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.started_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("startedEventId", TType::I64, 20))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cause {
      o_prot.write_field_begin(&TFieldIdentifier::new("cause", TType::I32, 30))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.details {
      o_prot.write_field_begin(&TFieldIdentifier::new("details", TType::String, 35))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.identity {
      o_prot.write_field_begin(&TFieldIdentifier::new("identity", TType::String, 40))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.reason {
      o_prot.write_field_begin(&TFieldIdentifier::new("reason", TType::String, 50))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.base_run_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("baseRunId", TType::String, 60))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.new_run_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("newRunId", TType::String, 70))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.fork_event_version {
      o_prot.write_field_begin(&TFieldIdentifier::new("forkEventVersion", TType::I64, 80))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.binary_checksum {
      o_prot.write_field_begin(&TFieldIdentifier::new("binaryChecksum", TType::String, 90))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.request_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 100))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ActivityTaskScheduledEventAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ActivityTaskScheduledEventAttributes {
  pub activity_id: Option<String>,
  pub activity_type: Option<ActivityType>,
  pub domain: Option<String>,
  pub task_list: Option<TaskList>,
  pub input: Option<Vec<u8>>,
  pub schedule_to_close_timeout_seconds: Option<i32>,
  pub schedule_to_start_timeout_seconds: Option<i32>,
  pub start_to_close_timeout_seconds: Option<i32>,
  pub heartbeat_timeout_seconds: Option<i32>,
  pub decision_task_completed_event_id: Option<i64>,
  pub retry_policy: Option<Box<RetryPolicy>>,
  pub header: Option<Header>,
}

impl ActivityTaskScheduledEventAttributes {
  pub fn new<F10, F20, F25, F30, F40, F45, F50, F55, F60, F90, F110, F120>(activity_id: F10, activity_type: F20, domain: F25, task_list: F30, input: F40, schedule_to_close_timeout_seconds: F45, schedule_to_start_timeout_seconds: F50, start_to_close_timeout_seconds: F55, heartbeat_timeout_seconds: F60, decision_task_completed_event_id: F90, retry_policy: F110, header: F120) -> ActivityTaskScheduledEventAttributes where F10: Into<Option<String>>, F20: Into<Option<ActivityType>>, F25: Into<Option<String>>, F30: Into<Option<TaskList>>, F40: Into<Option<Vec<u8>>>, F45: Into<Option<i32>>, F50: Into<Option<i32>>, F55: Into<Option<i32>>, F60: Into<Option<i32>>, F90: Into<Option<i64>>, F110: Into<Option<Box<RetryPolicy>>>, F120: Into<Option<Header>> {
    ActivityTaskScheduledEventAttributes {
      activity_id: activity_id.into(),
      activity_type: activity_type.into(),
      domain: domain.into(),
      task_list: task_list.into(),
      input: input.into(),
      schedule_to_close_timeout_seconds: schedule_to_close_timeout_seconds.into(),
      schedule_to_start_timeout_seconds: schedule_to_start_timeout_seconds.into(),
      start_to_close_timeout_seconds: start_to_close_timeout_seconds.into(),
      heartbeat_timeout_seconds: heartbeat_timeout_seconds.into(),
      decision_task_completed_event_id: decision_task_completed_event_id.into(),
      retry_policy: retry_policy.into(),
      header: header.into(),
    }
  }
}

impl TSerializable for ActivityTaskScheduledEventAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ActivityTaskScheduledEventAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<ActivityType> = None;
    let mut f_25: Option<String> = None;
    let mut f_30: Option<TaskList> = None;
    let mut f_40: Option<Vec<u8>> = None;
    let mut f_45: Option<i32> = None;
    let mut f_50: Option<i32> = None;
    let mut f_55: Option<i32> = None;
    let mut f_60: Option<i32> = None;
    let mut f_90: Option<i64> = None;
    let mut f_110: Option<Box<RetryPolicy>> = None;
    let mut f_120: Option<Header> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = ActivityType::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        25 => {
          let val = i_prot.read_string()?;
          f_25 = Some(val);
        },
        30 => {
          let val = TaskList::read_from_in_protocol(i_prot)?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_bytes()?;
          f_40 = Some(val);
        },
        45 => {
          let val = i_prot.read_i32()?;
          f_45 = Some(val);
        },
        50 => {
          let val = i_prot.read_i32()?;
          f_50 = Some(val);
        },
        55 => {
          let val = i_prot.read_i32()?;
          f_55 = Some(val);
        },
        60 => {
          let val = i_prot.read_i32()?;
          f_60 = Some(val);
        },
        90 => {
          let val = i_prot.read_i64()?;
          f_90 = Some(val);
        },
        110 => {
          let val = Box::new(RetryPolicy::read_from_in_protocol(i_prot)?);
          f_110 = Some(val);
        },
        120 => {
          let val = Header::read_from_in_protocol(i_prot)?;
          f_120 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ActivityTaskScheduledEventAttributes {
      activity_id: f_10,
      activity_type: f_20,
      domain: f_25,
      task_list: f_30,
      input: f_40,
      schedule_to_close_timeout_seconds: f_45,
      schedule_to_start_timeout_seconds: f_50,
      start_to_close_timeout_seconds: f_55,
      heartbeat_timeout_seconds: f_60,
      decision_task_completed_event_id: f_90,
      retry_policy: f_110,
      header: f_120,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ActivityTaskScheduledEventAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.activity_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("activityId", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.activity_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("activityType", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 25))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.task_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskList", TType::Struct, 30))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.input {
      o_prot.write_field_begin(&TFieldIdentifier::new("input", TType::String, 40))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.schedule_to_close_timeout_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("scheduleToCloseTimeoutSeconds", TType::I32, 45))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.schedule_to_start_timeout_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("scheduleToStartTimeoutSeconds", TType::I32, 50))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.start_to_close_timeout_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("startToCloseTimeoutSeconds", TType::I32, 55))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.heartbeat_timeout_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("heartbeatTimeoutSeconds", TType::I32, 60))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.decision_task_completed_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("decisionTaskCompletedEventId", TType::I64, 90))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.retry_policy {
      o_prot.write_field_begin(&TFieldIdentifier::new("retryPolicy", TType::Struct, 110))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.header {
      o_prot.write_field_begin(&TFieldIdentifier::new("header", TType::Struct, 120))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ActivityTaskStartedEventAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ActivityTaskStartedEventAttributes {
  pub scheduled_event_id: Option<i64>,
  pub identity: Option<String>,
  pub request_id: Option<String>,
  pub attempt: Option<i32>,
  pub last_failure_reason: Option<String>,
  pub last_failure_details: Option<Vec<u8>>,
}

impl ActivityTaskStartedEventAttributes {
  pub fn new<F10, F20, F30, F40, F50, F60>(scheduled_event_id: F10, identity: F20, request_id: F30, attempt: F40, last_failure_reason: F50, last_failure_details: F60) -> ActivityTaskStartedEventAttributes where F10: Into<Option<i64>>, F20: Into<Option<String>>, F30: Into<Option<String>>, F40: Into<Option<i32>>, F50: Into<Option<String>>, F60: Into<Option<Vec<u8>>> {
    ActivityTaskStartedEventAttributes {
      scheduled_event_id: scheduled_event_id.into(),
      identity: identity.into(),
      request_id: request_id.into(),
      attempt: attempt.into(),
      last_failure_reason: last_failure_reason.into(),
      last_failure_details: last_failure_details.into(),
    }
  }
}

impl TSerializable for ActivityTaskStartedEventAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ActivityTaskStartedEventAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<i64> = None;
    let mut f_20: Option<String> = None;
    let mut f_30: Option<String> = None;
    let mut f_40: Option<i32> = None;
    let mut f_50: Option<String> = None;
    let mut f_60: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_i64()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_string()?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_i32()?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_string()?;
          f_50 = Some(val);
        },
        60 => {
          let val = i_prot.read_bytes()?;
          f_60 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ActivityTaskStartedEventAttributes {
      scheduled_event_id: f_10,
      identity: f_20,
      request_id: f_30,
      attempt: f_40,
      last_failure_reason: f_50,
      last_failure_details: f_60,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ActivityTaskStartedEventAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.scheduled_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("scheduledEventId", TType::I64, 10))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.identity {
      o_prot.write_field_begin(&TFieldIdentifier::new("identity", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.request_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 30))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.attempt {
      o_prot.write_field_begin(&TFieldIdentifier::new("attempt", TType::I32, 40))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.last_failure_reason {
      o_prot.write_field_begin(&TFieldIdentifier::new("lastFailureReason", TType::String, 50))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.last_failure_details {
      o_prot.write_field_begin(&TFieldIdentifier::new("lastFailureDetails", TType::String, 60))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ActivityTaskCompletedEventAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ActivityTaskCompletedEventAttributes {
  pub result: Option<Vec<u8>>,
  pub scheduled_event_id: Option<i64>,
  pub started_event_id: Option<i64>,
  pub identity: Option<String>,
}

impl ActivityTaskCompletedEventAttributes {
  pub fn new<F10, F20, F30, F40>(result: F10, scheduled_event_id: F20, started_event_id: F30, identity: F40) -> ActivityTaskCompletedEventAttributes where F10: Into<Option<Vec<u8>>>, F20: Into<Option<i64>>, F30: Into<Option<i64>>, F40: Into<Option<String>> {
    ActivityTaskCompletedEventAttributes {
      result: result.into(),
      scheduled_event_id: scheduled_event_id.into(),
      started_event_id: started_event_id.into(),
      identity: identity.into(),
    }
  }
}

impl TSerializable for ActivityTaskCompletedEventAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ActivityTaskCompletedEventAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<Vec<u8>> = None;
    let mut f_20: Option<i64> = None;
    let mut f_30: Option<i64> = None;
    let mut f_40: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_bytes()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_i64()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_i64()?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_string()?;
          f_40 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ActivityTaskCompletedEventAttributes {
      result: f_10,
      scheduled_event_id: f_20,
      started_event_id: f_30,
      identity: f_40,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ActivityTaskCompletedEventAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result {
      o_prot.write_field_begin(&TFieldIdentifier::new("result", TType::String, 10))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.scheduled_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("scheduledEventId", TType::I64, 20))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.started_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("startedEventId", TType::I64, 30))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.identity {
      o_prot.write_field_begin(&TFieldIdentifier::new("identity", TType::String, 40))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ActivityTaskFailedEventAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ActivityTaskFailedEventAttributes {
  pub reason: Option<String>,
  pub details: Option<Vec<u8>>,
  pub scheduled_event_id: Option<i64>,
  pub started_event_id: Option<i64>,
  pub identity: Option<String>,
}

impl ActivityTaskFailedEventAttributes {
  pub fn new<F10, F20, F30, F40, F50>(reason: F10, details: F20, scheduled_event_id: F30, started_event_id: F40, identity: F50) -> ActivityTaskFailedEventAttributes where F10: Into<Option<String>>, F20: Into<Option<Vec<u8>>>, F30: Into<Option<i64>>, F40: Into<Option<i64>>, F50: Into<Option<String>> {
    ActivityTaskFailedEventAttributes {
      reason: reason.into(),
      details: details.into(),
      scheduled_event_id: scheduled_event_id.into(),
      started_event_id: started_event_id.into(),
      identity: identity.into(),
    }
  }
}

impl TSerializable for ActivityTaskFailedEventAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ActivityTaskFailedEventAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<Vec<u8>> = None;
    let mut f_30: Option<i64> = None;
    let mut f_40: Option<i64> = None;
    let mut f_50: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_bytes()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_i64()?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_i64()?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_string()?;
          f_50 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ActivityTaskFailedEventAttributes {
      reason: f_10,
      details: f_20,
      scheduled_event_id: f_30,
      started_event_id: f_40,
      identity: f_50,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ActivityTaskFailedEventAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.reason {
      o_prot.write_field_begin(&TFieldIdentifier::new("reason", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.details {
      o_prot.write_field_begin(&TFieldIdentifier::new("details", TType::String, 20))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.scheduled_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("scheduledEventId", TType::I64, 30))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.started_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("startedEventId", TType::I64, 40))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.identity {
      o_prot.write_field_begin(&TFieldIdentifier::new("identity", TType::String, 50))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ActivityTaskTimedOutEventAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ActivityTaskTimedOutEventAttributes {
  pub details: Option<Vec<u8>>,
  pub scheduled_event_id: Option<i64>,
  pub started_event_id: Option<i64>,
  pub timeout_type: Option<TimeoutType>,
  pub last_failure_reason: Option<String>,
  pub last_failure_details: Option<Vec<u8>>,
}

impl ActivityTaskTimedOutEventAttributes {
  pub fn new<F5, F10, F20, F30, F40, F50>(details: F5, scheduled_event_id: F10, started_event_id: F20, timeout_type: F30, last_failure_reason: F40, last_failure_details: F50) -> ActivityTaskTimedOutEventAttributes where F5: Into<Option<Vec<u8>>>, F10: Into<Option<i64>>, F20: Into<Option<i64>>, F30: Into<Option<TimeoutType>>, F40: Into<Option<String>>, F50: Into<Option<Vec<u8>>> {
    ActivityTaskTimedOutEventAttributes {
      details: details.into(),
      scheduled_event_id: scheduled_event_id.into(),
      started_event_id: started_event_id.into(),
      timeout_type: timeout_type.into(),
      last_failure_reason: last_failure_reason.into(),
      last_failure_details: last_failure_details.into(),
    }
  }
}

impl TSerializable for ActivityTaskTimedOutEventAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ActivityTaskTimedOutEventAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_5: Option<Vec<u8>> = None;
    let mut f_10: Option<i64> = None;
    let mut f_20: Option<i64> = None;
    let mut f_30: Option<TimeoutType> = None;
    let mut f_40: Option<String> = None;
    let mut f_50: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        5 => {
          let val = i_prot.read_bytes()?;
          f_5 = Some(val);
        },
        10 => {
          let val = i_prot.read_i64()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_i64()?;
          f_20 = Some(val);
        },
        30 => {
          let val = TimeoutType::read_from_in_protocol(i_prot)?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_string()?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_bytes()?;
          f_50 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ActivityTaskTimedOutEventAttributes {
      details: f_5,
      scheduled_event_id: f_10,
      started_event_id: f_20,
      timeout_type: f_30,
      last_failure_reason: f_40,
      last_failure_details: f_50,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ActivityTaskTimedOutEventAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.details {
      o_prot.write_field_begin(&TFieldIdentifier::new("details", TType::String, 5))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.scheduled_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("scheduledEventId", TType::I64, 10))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.started_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("startedEventId", TType::I64, 20))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.timeout_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("timeoutType", TType::I32, 30))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.last_failure_reason {
      o_prot.write_field_begin(&TFieldIdentifier::new("lastFailureReason", TType::String, 40))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.last_failure_details {
      o_prot.write_field_begin(&TFieldIdentifier::new("lastFailureDetails", TType::String, 50))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ActivityTaskCancelRequestedEventAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ActivityTaskCancelRequestedEventAttributes {
  pub activity_id: Option<String>,
  pub decision_task_completed_event_id: Option<i64>,
}

impl ActivityTaskCancelRequestedEventAttributes {
  pub fn new<F10, F20>(activity_id: F10, decision_task_completed_event_id: F20) -> ActivityTaskCancelRequestedEventAttributes where F10: Into<Option<String>>, F20: Into<Option<i64>> {
    ActivityTaskCancelRequestedEventAttributes {
      activity_id: activity_id.into(),
      decision_task_completed_event_id: decision_task_completed_event_id.into(),
    }
  }
}

impl TSerializable for ActivityTaskCancelRequestedEventAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ActivityTaskCancelRequestedEventAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_i64()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ActivityTaskCancelRequestedEventAttributes {
      activity_id: f_10,
      decision_task_completed_event_id: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ActivityTaskCancelRequestedEventAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.activity_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("activityId", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.decision_task_completed_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("decisionTaskCompletedEventId", TType::I64, 20))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// RequestCancelActivityTaskFailedEventAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RequestCancelActivityTaskFailedEventAttributes {
  pub activity_id: Option<String>,
  pub cause: Option<String>,
  pub decision_task_completed_event_id: Option<i64>,
}

impl RequestCancelActivityTaskFailedEventAttributes {
  pub fn new<F10, F20, F30>(activity_id: F10, cause: F20, decision_task_completed_event_id: F30) -> RequestCancelActivityTaskFailedEventAttributes where F10: Into<Option<String>>, F20: Into<Option<String>>, F30: Into<Option<i64>> {
    RequestCancelActivityTaskFailedEventAttributes {
      activity_id: activity_id.into(),
      cause: cause.into(),
      decision_task_completed_event_id: decision_task_completed_event_id.into(),
    }
  }
}

impl TSerializable for RequestCancelActivityTaskFailedEventAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RequestCancelActivityTaskFailedEventAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<String> = None;
    let mut f_30: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_i64()?;
          f_30 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RequestCancelActivityTaskFailedEventAttributes {
      activity_id: f_10,
      cause: f_20,
      decision_task_completed_event_id: f_30,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RequestCancelActivityTaskFailedEventAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.activity_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("activityId", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cause {
      o_prot.write_field_begin(&TFieldIdentifier::new("cause", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.decision_task_completed_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("decisionTaskCompletedEventId", TType::I64, 30))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ActivityTaskCanceledEventAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ActivityTaskCanceledEventAttributes {
  pub details: Option<Vec<u8>>,
  pub latest_cancel_requested_event_id: Option<i64>,
  pub scheduled_event_id: Option<i64>,
  pub started_event_id: Option<i64>,
  pub identity: Option<String>,
}

impl ActivityTaskCanceledEventAttributes {
  pub fn new<F10, F20, F30, F40, F50>(details: F10, latest_cancel_requested_event_id: F20, scheduled_event_id: F30, started_event_id: F40, identity: F50) -> ActivityTaskCanceledEventAttributes where F10: Into<Option<Vec<u8>>>, F20: Into<Option<i64>>, F30: Into<Option<i64>>, F40: Into<Option<i64>>, F50: Into<Option<String>> {
    ActivityTaskCanceledEventAttributes {
      details: details.into(),
      latest_cancel_requested_event_id: latest_cancel_requested_event_id.into(),
      scheduled_event_id: scheduled_event_id.into(),
      started_event_id: started_event_id.into(),
      identity: identity.into(),
    }
  }
}

impl TSerializable for ActivityTaskCanceledEventAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ActivityTaskCanceledEventAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<Vec<u8>> = None;
    let mut f_20: Option<i64> = None;
    let mut f_30: Option<i64> = None;
    let mut f_40: Option<i64> = None;
    let mut f_50: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_bytes()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_i64()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_i64()?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_i64()?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_string()?;
          f_50 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ActivityTaskCanceledEventAttributes {
      details: f_10,
      latest_cancel_requested_event_id: f_20,
      scheduled_event_id: f_30,
      started_event_id: f_40,
      identity: f_50,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ActivityTaskCanceledEventAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.details {
      o_prot.write_field_begin(&TFieldIdentifier::new("details", TType::String, 10))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.latest_cancel_requested_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("latestCancelRequestedEventId", TType::I64, 20))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.scheduled_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("scheduledEventId", TType::I64, 30))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.started_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("startedEventId", TType::I64, 40))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.identity {
      o_prot.write_field_begin(&TFieldIdentifier::new("identity", TType::String, 50))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TimerStartedEventAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TimerStartedEventAttributes {
  pub timer_id: Option<String>,
  pub start_to_fire_timeout_seconds: Option<i64>,
  pub decision_task_completed_event_id: Option<i64>,
}

impl TimerStartedEventAttributes {
  pub fn new<F10, F20, F30>(timer_id: F10, start_to_fire_timeout_seconds: F20, decision_task_completed_event_id: F30) -> TimerStartedEventAttributes where F10: Into<Option<String>>, F20: Into<Option<i64>>, F30: Into<Option<i64>> {
    TimerStartedEventAttributes {
      timer_id: timer_id.into(),
      start_to_fire_timeout_seconds: start_to_fire_timeout_seconds.into(),
      decision_task_completed_event_id: decision_task_completed_event_id.into(),
    }
  }
}

impl TSerializable for TimerStartedEventAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TimerStartedEventAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<i64> = None;
    let mut f_30: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_i64()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_i64()?;
          f_30 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TimerStartedEventAttributes {
      timer_id: f_10,
      start_to_fire_timeout_seconds: f_20,
      decision_task_completed_event_id: f_30,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TimerStartedEventAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.timer_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("timerId", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.start_to_fire_timeout_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("startToFireTimeoutSeconds", TType::I64, 20))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.decision_task_completed_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("decisionTaskCompletedEventId", TType::I64, 30))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TimerFiredEventAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TimerFiredEventAttributes {
  pub timer_id: Option<String>,
  pub started_event_id: Option<i64>,
}

impl TimerFiredEventAttributes {
  pub fn new<F10, F20>(timer_id: F10, started_event_id: F20) -> TimerFiredEventAttributes where F10: Into<Option<String>>, F20: Into<Option<i64>> {
    TimerFiredEventAttributes {
      timer_id: timer_id.into(),
      started_event_id: started_event_id.into(),
    }
  }
}

impl TSerializable for TimerFiredEventAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TimerFiredEventAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_i64()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TimerFiredEventAttributes {
      timer_id: f_10,
      started_event_id: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TimerFiredEventAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.timer_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("timerId", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.started_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("startedEventId", TType::I64, 20))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TimerCanceledEventAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TimerCanceledEventAttributes {
  pub timer_id: Option<String>,
  pub started_event_id: Option<i64>,
  pub decision_task_completed_event_id: Option<i64>,
  pub identity: Option<String>,
}

impl TimerCanceledEventAttributes {
  pub fn new<F10, F20, F30, F40>(timer_id: F10, started_event_id: F20, decision_task_completed_event_id: F30, identity: F40) -> TimerCanceledEventAttributes where F10: Into<Option<String>>, F20: Into<Option<i64>>, F30: Into<Option<i64>>, F40: Into<Option<String>> {
    TimerCanceledEventAttributes {
      timer_id: timer_id.into(),
      started_event_id: started_event_id.into(),
      decision_task_completed_event_id: decision_task_completed_event_id.into(),
      identity: identity.into(),
    }
  }
}

impl TSerializable for TimerCanceledEventAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TimerCanceledEventAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<i64> = None;
    let mut f_30: Option<i64> = None;
    let mut f_40: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_i64()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_i64()?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_string()?;
          f_40 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TimerCanceledEventAttributes {
      timer_id: f_10,
      started_event_id: f_20,
      decision_task_completed_event_id: f_30,
      identity: f_40,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TimerCanceledEventAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.timer_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("timerId", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.started_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("startedEventId", TType::I64, 20))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.decision_task_completed_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("decisionTaskCompletedEventId", TType::I64, 30))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.identity {
      o_prot.write_field_begin(&TFieldIdentifier::new("identity", TType::String, 40))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// CancelTimerFailedEventAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CancelTimerFailedEventAttributes {
  pub timer_id: Option<String>,
  pub cause: Option<String>,
  pub decision_task_completed_event_id: Option<i64>,
  pub identity: Option<String>,
}

impl CancelTimerFailedEventAttributes {
  pub fn new<F10, F20, F30, F40>(timer_id: F10, cause: F20, decision_task_completed_event_id: F30, identity: F40) -> CancelTimerFailedEventAttributes where F10: Into<Option<String>>, F20: Into<Option<String>>, F30: Into<Option<i64>>, F40: Into<Option<String>> {
    CancelTimerFailedEventAttributes {
      timer_id: timer_id.into(),
      cause: cause.into(),
      decision_task_completed_event_id: decision_task_completed_event_id.into(),
      identity: identity.into(),
    }
  }
}

impl TSerializable for CancelTimerFailedEventAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CancelTimerFailedEventAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<String> = None;
    let mut f_30: Option<i64> = None;
    let mut f_40: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_i64()?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_string()?;
          f_40 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CancelTimerFailedEventAttributes {
      timer_id: f_10,
      cause: f_20,
      decision_task_completed_event_id: f_30,
      identity: f_40,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CancelTimerFailedEventAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.timer_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("timerId", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cause {
      o_prot.write_field_begin(&TFieldIdentifier::new("cause", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.decision_task_completed_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("decisionTaskCompletedEventId", TType::I64, 30))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.identity {
      o_prot.write_field_begin(&TFieldIdentifier::new("identity", TType::String, 40))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowExecutionCancelRequestedEventAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WorkflowExecutionCancelRequestedEventAttributes {
  pub cause: Option<String>,
  pub external_initiated_event_id: Option<i64>,
  pub external_workflow_execution: Option<WorkflowExecution>,
  pub identity: Option<String>,
  pub request_id: Option<String>,
}

impl WorkflowExecutionCancelRequestedEventAttributes {
  pub fn new<F10, F20, F30, F40, F50>(cause: F10, external_initiated_event_id: F20, external_workflow_execution: F30, identity: F40, request_id: F50) -> WorkflowExecutionCancelRequestedEventAttributes where F10: Into<Option<String>>, F20: Into<Option<i64>>, F30: Into<Option<WorkflowExecution>>, F40: Into<Option<String>>, F50: Into<Option<String>> {
    WorkflowExecutionCancelRequestedEventAttributes {
      cause: cause.into(),
      external_initiated_event_id: external_initiated_event_id.into(),
      external_workflow_execution: external_workflow_execution.into(),
      identity: identity.into(),
      request_id: request_id.into(),
    }
  }
}

impl TSerializable for WorkflowExecutionCancelRequestedEventAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowExecutionCancelRequestedEventAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<i64> = None;
    let mut f_30: Option<WorkflowExecution> = None;
    let mut f_40: Option<String> = None;
    let mut f_50: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_i64()?;
          f_20 = Some(val);
        },
        30 => {
          let val = WorkflowExecution::read_from_in_protocol(i_prot)?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_string()?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_string()?;
          f_50 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowExecutionCancelRequestedEventAttributes {
      cause: f_10,
      external_initiated_event_id: f_20,
      external_workflow_execution: f_30,
      identity: f_40,
      request_id: f_50,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowExecutionCancelRequestedEventAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.cause {
      o_prot.write_field_begin(&TFieldIdentifier::new("cause", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.external_initiated_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("externalInitiatedEventId", TType::I64, 20))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.external_workflow_execution {
      o_prot.write_field_begin(&TFieldIdentifier::new("externalWorkflowExecution", TType::Struct, 30))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.identity {
      o_prot.write_field_begin(&TFieldIdentifier::new("identity", TType::String, 40))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.request_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 50))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowExecutionCanceledEventAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WorkflowExecutionCanceledEventAttributes {
  pub decision_task_completed_event_id: Option<i64>,
  pub details: Option<Vec<u8>>,
}

impl WorkflowExecutionCanceledEventAttributes {
  pub fn new<F10, F20>(decision_task_completed_event_id: F10, details: F20) -> WorkflowExecutionCanceledEventAttributes where F10: Into<Option<i64>>, F20: Into<Option<Vec<u8>>> {
    WorkflowExecutionCanceledEventAttributes {
      decision_task_completed_event_id: decision_task_completed_event_id.into(),
      details: details.into(),
    }
  }
}

impl TSerializable for WorkflowExecutionCanceledEventAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowExecutionCanceledEventAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<i64> = None;
    let mut f_20: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_i64()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_bytes()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowExecutionCanceledEventAttributes {
      decision_task_completed_event_id: f_10,
      details: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowExecutionCanceledEventAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.decision_task_completed_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("decisionTaskCompletedEventId", TType::I64, 10))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.details {
      o_prot.write_field_begin(&TFieldIdentifier::new("details", TType::String, 20))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// MarkerRecordedEventAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct MarkerRecordedEventAttributes {
  pub marker_name: Option<String>,
  pub details: Option<Vec<u8>>,
  pub decision_task_completed_event_id: Option<i64>,
  pub header: Option<Header>,
}

impl MarkerRecordedEventAttributes {
  pub fn new<F10, F20, F30, F40>(marker_name: F10, details: F20, decision_task_completed_event_id: F30, header: F40) -> MarkerRecordedEventAttributes where F10: Into<Option<String>>, F20: Into<Option<Vec<u8>>>, F30: Into<Option<i64>>, F40: Into<Option<Header>> {
    MarkerRecordedEventAttributes {
      marker_name: marker_name.into(),
      details: details.into(),
      decision_task_completed_event_id: decision_task_completed_event_id.into(),
      header: header.into(),
    }
  }
}

impl TSerializable for MarkerRecordedEventAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<MarkerRecordedEventAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<Vec<u8>> = None;
    let mut f_30: Option<i64> = None;
    let mut f_40: Option<Header> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_bytes()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_i64()?;
          f_30 = Some(val);
        },
        40 => {
          let val = Header::read_from_in_protocol(i_prot)?;
          f_40 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = MarkerRecordedEventAttributes {
      marker_name: f_10,
      details: f_20,
      decision_task_completed_event_id: f_30,
      header: f_40,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MarkerRecordedEventAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.marker_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("markerName", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.details {
      o_prot.write_field_begin(&TFieldIdentifier::new("details", TType::String, 20))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.decision_task_completed_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("decisionTaskCompletedEventId", TType::I64, 30))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.header {
      o_prot.write_field_begin(&TFieldIdentifier::new("header", TType::Struct, 40))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowExecutionSignaledEventAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WorkflowExecutionSignaledEventAttributes {
  pub signal_name: Option<String>,
  pub input: Option<Vec<u8>>,
  pub identity: Option<String>,
  pub request_id: Option<String>,
}

impl WorkflowExecutionSignaledEventAttributes {
  pub fn new<F10, F20, F30, F40>(signal_name: F10, input: F20, identity: F30, request_id: F40) -> WorkflowExecutionSignaledEventAttributes where F10: Into<Option<String>>, F20: Into<Option<Vec<u8>>>, F30: Into<Option<String>>, F40: Into<Option<String>> {
    WorkflowExecutionSignaledEventAttributes {
      signal_name: signal_name.into(),
      input: input.into(),
      identity: identity.into(),
      request_id: request_id.into(),
    }
  }
}

impl TSerializable for WorkflowExecutionSignaledEventAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowExecutionSignaledEventAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<Vec<u8>> = None;
    let mut f_30: Option<String> = None;
    let mut f_40: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_bytes()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_string()?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_string()?;
          f_40 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowExecutionSignaledEventAttributes {
      signal_name: f_10,
      input: f_20,
      identity: f_30,
      request_id: f_40,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowExecutionSignaledEventAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.signal_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("signalName", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.input {
      o_prot.write_field_begin(&TFieldIdentifier::new("input", TType::String, 20))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.identity {
      o_prot.write_field_begin(&TFieldIdentifier::new("identity", TType::String, 30))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.request_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 40))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowExecutionTerminatedEventAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WorkflowExecutionTerminatedEventAttributes {
  pub reason: Option<String>,
  pub details: Option<Vec<u8>>,
  pub identity: Option<String>,
}

impl WorkflowExecutionTerminatedEventAttributes {
  pub fn new<F10, F20, F30>(reason: F10, details: F20, identity: F30) -> WorkflowExecutionTerminatedEventAttributes where F10: Into<Option<String>>, F20: Into<Option<Vec<u8>>>, F30: Into<Option<String>> {
    WorkflowExecutionTerminatedEventAttributes {
      reason: reason.into(),
      details: details.into(),
      identity: identity.into(),
    }
  }
}

impl TSerializable for WorkflowExecutionTerminatedEventAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowExecutionTerminatedEventAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<Vec<u8>> = None;
    let mut f_30: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_bytes()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_string()?;
          f_30 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowExecutionTerminatedEventAttributes {
      reason: f_10,
      details: f_20,
      identity: f_30,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowExecutionTerminatedEventAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.reason {
      o_prot.write_field_begin(&TFieldIdentifier::new("reason", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.details {
      o_prot.write_field_begin(&TFieldIdentifier::new("details", TType::String, 20))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.identity {
      o_prot.write_field_begin(&TFieldIdentifier::new("identity", TType::String, 30))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// RequestCancelExternalWorkflowExecutionInitiatedEventAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RequestCancelExternalWorkflowExecutionInitiatedEventAttributes {
  pub decision_task_completed_event_id: Option<i64>,
  pub domain: Option<String>,
  pub workflow_execution: Option<WorkflowExecution>,
  pub control: Option<Vec<u8>>,
  pub child_workflow_only: Option<bool>,
}

impl RequestCancelExternalWorkflowExecutionInitiatedEventAttributes {
  pub fn new<F10, F20, F30, F40, F50>(decision_task_completed_event_id: F10, domain: F20, workflow_execution: F30, control: F40, child_workflow_only: F50) -> RequestCancelExternalWorkflowExecutionInitiatedEventAttributes where F10: Into<Option<i64>>, F20: Into<Option<String>>, F30: Into<Option<WorkflowExecution>>, F40: Into<Option<Vec<u8>>>, F50: Into<Option<bool>> {
    RequestCancelExternalWorkflowExecutionInitiatedEventAttributes {
      decision_task_completed_event_id: decision_task_completed_event_id.into(),
      domain: domain.into(),
      workflow_execution: workflow_execution.into(),
      control: control.into(),
      child_workflow_only: child_workflow_only.into(),
    }
  }
}

impl TSerializable for RequestCancelExternalWorkflowExecutionInitiatedEventAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RequestCancelExternalWorkflowExecutionInitiatedEventAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<i64> = None;
    let mut f_20: Option<String> = None;
    let mut f_30: Option<WorkflowExecution> = None;
    let mut f_40: Option<Vec<u8>> = None;
    let mut f_50: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_i64()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        30 => {
          let val = WorkflowExecution::read_from_in_protocol(i_prot)?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_bytes()?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_bool()?;
          f_50 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RequestCancelExternalWorkflowExecutionInitiatedEventAttributes {
      decision_task_completed_event_id: f_10,
      domain: f_20,
      workflow_execution: f_30,
      control: f_40,
      child_workflow_only: f_50,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RequestCancelExternalWorkflowExecutionInitiatedEventAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.decision_task_completed_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("decisionTaskCompletedEventId", TType::I64, 10))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_execution {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecution", TType::Struct, 30))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.control {
      o_prot.write_field_begin(&TFieldIdentifier::new("control", TType::String, 40))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.child_workflow_only {
      o_prot.write_field_begin(&TFieldIdentifier::new("childWorkflowOnly", TType::Bool, 50))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// RequestCancelExternalWorkflowExecutionFailedEventAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RequestCancelExternalWorkflowExecutionFailedEventAttributes {
  pub cause: Option<CancelExternalWorkflowExecutionFailedCause>,
  pub decision_task_completed_event_id: Option<i64>,
  pub domain: Option<String>,
  pub workflow_execution: Option<WorkflowExecution>,
  pub initiated_event_id: Option<i64>,
  pub control: Option<Vec<u8>>,
}

impl RequestCancelExternalWorkflowExecutionFailedEventAttributes {
  pub fn new<F10, F20, F30, F40, F50, F60>(cause: F10, decision_task_completed_event_id: F20, domain: F30, workflow_execution: F40, initiated_event_id: F50, control: F60) -> RequestCancelExternalWorkflowExecutionFailedEventAttributes where F10: Into<Option<CancelExternalWorkflowExecutionFailedCause>>, F20: Into<Option<i64>>, F30: Into<Option<String>>, F40: Into<Option<WorkflowExecution>>, F50: Into<Option<i64>>, F60: Into<Option<Vec<u8>>> {
    RequestCancelExternalWorkflowExecutionFailedEventAttributes {
      cause: cause.into(),
      decision_task_completed_event_id: decision_task_completed_event_id.into(),
      domain: domain.into(),
      workflow_execution: workflow_execution.into(),
      initiated_event_id: initiated_event_id.into(),
      control: control.into(),
    }
  }
}

impl TSerializable for RequestCancelExternalWorkflowExecutionFailedEventAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RequestCancelExternalWorkflowExecutionFailedEventAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<CancelExternalWorkflowExecutionFailedCause> = None;
    let mut f_20: Option<i64> = None;
    let mut f_30: Option<String> = None;
    let mut f_40: Option<WorkflowExecution> = None;
    let mut f_50: Option<i64> = None;
    let mut f_60: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = CancelExternalWorkflowExecutionFailedCause::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_i64()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_string()?;
          f_30 = Some(val);
        },
        40 => {
          let val = WorkflowExecution::read_from_in_protocol(i_prot)?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_i64()?;
          f_50 = Some(val);
        },
        60 => {
          let val = i_prot.read_bytes()?;
          f_60 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RequestCancelExternalWorkflowExecutionFailedEventAttributes {
      cause: f_10,
      decision_task_completed_event_id: f_20,
      domain: f_30,
      workflow_execution: f_40,
      initiated_event_id: f_50,
      control: f_60,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RequestCancelExternalWorkflowExecutionFailedEventAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.cause {
      o_prot.write_field_begin(&TFieldIdentifier::new("cause", TType::I32, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.decision_task_completed_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("decisionTaskCompletedEventId", TType::I64, 20))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 30))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_execution {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecution", TType::Struct, 40))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.initiated_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("initiatedEventId", TType::I64, 50))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.control {
      o_prot.write_field_begin(&TFieldIdentifier::new("control", TType::String, 60))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ExternalWorkflowExecutionCancelRequestedEventAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ExternalWorkflowExecutionCancelRequestedEventAttributes {
  pub initiated_event_id: Option<i64>,
  pub domain: Option<String>,
  pub workflow_execution: Option<WorkflowExecution>,
}

impl ExternalWorkflowExecutionCancelRequestedEventAttributes {
  pub fn new<F10, F20, F30>(initiated_event_id: F10, domain: F20, workflow_execution: F30) -> ExternalWorkflowExecutionCancelRequestedEventAttributes where F10: Into<Option<i64>>, F20: Into<Option<String>>, F30: Into<Option<WorkflowExecution>> {
    ExternalWorkflowExecutionCancelRequestedEventAttributes {
      initiated_event_id: initiated_event_id.into(),
      domain: domain.into(),
      workflow_execution: workflow_execution.into(),
    }
  }
}

impl TSerializable for ExternalWorkflowExecutionCancelRequestedEventAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ExternalWorkflowExecutionCancelRequestedEventAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<i64> = None;
    let mut f_20: Option<String> = None;
    let mut f_30: Option<WorkflowExecution> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_i64()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        30 => {
          let val = WorkflowExecution::read_from_in_protocol(i_prot)?;
          f_30 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ExternalWorkflowExecutionCancelRequestedEventAttributes {
      initiated_event_id: f_10,
      domain: f_20,
      workflow_execution: f_30,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ExternalWorkflowExecutionCancelRequestedEventAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.initiated_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("initiatedEventId", TType::I64, 10))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_execution {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecution", TType::Struct, 30))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SignalExternalWorkflowExecutionInitiatedEventAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SignalExternalWorkflowExecutionInitiatedEventAttributes {
  pub decision_task_completed_event_id: Option<i64>,
  pub domain: Option<String>,
  pub workflow_execution: Option<WorkflowExecution>,
  pub signal_name: Option<String>,
  pub input: Option<Vec<u8>>,
  pub control: Option<Vec<u8>>,
  pub child_workflow_only: Option<bool>,
}

impl SignalExternalWorkflowExecutionInitiatedEventAttributes {
  pub fn new<F10, F20, F30, F40, F50, F60, F70>(decision_task_completed_event_id: F10, domain: F20, workflow_execution: F30, signal_name: F40, input: F50, control: F60, child_workflow_only: F70) -> SignalExternalWorkflowExecutionInitiatedEventAttributes where F10: Into<Option<i64>>, F20: Into<Option<String>>, F30: Into<Option<WorkflowExecution>>, F40: Into<Option<String>>, F50: Into<Option<Vec<u8>>>, F60: Into<Option<Vec<u8>>>, F70: Into<Option<bool>> {
    SignalExternalWorkflowExecutionInitiatedEventAttributes {
      decision_task_completed_event_id: decision_task_completed_event_id.into(),
      domain: domain.into(),
      workflow_execution: workflow_execution.into(),
      signal_name: signal_name.into(),
      input: input.into(),
      control: control.into(),
      child_workflow_only: child_workflow_only.into(),
    }
  }
}

impl TSerializable for SignalExternalWorkflowExecutionInitiatedEventAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SignalExternalWorkflowExecutionInitiatedEventAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<i64> = None;
    let mut f_20: Option<String> = None;
    let mut f_30: Option<WorkflowExecution> = None;
    let mut f_40: Option<String> = None;
    let mut f_50: Option<Vec<u8>> = None;
    let mut f_60: Option<Vec<u8>> = None;
    let mut f_70: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_i64()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        30 => {
          let val = WorkflowExecution::read_from_in_protocol(i_prot)?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_string()?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_bytes()?;
          f_50 = Some(val);
        },
        60 => {
          let val = i_prot.read_bytes()?;
          f_60 = Some(val);
        },
        70 => {
          let val = i_prot.read_bool()?;
          f_70 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SignalExternalWorkflowExecutionInitiatedEventAttributes {
      decision_task_completed_event_id: f_10,
      domain: f_20,
      workflow_execution: f_30,
      signal_name: f_40,
      input: f_50,
      control: f_60,
      child_workflow_only: f_70,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SignalExternalWorkflowExecutionInitiatedEventAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.decision_task_completed_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("decisionTaskCompletedEventId", TType::I64, 10))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_execution {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecution", TType::Struct, 30))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.signal_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("signalName", TType::String, 40))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.input {
      o_prot.write_field_begin(&TFieldIdentifier::new("input", TType::String, 50))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.control {
      o_prot.write_field_begin(&TFieldIdentifier::new("control", TType::String, 60))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.child_workflow_only {
      o_prot.write_field_begin(&TFieldIdentifier::new("childWorkflowOnly", TType::Bool, 70))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SignalExternalWorkflowExecutionFailedEventAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SignalExternalWorkflowExecutionFailedEventAttributes {
  pub cause: Option<SignalExternalWorkflowExecutionFailedCause>,
  pub decision_task_completed_event_id: Option<i64>,
  pub domain: Option<String>,
  pub workflow_execution: Option<WorkflowExecution>,
  pub initiated_event_id: Option<i64>,
  pub control: Option<Vec<u8>>,
}

impl SignalExternalWorkflowExecutionFailedEventAttributes {
  pub fn new<F10, F20, F30, F40, F50, F60>(cause: F10, decision_task_completed_event_id: F20, domain: F30, workflow_execution: F40, initiated_event_id: F50, control: F60) -> SignalExternalWorkflowExecutionFailedEventAttributes where F10: Into<Option<SignalExternalWorkflowExecutionFailedCause>>, F20: Into<Option<i64>>, F30: Into<Option<String>>, F40: Into<Option<WorkflowExecution>>, F50: Into<Option<i64>>, F60: Into<Option<Vec<u8>>> {
    SignalExternalWorkflowExecutionFailedEventAttributes {
      cause: cause.into(),
      decision_task_completed_event_id: decision_task_completed_event_id.into(),
      domain: domain.into(),
      workflow_execution: workflow_execution.into(),
      initiated_event_id: initiated_event_id.into(),
      control: control.into(),
    }
  }
}

impl TSerializable for SignalExternalWorkflowExecutionFailedEventAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SignalExternalWorkflowExecutionFailedEventAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<SignalExternalWorkflowExecutionFailedCause> = None;
    let mut f_20: Option<i64> = None;
    let mut f_30: Option<String> = None;
    let mut f_40: Option<WorkflowExecution> = None;
    let mut f_50: Option<i64> = None;
    let mut f_60: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = SignalExternalWorkflowExecutionFailedCause::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_i64()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_string()?;
          f_30 = Some(val);
        },
        40 => {
          let val = WorkflowExecution::read_from_in_protocol(i_prot)?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_i64()?;
          f_50 = Some(val);
        },
        60 => {
          let val = i_prot.read_bytes()?;
          f_60 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SignalExternalWorkflowExecutionFailedEventAttributes {
      cause: f_10,
      decision_task_completed_event_id: f_20,
      domain: f_30,
      workflow_execution: f_40,
      initiated_event_id: f_50,
      control: f_60,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SignalExternalWorkflowExecutionFailedEventAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.cause {
      o_prot.write_field_begin(&TFieldIdentifier::new("cause", TType::I32, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.decision_task_completed_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("decisionTaskCompletedEventId", TType::I64, 20))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 30))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_execution {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecution", TType::Struct, 40))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.initiated_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("initiatedEventId", TType::I64, 50))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.control {
      o_prot.write_field_begin(&TFieldIdentifier::new("control", TType::String, 60))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ExternalWorkflowExecutionSignaledEventAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ExternalWorkflowExecutionSignaledEventAttributes {
  pub initiated_event_id: Option<i64>,
  pub domain: Option<String>,
  pub workflow_execution: Option<WorkflowExecution>,
  pub control: Option<Vec<u8>>,
}

impl ExternalWorkflowExecutionSignaledEventAttributes {
  pub fn new<F10, F20, F30, F40>(initiated_event_id: F10, domain: F20, workflow_execution: F30, control: F40) -> ExternalWorkflowExecutionSignaledEventAttributes where F10: Into<Option<i64>>, F20: Into<Option<String>>, F30: Into<Option<WorkflowExecution>>, F40: Into<Option<Vec<u8>>> {
    ExternalWorkflowExecutionSignaledEventAttributes {
      initiated_event_id: initiated_event_id.into(),
      domain: domain.into(),
      workflow_execution: workflow_execution.into(),
      control: control.into(),
    }
  }
}

impl TSerializable for ExternalWorkflowExecutionSignaledEventAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ExternalWorkflowExecutionSignaledEventAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<i64> = None;
    let mut f_20: Option<String> = None;
    let mut f_30: Option<WorkflowExecution> = None;
    let mut f_40: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_i64()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        30 => {
          let val = WorkflowExecution::read_from_in_protocol(i_prot)?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_bytes()?;
          f_40 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ExternalWorkflowExecutionSignaledEventAttributes {
      initiated_event_id: f_10,
      domain: f_20,
      workflow_execution: f_30,
      control: f_40,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ExternalWorkflowExecutionSignaledEventAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.initiated_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("initiatedEventId", TType::I64, 10))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_execution {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecution", TType::Struct, 30))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.control {
      o_prot.write_field_begin(&TFieldIdentifier::new("control", TType::String, 40))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// UpsertWorkflowSearchAttributesEventAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct UpsertWorkflowSearchAttributesEventAttributes {
  pub decision_task_completed_event_id: Option<i64>,
  pub search_attributes: Option<SearchAttributes>,
}

impl UpsertWorkflowSearchAttributesEventAttributes {
  pub fn new<F10, F20>(decision_task_completed_event_id: F10, search_attributes: F20) -> UpsertWorkflowSearchAttributesEventAttributes where F10: Into<Option<i64>>, F20: Into<Option<SearchAttributes>> {
    UpsertWorkflowSearchAttributesEventAttributes {
      decision_task_completed_event_id: decision_task_completed_event_id.into(),
      search_attributes: search_attributes.into(),
    }
  }
}

impl TSerializable for UpsertWorkflowSearchAttributesEventAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UpsertWorkflowSearchAttributesEventAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<i64> = None;
    let mut f_20: Option<SearchAttributes> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_i64()?;
          f_10 = Some(val);
        },
        20 => {
          let val = SearchAttributes::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = UpsertWorkflowSearchAttributesEventAttributes {
      decision_task_completed_event_id: f_10,
      search_attributes: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UpsertWorkflowSearchAttributesEventAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.decision_task_completed_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("decisionTaskCompletedEventId", TType::I64, 10))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.search_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("searchAttributes", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// StartChildWorkflowExecutionInitiatedEventAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct StartChildWorkflowExecutionInitiatedEventAttributes {
  pub domain: Option<String>,
  pub workflow_id: Option<String>,
  pub workflow_type: Option<WorkflowType>,
  pub task_list: Option<TaskList>,
  pub input: Option<Vec<u8>>,
  pub execution_start_to_close_timeout_seconds: Option<i32>,
  pub task_start_to_close_timeout_seconds: Option<i32>,
  pub parent_close_policy: Option<ParentClosePolicy>,
  pub control: Option<Vec<u8>>,
  pub decision_task_completed_event_id: Option<i64>,
  pub workflow_id_reuse_policy: Option<WorkflowIdReusePolicy>,
  pub retry_policy: Option<Box<RetryPolicy>>,
  pub cron_schedule: Option<String>,
  pub header: Option<Header>,
  pub memo: Option<Memo>,
  pub search_attributes: Option<SearchAttributes>,
  pub delay_start_seconds: Option<i32>,
  pub jitter_start_seconds: Option<i32>,
  pub first_run_at_timestamp: Option<i64>,
  pub cron_overlap_policy: Option<CronOverlapPolicy>,
  pub active_cluster_selection_policy: Option<Box<ActiveClusterSelectionPolicy>>,
}

impl StartChildWorkflowExecutionInitiatedEventAttributes {
  pub fn new<F10, F20, F30, F40, F50, F60, F70, F81, F90, F100, F110, F120, F130, F140, F150, F160, F170, F180, F190, F200, F210>(domain: F10, workflow_id: F20, workflow_type: F30, task_list: F40, input: F50, execution_start_to_close_timeout_seconds: F60, task_start_to_close_timeout_seconds: F70, parent_close_policy: F81, control: F90, decision_task_completed_event_id: F100, workflow_id_reuse_policy: F110, retry_policy: F120, cron_schedule: F130, header: F140, memo: F150, search_attributes: F160, delay_start_seconds: F170, jitter_start_seconds: F180, first_run_at_timestamp: F190, cron_overlap_policy: F200, active_cluster_selection_policy: F210) -> StartChildWorkflowExecutionInitiatedEventAttributes where F10: Into<Option<String>>, F20: Into<Option<String>>, F30: Into<Option<WorkflowType>>, F40: Into<Option<TaskList>>, F50: Into<Option<Vec<u8>>>, F60: Into<Option<i32>>, F70: Into<Option<i32>>, F81: Into<Option<ParentClosePolicy>>, F90: Into<Option<Vec<u8>>>, F100: Into<Option<i64>>, F110: Into<Option<WorkflowIdReusePolicy>>, F120: Into<Option<Box<RetryPolicy>>>, F130: Into<Option<String>>, F140: Into<Option<Header>>, F150: Into<Option<Memo>>, F160: Into<Option<SearchAttributes>>, F170: Into<Option<i32>>, F180: Into<Option<i32>>, F190: Into<Option<i64>>, F200: Into<Option<CronOverlapPolicy>>, F210: Into<Option<Box<ActiveClusterSelectionPolicy>>> {
    StartChildWorkflowExecutionInitiatedEventAttributes {
      domain: domain.into(),
      workflow_id: workflow_id.into(),
      workflow_type: workflow_type.into(),
      task_list: task_list.into(),
      input: input.into(),
      execution_start_to_close_timeout_seconds: execution_start_to_close_timeout_seconds.into(),
      task_start_to_close_timeout_seconds: task_start_to_close_timeout_seconds.into(),
      parent_close_policy: parent_close_policy.into(),
      control: control.into(),
      decision_task_completed_event_id: decision_task_completed_event_id.into(),
      workflow_id_reuse_policy: workflow_id_reuse_policy.into(),
      retry_policy: retry_policy.into(),
      cron_schedule: cron_schedule.into(),
      header: header.into(),
      memo: memo.into(),
      search_attributes: search_attributes.into(),
      delay_start_seconds: delay_start_seconds.into(),
      jitter_start_seconds: jitter_start_seconds.into(),
      first_run_at_timestamp: first_run_at_timestamp.into(),
      cron_overlap_policy: cron_overlap_policy.into(),
      active_cluster_selection_policy: active_cluster_selection_policy.into(),
    }
  }
}

impl TSerializable for StartChildWorkflowExecutionInitiatedEventAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<StartChildWorkflowExecutionInitiatedEventAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<String> = None;
    let mut f_30: Option<WorkflowType> = None;
    let mut f_40: Option<TaskList> = None;
    let mut f_50: Option<Vec<u8>> = None;
    let mut f_60: Option<i32> = None;
    let mut f_70: Option<i32> = None;
    let mut f_81: Option<ParentClosePolicy> = None;
    let mut f_90: Option<Vec<u8>> = None;
    let mut f_100: Option<i64> = None;
    let mut f_110: Option<WorkflowIdReusePolicy> = None;
    let mut f_120: Option<Box<RetryPolicy>> = None;
    let mut f_130: Option<String> = None;
    let mut f_140: Option<Header> = None;
    let mut f_150: Option<Memo> = None;
    let mut f_160: Option<SearchAttributes> = None;
    let mut f_170: Option<i32> = None;
    let mut f_180: Option<i32> = None;
    let mut f_190: Option<i64> = None;
    let mut f_200: Option<CronOverlapPolicy> = None;
    let mut f_210: Option<Box<ActiveClusterSelectionPolicy>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        30 => {
          let val = WorkflowType::read_from_in_protocol(i_prot)?;
          f_30 = Some(val);
        },
        40 => {
          let val = TaskList::read_from_in_protocol(i_prot)?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_bytes()?;
          f_50 = Some(val);
        },
        60 => {
          let val = i_prot.read_i32()?;
          f_60 = Some(val);
        },
        70 => {
          let val = i_prot.read_i32()?;
          f_70 = Some(val);
        },
        81 => {
          let val = ParentClosePolicy::read_from_in_protocol(i_prot)?;
          f_81 = Some(val);
        },
        90 => {
          let val = i_prot.read_bytes()?;
          f_90 = Some(val);
        },
        100 => {
          let val = i_prot.read_i64()?;
          f_100 = Some(val);
        },
        110 => {
          let val = WorkflowIdReusePolicy::read_from_in_protocol(i_prot)?;
          f_110 = Some(val);
        },
        120 => {
          let val = Box::new(RetryPolicy::read_from_in_protocol(i_prot)?);
          f_120 = Some(val);
        },
        130 => {
          let val = i_prot.read_string()?;
          f_130 = Some(val);
        },
        140 => {
          let val = Header::read_from_in_protocol(i_prot)?;
          f_140 = Some(val);
        },
        150 => {
          let val = Memo::read_from_in_protocol(i_prot)?;
          f_150 = Some(val);
        },
        160 => {
          let val = SearchAttributes::read_from_in_protocol(i_prot)?;
          f_160 = Some(val);
        },
        170 => {
          let val = i_prot.read_i32()?;
          f_170 = Some(val);
        },
        180 => {
          let val = i_prot.read_i32()?;
          f_180 = Some(val);
        },
        190 => {
          let val = i_prot.read_i64()?;
          f_190 = Some(val);
        },
        200 => {
          let val = CronOverlapPolicy::read_from_in_protocol(i_prot)?;
          f_200 = Some(val);
        },
        210 => {
          let val = Box::new(ActiveClusterSelectionPolicy::read_from_in_protocol(i_prot)?);
          f_210 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = StartChildWorkflowExecutionInitiatedEventAttributes {
      domain: f_10,
      workflow_id: f_20,
      workflow_type: f_30,
      task_list: f_40,
      input: f_50,
      execution_start_to_close_timeout_seconds: f_60,
      task_start_to_close_timeout_seconds: f_70,
      parent_close_policy: f_81,
      control: f_90,
      decision_task_completed_event_id: f_100,
      workflow_id_reuse_policy: f_110,
      retry_policy: f_120,
      cron_schedule: f_130,
      header: f_140,
      memo: f_150,
      search_attributes: f_160,
      delay_start_seconds: f_170,
      jitter_start_seconds: f_180,
      first_run_at_timestamp: f_190,
      cron_overlap_policy: f_200,
      active_cluster_selection_policy: f_210,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("StartChildWorkflowExecutionInitiatedEventAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowId", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowType", TType::Struct, 30))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.task_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskList", TType::Struct, 40))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.input {
      o_prot.write_field_begin(&TFieldIdentifier::new("input", TType::String, 50))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.execution_start_to_close_timeout_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("executionStartToCloseTimeoutSeconds", TType::I32, 60))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.task_start_to_close_timeout_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskStartToCloseTimeoutSeconds", TType::I32, 70))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.parent_close_policy {
      o_prot.write_field_begin(&TFieldIdentifier::new("parentClosePolicy", TType::I32, 81))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.control {
      o_prot.write_field_begin(&TFieldIdentifier::new("control", TType::String, 90))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.decision_task_completed_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("decisionTaskCompletedEventId", TType::I64, 100))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_id_reuse_policy {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowIdReusePolicy", TType::I32, 110))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.retry_policy {
      o_prot.write_field_begin(&TFieldIdentifier::new("retryPolicy", TType::Struct, 120))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cron_schedule {
      o_prot.write_field_begin(&TFieldIdentifier::new("cronSchedule", TType::String, 130))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.header {
      o_prot.write_field_begin(&TFieldIdentifier::new("header", TType::Struct, 140))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.memo {
      o_prot.write_field_begin(&TFieldIdentifier::new("memo", TType::Struct, 150))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.search_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("searchAttributes", TType::Struct, 160))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.delay_start_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("delayStartSeconds", TType::I32, 170))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.jitter_start_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("jitterStartSeconds", TType::I32, 180))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.first_run_at_timestamp {
      o_prot.write_field_begin(&TFieldIdentifier::new("firstRunAtTimestamp", TType::I64, 190))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cron_overlap_policy {
      o_prot.write_field_begin(&TFieldIdentifier::new("cronOverlapPolicy", TType::I32, 200))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.active_cluster_selection_policy {
      o_prot.write_field_begin(&TFieldIdentifier::new("activeClusterSelectionPolicy", TType::Struct, 210))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// StartChildWorkflowExecutionFailedEventAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct StartChildWorkflowExecutionFailedEventAttributes {
  pub domain: Option<String>,
  pub workflow_id: Option<String>,
  pub workflow_type: Option<WorkflowType>,
  pub cause: Option<ChildWorkflowExecutionFailedCause>,
  pub control: Option<Vec<u8>>,
  pub initiated_event_id: Option<i64>,
  pub decision_task_completed_event_id: Option<i64>,
}

impl StartChildWorkflowExecutionFailedEventAttributes {
  pub fn new<F10, F20, F30, F40, F50, F60, F70>(domain: F10, workflow_id: F20, workflow_type: F30, cause: F40, control: F50, initiated_event_id: F60, decision_task_completed_event_id: F70) -> StartChildWorkflowExecutionFailedEventAttributes where F10: Into<Option<String>>, F20: Into<Option<String>>, F30: Into<Option<WorkflowType>>, F40: Into<Option<ChildWorkflowExecutionFailedCause>>, F50: Into<Option<Vec<u8>>>, F60: Into<Option<i64>>, F70: Into<Option<i64>> {
    StartChildWorkflowExecutionFailedEventAttributes {
      domain: domain.into(),
      workflow_id: workflow_id.into(),
      workflow_type: workflow_type.into(),
      cause: cause.into(),
      control: control.into(),
      initiated_event_id: initiated_event_id.into(),
      decision_task_completed_event_id: decision_task_completed_event_id.into(),
    }
  }
}

impl TSerializable for StartChildWorkflowExecutionFailedEventAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<StartChildWorkflowExecutionFailedEventAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<String> = None;
    let mut f_30: Option<WorkflowType> = None;
    let mut f_40: Option<ChildWorkflowExecutionFailedCause> = None;
    let mut f_50: Option<Vec<u8>> = None;
    let mut f_60: Option<i64> = None;
    let mut f_70: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        30 => {
          let val = WorkflowType::read_from_in_protocol(i_prot)?;
          f_30 = Some(val);
        },
        40 => {
          let val = ChildWorkflowExecutionFailedCause::read_from_in_protocol(i_prot)?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_bytes()?;
          f_50 = Some(val);
        },
        60 => {
          let val = i_prot.read_i64()?;
          f_60 = Some(val);
        },
        70 => {
          let val = i_prot.read_i64()?;
          f_70 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = StartChildWorkflowExecutionFailedEventAttributes {
      domain: f_10,
      workflow_id: f_20,
      workflow_type: f_30,
      cause: f_40,
      control: f_50,
      initiated_event_id: f_60,
      decision_task_completed_event_id: f_70,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("StartChildWorkflowExecutionFailedEventAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowId", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowType", TType::Struct, 30))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cause {
      o_prot.write_field_begin(&TFieldIdentifier::new("cause", TType::I32, 40))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.control {
      o_prot.write_field_begin(&TFieldIdentifier::new("control", TType::String, 50))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.initiated_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("initiatedEventId", TType::I64, 60))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.decision_task_completed_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("decisionTaskCompletedEventId", TType::I64, 70))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChildWorkflowExecutionStartedEventAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ChildWorkflowExecutionStartedEventAttributes {
  pub domain: Option<String>,
  pub initiated_event_id: Option<i64>,
  pub workflow_execution: Option<WorkflowExecution>,
  pub workflow_type: Option<WorkflowType>,
  pub header: Option<Header>,
}

impl ChildWorkflowExecutionStartedEventAttributes {
  pub fn new<F10, F20, F30, F40, F50>(domain: F10, initiated_event_id: F20, workflow_execution: F30, workflow_type: F40, header: F50) -> ChildWorkflowExecutionStartedEventAttributes where F10: Into<Option<String>>, F20: Into<Option<i64>>, F30: Into<Option<WorkflowExecution>>, F40: Into<Option<WorkflowType>>, F50: Into<Option<Header>> {
    ChildWorkflowExecutionStartedEventAttributes {
      domain: domain.into(),
      initiated_event_id: initiated_event_id.into(),
      workflow_execution: workflow_execution.into(),
      workflow_type: workflow_type.into(),
      header: header.into(),
    }
  }
}

impl TSerializable for ChildWorkflowExecutionStartedEventAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChildWorkflowExecutionStartedEventAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<i64> = None;
    let mut f_30: Option<WorkflowExecution> = None;
    let mut f_40: Option<WorkflowType> = None;
    let mut f_50: Option<Header> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_i64()?;
          f_20 = Some(val);
        },
        30 => {
          let val = WorkflowExecution::read_from_in_protocol(i_prot)?;
          f_30 = Some(val);
        },
        40 => {
          let val = WorkflowType::read_from_in_protocol(i_prot)?;
          f_40 = Some(val);
        },
        50 => {
          let val = Header::read_from_in_protocol(i_prot)?;
          f_50 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChildWorkflowExecutionStartedEventAttributes {
      domain: f_10,
      initiated_event_id: f_20,
      workflow_execution: f_30,
      workflow_type: f_40,
      header: f_50,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChildWorkflowExecutionStartedEventAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.initiated_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("initiatedEventId", TType::I64, 20))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_execution {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecution", TType::Struct, 30))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowType", TType::Struct, 40))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.header {
      o_prot.write_field_begin(&TFieldIdentifier::new("header", TType::Struct, 50))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChildWorkflowExecutionCompletedEventAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ChildWorkflowExecutionCompletedEventAttributes {
  pub result: Option<Vec<u8>>,
  pub domain: Option<String>,
  pub workflow_execution: Option<WorkflowExecution>,
  pub workflow_type: Option<WorkflowType>,
  pub initiated_event_id: Option<i64>,
  pub started_event_id: Option<i64>,
}

impl ChildWorkflowExecutionCompletedEventAttributes {
  pub fn new<F10, F20, F30, F40, F50, F60>(result: F10, domain: F20, workflow_execution: F30, workflow_type: F40, initiated_event_id: F50, started_event_id: F60) -> ChildWorkflowExecutionCompletedEventAttributes where F10: Into<Option<Vec<u8>>>, F20: Into<Option<String>>, F30: Into<Option<WorkflowExecution>>, F40: Into<Option<WorkflowType>>, F50: Into<Option<i64>>, F60: Into<Option<i64>> {
    ChildWorkflowExecutionCompletedEventAttributes {
      result: result.into(),
      domain: domain.into(),
      workflow_execution: workflow_execution.into(),
      workflow_type: workflow_type.into(),
      initiated_event_id: initiated_event_id.into(),
      started_event_id: started_event_id.into(),
    }
  }
}

impl TSerializable for ChildWorkflowExecutionCompletedEventAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChildWorkflowExecutionCompletedEventAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<Vec<u8>> = None;
    let mut f_20: Option<String> = None;
    let mut f_30: Option<WorkflowExecution> = None;
    let mut f_40: Option<WorkflowType> = None;
    let mut f_50: Option<i64> = None;
    let mut f_60: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_bytes()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        30 => {
          let val = WorkflowExecution::read_from_in_protocol(i_prot)?;
          f_30 = Some(val);
        },
        40 => {
          let val = WorkflowType::read_from_in_protocol(i_prot)?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_i64()?;
          f_50 = Some(val);
        },
        60 => {
          let val = i_prot.read_i64()?;
          f_60 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChildWorkflowExecutionCompletedEventAttributes {
      result: f_10,
      domain: f_20,
      workflow_execution: f_30,
      workflow_type: f_40,
      initiated_event_id: f_50,
      started_event_id: f_60,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChildWorkflowExecutionCompletedEventAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result {
      o_prot.write_field_begin(&TFieldIdentifier::new("result", TType::String, 10))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_execution {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecution", TType::Struct, 30))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowType", TType::Struct, 40))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.initiated_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("initiatedEventId", TType::I64, 50))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.started_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("startedEventId", TType::I64, 60))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChildWorkflowExecutionFailedEventAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ChildWorkflowExecutionFailedEventAttributes {
  pub reason: Option<String>,
  pub details: Option<Vec<u8>>,
  pub domain: Option<String>,
  pub workflow_execution: Option<WorkflowExecution>,
  pub workflow_type: Option<WorkflowType>,
  pub initiated_event_id: Option<i64>,
  pub started_event_id: Option<i64>,
}

impl ChildWorkflowExecutionFailedEventAttributes {
  pub fn new<F10, F20, F30, F40, F50, F60, F70>(reason: F10, details: F20, domain: F30, workflow_execution: F40, workflow_type: F50, initiated_event_id: F60, started_event_id: F70) -> ChildWorkflowExecutionFailedEventAttributes where F10: Into<Option<String>>, F20: Into<Option<Vec<u8>>>, F30: Into<Option<String>>, F40: Into<Option<WorkflowExecution>>, F50: Into<Option<WorkflowType>>, F60: Into<Option<i64>>, F70: Into<Option<i64>> {
    ChildWorkflowExecutionFailedEventAttributes {
      reason: reason.into(),
      details: details.into(),
      domain: domain.into(),
      workflow_execution: workflow_execution.into(),
      workflow_type: workflow_type.into(),
      initiated_event_id: initiated_event_id.into(),
      started_event_id: started_event_id.into(),
    }
  }
}

impl TSerializable for ChildWorkflowExecutionFailedEventAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChildWorkflowExecutionFailedEventAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<Vec<u8>> = None;
    let mut f_30: Option<String> = None;
    let mut f_40: Option<WorkflowExecution> = None;
    let mut f_50: Option<WorkflowType> = None;
    let mut f_60: Option<i64> = None;
    let mut f_70: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_bytes()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_string()?;
          f_30 = Some(val);
        },
        40 => {
          let val = WorkflowExecution::read_from_in_protocol(i_prot)?;
          f_40 = Some(val);
        },
        50 => {
          let val = WorkflowType::read_from_in_protocol(i_prot)?;
          f_50 = Some(val);
        },
        60 => {
          let val = i_prot.read_i64()?;
          f_60 = Some(val);
        },
        70 => {
          let val = i_prot.read_i64()?;
          f_70 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChildWorkflowExecutionFailedEventAttributes {
      reason: f_10,
      details: f_20,
      domain: f_30,
      workflow_execution: f_40,
      workflow_type: f_50,
      initiated_event_id: f_60,
      started_event_id: f_70,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChildWorkflowExecutionFailedEventAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.reason {
      o_prot.write_field_begin(&TFieldIdentifier::new("reason", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.details {
      o_prot.write_field_begin(&TFieldIdentifier::new("details", TType::String, 20))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 30))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_execution {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecution", TType::Struct, 40))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowType", TType::Struct, 50))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.initiated_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("initiatedEventId", TType::I64, 60))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.started_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("startedEventId", TType::I64, 70))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChildWorkflowExecutionCanceledEventAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ChildWorkflowExecutionCanceledEventAttributes {
  pub details: Option<Vec<u8>>,
  pub domain: Option<String>,
  pub workflow_execution: Option<WorkflowExecution>,
  pub workflow_type: Option<WorkflowType>,
  pub initiated_event_id: Option<i64>,
  pub started_event_id: Option<i64>,
}

impl ChildWorkflowExecutionCanceledEventAttributes {
  pub fn new<F10, F20, F30, F40, F50, F60>(details: F10, domain: F20, workflow_execution: F30, workflow_type: F40, initiated_event_id: F50, started_event_id: F60) -> ChildWorkflowExecutionCanceledEventAttributes where F10: Into<Option<Vec<u8>>>, F20: Into<Option<String>>, F30: Into<Option<WorkflowExecution>>, F40: Into<Option<WorkflowType>>, F50: Into<Option<i64>>, F60: Into<Option<i64>> {
    ChildWorkflowExecutionCanceledEventAttributes {
      details: details.into(),
      domain: domain.into(),
      workflow_execution: workflow_execution.into(),
      workflow_type: workflow_type.into(),
      initiated_event_id: initiated_event_id.into(),
      started_event_id: started_event_id.into(),
    }
  }
}

impl TSerializable for ChildWorkflowExecutionCanceledEventAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChildWorkflowExecutionCanceledEventAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<Vec<u8>> = None;
    let mut f_20: Option<String> = None;
    let mut f_30: Option<WorkflowExecution> = None;
    let mut f_40: Option<WorkflowType> = None;
    let mut f_50: Option<i64> = None;
    let mut f_60: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_bytes()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        30 => {
          let val = WorkflowExecution::read_from_in_protocol(i_prot)?;
          f_30 = Some(val);
        },
        40 => {
          let val = WorkflowType::read_from_in_protocol(i_prot)?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_i64()?;
          f_50 = Some(val);
        },
        60 => {
          let val = i_prot.read_i64()?;
          f_60 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChildWorkflowExecutionCanceledEventAttributes {
      details: f_10,
      domain: f_20,
      workflow_execution: f_30,
      workflow_type: f_40,
      initiated_event_id: f_50,
      started_event_id: f_60,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChildWorkflowExecutionCanceledEventAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.details {
      o_prot.write_field_begin(&TFieldIdentifier::new("details", TType::String, 10))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_execution {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecution", TType::Struct, 30))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowType", TType::Struct, 40))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.initiated_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("initiatedEventId", TType::I64, 50))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.started_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("startedEventId", TType::I64, 60))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChildWorkflowExecutionTimedOutEventAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ChildWorkflowExecutionTimedOutEventAttributes {
  pub timeout_type: Option<TimeoutType>,
  pub domain: Option<String>,
  pub workflow_execution: Option<WorkflowExecution>,
  pub workflow_type: Option<WorkflowType>,
  pub initiated_event_id: Option<i64>,
  pub started_event_id: Option<i64>,
}

impl ChildWorkflowExecutionTimedOutEventAttributes {
  pub fn new<F10, F20, F30, F40, F50, F60>(timeout_type: F10, domain: F20, workflow_execution: F30, workflow_type: F40, initiated_event_id: F50, started_event_id: F60) -> ChildWorkflowExecutionTimedOutEventAttributes where F10: Into<Option<TimeoutType>>, F20: Into<Option<String>>, F30: Into<Option<WorkflowExecution>>, F40: Into<Option<WorkflowType>>, F50: Into<Option<i64>>, F60: Into<Option<i64>> {
    ChildWorkflowExecutionTimedOutEventAttributes {
      timeout_type: timeout_type.into(),
      domain: domain.into(),
      workflow_execution: workflow_execution.into(),
      workflow_type: workflow_type.into(),
      initiated_event_id: initiated_event_id.into(),
      started_event_id: started_event_id.into(),
    }
  }
}

impl TSerializable for ChildWorkflowExecutionTimedOutEventAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChildWorkflowExecutionTimedOutEventAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<TimeoutType> = None;
    let mut f_20: Option<String> = None;
    let mut f_30: Option<WorkflowExecution> = None;
    let mut f_40: Option<WorkflowType> = None;
    let mut f_50: Option<i64> = None;
    let mut f_60: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = TimeoutType::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        30 => {
          let val = WorkflowExecution::read_from_in_protocol(i_prot)?;
          f_30 = Some(val);
        },
        40 => {
          let val = WorkflowType::read_from_in_protocol(i_prot)?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_i64()?;
          f_50 = Some(val);
        },
        60 => {
          let val = i_prot.read_i64()?;
          f_60 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChildWorkflowExecutionTimedOutEventAttributes {
      timeout_type: f_10,
      domain: f_20,
      workflow_execution: f_30,
      workflow_type: f_40,
      initiated_event_id: f_50,
      started_event_id: f_60,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChildWorkflowExecutionTimedOutEventAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.timeout_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("timeoutType", TType::I32, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_execution {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecution", TType::Struct, 30))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowType", TType::Struct, 40))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.initiated_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("initiatedEventId", TType::I64, 50))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.started_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("startedEventId", TType::I64, 60))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ChildWorkflowExecutionTerminatedEventAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ChildWorkflowExecutionTerminatedEventAttributes {
  pub domain: Option<String>,
  pub workflow_execution: Option<WorkflowExecution>,
  pub workflow_type: Option<WorkflowType>,
  pub initiated_event_id: Option<i64>,
  pub started_event_id: Option<i64>,
}

impl ChildWorkflowExecutionTerminatedEventAttributes {
  pub fn new<F10, F20, F30, F40, F50>(domain: F10, workflow_execution: F20, workflow_type: F30, initiated_event_id: F40, started_event_id: F50) -> ChildWorkflowExecutionTerminatedEventAttributes where F10: Into<Option<String>>, F20: Into<Option<WorkflowExecution>>, F30: Into<Option<WorkflowType>>, F40: Into<Option<i64>>, F50: Into<Option<i64>> {
    ChildWorkflowExecutionTerminatedEventAttributes {
      domain: domain.into(),
      workflow_execution: workflow_execution.into(),
      workflow_type: workflow_type.into(),
      initiated_event_id: initiated_event_id.into(),
      started_event_id: started_event_id.into(),
    }
  }
}

impl TSerializable for ChildWorkflowExecutionTerminatedEventAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ChildWorkflowExecutionTerminatedEventAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<WorkflowExecution> = None;
    let mut f_30: Option<WorkflowType> = None;
    let mut f_40: Option<i64> = None;
    let mut f_50: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = WorkflowExecution::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        30 => {
          let val = WorkflowType::read_from_in_protocol(i_prot)?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_i64()?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_i64()?;
          f_50 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ChildWorkflowExecutionTerminatedEventAttributes {
      domain: f_10,
      workflow_execution: f_20,
      workflow_type: f_30,
      initiated_event_id: f_40,
      started_event_id: f_50,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ChildWorkflowExecutionTerminatedEventAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_execution {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecution", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowType", TType::Struct, 30))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.initiated_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("initiatedEventId", TType::I64, 40))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.started_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("startedEventId", TType::I64, 50))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HistoryEvent
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct HistoryEvent {
  pub event_id: Option<i64>,
  pub timestamp: Option<i64>,
  pub event_type: Option<EventType>,
  pub version: Option<i64>,
  pub task_id: Option<i64>,
  pub workflow_execution_started_event_attributes: Option<WorkflowExecutionStartedEventAttributes>,
  pub workflow_execution_completed_event_attributes: Option<WorkflowExecutionCompletedEventAttributes>,
  pub workflow_execution_failed_event_attributes: Option<WorkflowExecutionFailedEventAttributes>,
  pub workflow_execution_timed_out_event_attributes: Option<WorkflowExecutionTimedOutEventAttributes>,
  pub decision_task_scheduled_event_attributes: Option<DecisionTaskScheduledEventAttributes>,
  pub decision_task_started_event_attributes: Option<DecisionTaskStartedEventAttributes>,
  pub decision_task_completed_event_attributes: Option<DecisionTaskCompletedEventAttributes>,
  pub decision_task_timed_out_event_attributes: Option<DecisionTaskTimedOutEventAttributes>,
  pub decision_task_failed_event_attributes: Option<DecisionTaskFailedEventAttributes>,
  pub activity_task_scheduled_event_attributes: Option<ActivityTaskScheduledEventAttributes>,
  pub activity_task_started_event_attributes: Option<ActivityTaskStartedEventAttributes>,
  pub activity_task_completed_event_attributes: Option<ActivityTaskCompletedEventAttributes>,
  pub activity_task_failed_event_attributes: Option<ActivityTaskFailedEventAttributes>,
  pub activity_task_timed_out_event_attributes: Option<ActivityTaskTimedOutEventAttributes>,
  pub timer_started_event_attributes: Option<TimerStartedEventAttributes>,
  pub timer_fired_event_attributes: Option<TimerFiredEventAttributes>,
  pub activity_task_cancel_requested_event_attributes: Option<ActivityTaskCancelRequestedEventAttributes>,
  pub request_cancel_activity_task_failed_event_attributes: Option<RequestCancelActivityTaskFailedEventAttributes>,
  pub activity_task_canceled_event_attributes: Option<ActivityTaskCanceledEventAttributes>,
  pub timer_canceled_event_attributes: Option<TimerCanceledEventAttributes>,
  pub cancel_timer_failed_event_attributes: Option<CancelTimerFailedEventAttributes>,
  pub marker_recorded_event_attributes: Option<MarkerRecordedEventAttributes>,
  pub workflow_execution_signaled_event_attributes: Option<WorkflowExecutionSignaledEventAttributes>,
  pub workflow_execution_terminated_event_attributes: Option<WorkflowExecutionTerminatedEventAttributes>,
  pub workflow_execution_cancel_requested_event_attributes: Option<WorkflowExecutionCancelRequestedEventAttributes>,
  pub workflow_execution_canceled_event_attributes: Option<WorkflowExecutionCanceledEventAttributes>,
  pub request_cancel_external_workflow_execution_initiated_event_attributes: Option<RequestCancelExternalWorkflowExecutionInitiatedEventAttributes>,
  pub request_cancel_external_workflow_execution_failed_event_attributes: Option<RequestCancelExternalWorkflowExecutionFailedEventAttributes>,
  pub external_workflow_execution_cancel_requested_event_attributes: Option<ExternalWorkflowExecutionCancelRequestedEventAttributes>,
  pub workflow_execution_continued_as_new_event_attributes: Option<WorkflowExecutionContinuedAsNewEventAttributes>,
  pub start_child_workflow_execution_initiated_event_attributes: Option<StartChildWorkflowExecutionInitiatedEventAttributes>,
  pub start_child_workflow_execution_failed_event_attributes: Option<StartChildWorkflowExecutionFailedEventAttributes>,
  pub child_workflow_execution_started_event_attributes: Option<ChildWorkflowExecutionStartedEventAttributes>,
  pub child_workflow_execution_completed_event_attributes: Option<ChildWorkflowExecutionCompletedEventAttributes>,
  pub child_workflow_execution_failed_event_attributes: Option<ChildWorkflowExecutionFailedEventAttributes>,
  pub child_workflow_execution_canceled_event_attributes: Option<ChildWorkflowExecutionCanceledEventAttributes>,
  pub child_workflow_execution_timed_out_event_attributes: Option<ChildWorkflowExecutionTimedOutEventAttributes>,
  pub child_workflow_execution_terminated_event_attributes: Option<ChildWorkflowExecutionTerminatedEventAttributes>,
  pub signal_external_workflow_execution_initiated_event_attributes: Option<SignalExternalWorkflowExecutionInitiatedEventAttributes>,
  pub signal_external_workflow_execution_failed_event_attributes: Option<SignalExternalWorkflowExecutionFailedEventAttributes>,
  pub external_workflow_execution_signaled_event_attributes: Option<ExternalWorkflowExecutionSignaledEventAttributes>,
  pub upsert_workflow_search_attributes_event_attributes: Option<UpsertWorkflowSearchAttributesEventAttributes>,
}

impl HistoryEvent {
  pub fn new<F10, F20, F30, F35, F36, F40, F50, F60, F70, F80, F90, F100, F110, F120, F130, F140, F150, F160, F170, F180, F190, F200, F210, F220, F230, F240, F250, F260, F270, F280, F290, F300, F310, F320, F330, F340, F350, F360, F370, F380, F390, F400, F410, F420, F430, F440, F450>(event_id: F10, timestamp: F20, event_type: F30, version: F35, task_id: F36, workflow_execution_started_event_attributes: F40, workflow_execution_completed_event_attributes: F50, workflow_execution_failed_event_attributes: F60, workflow_execution_timed_out_event_attributes: F70, decision_task_scheduled_event_attributes: F80, decision_task_started_event_attributes: F90, decision_task_completed_event_attributes: F100, decision_task_timed_out_event_attributes: F110, decision_task_failed_event_attributes: F120, activity_task_scheduled_event_attributes: F130, activity_task_started_event_attributes: F140, activity_task_completed_event_attributes: F150, activity_task_failed_event_attributes: F160, activity_task_timed_out_event_attributes: F170, timer_started_event_attributes: F180, timer_fired_event_attributes: F190, activity_task_cancel_requested_event_attributes: F200, request_cancel_activity_task_failed_event_attributes: F210, activity_task_canceled_event_attributes: F220, timer_canceled_event_attributes: F230, cancel_timer_failed_event_attributes: F240, marker_recorded_event_attributes: F250, workflow_execution_signaled_event_attributes: F260, workflow_execution_terminated_event_attributes: F270, workflow_execution_cancel_requested_event_attributes: F280, workflow_execution_canceled_event_attributes: F290, request_cancel_external_workflow_execution_initiated_event_attributes: F300, request_cancel_external_workflow_execution_failed_event_attributes: F310, external_workflow_execution_cancel_requested_event_attributes: F320, workflow_execution_continued_as_new_event_attributes: F330, start_child_workflow_execution_initiated_event_attributes: F340, start_child_workflow_execution_failed_event_attributes: F350, child_workflow_execution_started_event_attributes: F360, child_workflow_execution_completed_event_attributes: F370, child_workflow_execution_failed_event_attributes: F380, child_workflow_execution_canceled_event_attributes: F390, child_workflow_execution_timed_out_event_attributes: F400, child_workflow_execution_terminated_event_attributes: F410, signal_external_workflow_execution_initiated_event_attributes: F420, signal_external_workflow_execution_failed_event_attributes: F430, external_workflow_execution_signaled_event_attributes: F440, upsert_workflow_search_attributes_event_attributes: F450) -> HistoryEvent where F10: Into<Option<i64>>, F20: Into<Option<i64>>, F30: Into<Option<EventType>>, F35: Into<Option<i64>>, F36: Into<Option<i64>>, F40: Into<Option<WorkflowExecutionStartedEventAttributes>>, F50: Into<Option<WorkflowExecutionCompletedEventAttributes>>, F60: Into<Option<WorkflowExecutionFailedEventAttributes>>, F70: Into<Option<WorkflowExecutionTimedOutEventAttributes>>, F80: Into<Option<DecisionTaskScheduledEventAttributes>>, F90: Into<Option<DecisionTaskStartedEventAttributes>>, F100: Into<Option<DecisionTaskCompletedEventAttributes>>, F110: Into<Option<DecisionTaskTimedOutEventAttributes>>, F120: Into<Option<DecisionTaskFailedEventAttributes>>, F130: Into<Option<ActivityTaskScheduledEventAttributes>>, F140: Into<Option<ActivityTaskStartedEventAttributes>>, F150: Into<Option<ActivityTaskCompletedEventAttributes>>, F160: Into<Option<ActivityTaskFailedEventAttributes>>, F170: Into<Option<ActivityTaskTimedOutEventAttributes>>, F180: Into<Option<TimerStartedEventAttributes>>, F190: Into<Option<TimerFiredEventAttributes>>, F200: Into<Option<ActivityTaskCancelRequestedEventAttributes>>, F210: Into<Option<RequestCancelActivityTaskFailedEventAttributes>>, F220: Into<Option<ActivityTaskCanceledEventAttributes>>, F230: Into<Option<TimerCanceledEventAttributes>>, F240: Into<Option<CancelTimerFailedEventAttributes>>, F250: Into<Option<MarkerRecordedEventAttributes>>, F260: Into<Option<WorkflowExecutionSignaledEventAttributes>>, F270: Into<Option<WorkflowExecutionTerminatedEventAttributes>>, F280: Into<Option<WorkflowExecutionCancelRequestedEventAttributes>>, F290: Into<Option<WorkflowExecutionCanceledEventAttributes>>, F300: Into<Option<RequestCancelExternalWorkflowExecutionInitiatedEventAttributes>>, F310: Into<Option<RequestCancelExternalWorkflowExecutionFailedEventAttributes>>, F320: Into<Option<ExternalWorkflowExecutionCancelRequestedEventAttributes>>, F330: Into<Option<WorkflowExecutionContinuedAsNewEventAttributes>>, F340: Into<Option<StartChildWorkflowExecutionInitiatedEventAttributes>>, F350: Into<Option<StartChildWorkflowExecutionFailedEventAttributes>>, F360: Into<Option<ChildWorkflowExecutionStartedEventAttributes>>, F370: Into<Option<ChildWorkflowExecutionCompletedEventAttributes>>, F380: Into<Option<ChildWorkflowExecutionFailedEventAttributes>>, F390: Into<Option<ChildWorkflowExecutionCanceledEventAttributes>>, F400: Into<Option<ChildWorkflowExecutionTimedOutEventAttributes>>, F410: Into<Option<ChildWorkflowExecutionTerminatedEventAttributes>>, F420: Into<Option<SignalExternalWorkflowExecutionInitiatedEventAttributes>>, F430: Into<Option<SignalExternalWorkflowExecutionFailedEventAttributes>>, F440: Into<Option<ExternalWorkflowExecutionSignaledEventAttributes>>, F450: Into<Option<UpsertWorkflowSearchAttributesEventAttributes>> {
    HistoryEvent {
      event_id: event_id.into(),
      timestamp: timestamp.into(),
      event_type: event_type.into(),
      version: version.into(),
      task_id: task_id.into(),
      workflow_execution_started_event_attributes: workflow_execution_started_event_attributes.into(),
      workflow_execution_completed_event_attributes: workflow_execution_completed_event_attributes.into(),
      workflow_execution_failed_event_attributes: workflow_execution_failed_event_attributes.into(),
      workflow_execution_timed_out_event_attributes: workflow_execution_timed_out_event_attributes.into(),
      decision_task_scheduled_event_attributes: decision_task_scheduled_event_attributes.into(),
      decision_task_started_event_attributes: decision_task_started_event_attributes.into(),
      decision_task_completed_event_attributes: decision_task_completed_event_attributes.into(),
      decision_task_timed_out_event_attributes: decision_task_timed_out_event_attributes.into(),
      decision_task_failed_event_attributes: decision_task_failed_event_attributes.into(),
      activity_task_scheduled_event_attributes: activity_task_scheduled_event_attributes.into(),
      activity_task_started_event_attributes: activity_task_started_event_attributes.into(),
      activity_task_completed_event_attributes: activity_task_completed_event_attributes.into(),
      activity_task_failed_event_attributes: activity_task_failed_event_attributes.into(),
      activity_task_timed_out_event_attributes: activity_task_timed_out_event_attributes.into(),
      timer_started_event_attributes: timer_started_event_attributes.into(),
      timer_fired_event_attributes: timer_fired_event_attributes.into(),
      activity_task_cancel_requested_event_attributes: activity_task_cancel_requested_event_attributes.into(),
      request_cancel_activity_task_failed_event_attributes: request_cancel_activity_task_failed_event_attributes.into(),
      activity_task_canceled_event_attributes: activity_task_canceled_event_attributes.into(),
      timer_canceled_event_attributes: timer_canceled_event_attributes.into(),
      cancel_timer_failed_event_attributes: cancel_timer_failed_event_attributes.into(),
      marker_recorded_event_attributes: marker_recorded_event_attributes.into(),
      workflow_execution_signaled_event_attributes: workflow_execution_signaled_event_attributes.into(),
      workflow_execution_terminated_event_attributes: workflow_execution_terminated_event_attributes.into(),
      workflow_execution_cancel_requested_event_attributes: workflow_execution_cancel_requested_event_attributes.into(),
      workflow_execution_canceled_event_attributes: workflow_execution_canceled_event_attributes.into(),
      request_cancel_external_workflow_execution_initiated_event_attributes: request_cancel_external_workflow_execution_initiated_event_attributes.into(),
      request_cancel_external_workflow_execution_failed_event_attributes: request_cancel_external_workflow_execution_failed_event_attributes.into(),
      external_workflow_execution_cancel_requested_event_attributes: external_workflow_execution_cancel_requested_event_attributes.into(),
      workflow_execution_continued_as_new_event_attributes: workflow_execution_continued_as_new_event_attributes.into(),
      start_child_workflow_execution_initiated_event_attributes: start_child_workflow_execution_initiated_event_attributes.into(),
      start_child_workflow_execution_failed_event_attributes: start_child_workflow_execution_failed_event_attributes.into(),
      child_workflow_execution_started_event_attributes: child_workflow_execution_started_event_attributes.into(),
      child_workflow_execution_completed_event_attributes: child_workflow_execution_completed_event_attributes.into(),
      child_workflow_execution_failed_event_attributes: child_workflow_execution_failed_event_attributes.into(),
      child_workflow_execution_canceled_event_attributes: child_workflow_execution_canceled_event_attributes.into(),
      child_workflow_execution_timed_out_event_attributes: child_workflow_execution_timed_out_event_attributes.into(),
      child_workflow_execution_terminated_event_attributes: child_workflow_execution_terminated_event_attributes.into(),
      signal_external_workflow_execution_initiated_event_attributes: signal_external_workflow_execution_initiated_event_attributes.into(),
      signal_external_workflow_execution_failed_event_attributes: signal_external_workflow_execution_failed_event_attributes.into(),
      external_workflow_execution_signaled_event_attributes: external_workflow_execution_signaled_event_attributes.into(),
      upsert_workflow_search_attributes_event_attributes: upsert_workflow_search_attributes_event_attributes.into(),
    }
  }
}

impl TSerializable for HistoryEvent {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HistoryEvent> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<i64> = None;
    let mut f_20: Option<i64> = None;
    let mut f_30: Option<EventType> = None;
    let mut f_35: Option<i64> = None;
    let mut f_36: Option<i64> = None;
    let mut f_40: Option<WorkflowExecutionStartedEventAttributes> = None;
    let mut f_50: Option<WorkflowExecutionCompletedEventAttributes> = None;
    let mut f_60: Option<WorkflowExecutionFailedEventAttributes> = None;
    let mut f_70: Option<WorkflowExecutionTimedOutEventAttributes> = None;
    let mut f_80: Option<DecisionTaskScheduledEventAttributes> = None;
    let mut f_90: Option<DecisionTaskStartedEventAttributes> = None;
    let mut f_100: Option<DecisionTaskCompletedEventAttributes> = None;
    let mut f_110: Option<DecisionTaskTimedOutEventAttributes> = None;
    let mut f_120: Option<DecisionTaskFailedEventAttributes> = None;
    let mut f_130: Option<ActivityTaskScheduledEventAttributes> = None;
    let mut f_140: Option<ActivityTaskStartedEventAttributes> = None;
    let mut f_150: Option<ActivityTaskCompletedEventAttributes> = None;
    let mut f_160: Option<ActivityTaskFailedEventAttributes> = None;
    let mut f_170: Option<ActivityTaskTimedOutEventAttributes> = None;
    let mut f_180: Option<TimerStartedEventAttributes> = None;
    let mut f_190: Option<TimerFiredEventAttributes> = None;
    let mut f_200: Option<ActivityTaskCancelRequestedEventAttributes> = None;
    let mut f_210: Option<RequestCancelActivityTaskFailedEventAttributes> = None;
    let mut f_220: Option<ActivityTaskCanceledEventAttributes> = None;
    let mut f_230: Option<TimerCanceledEventAttributes> = None;
    let mut f_240: Option<CancelTimerFailedEventAttributes> = None;
    let mut f_250: Option<MarkerRecordedEventAttributes> = None;
    let mut f_260: Option<WorkflowExecutionSignaledEventAttributes> = None;
    let mut f_270: Option<WorkflowExecutionTerminatedEventAttributes> = None;
    let mut f_280: Option<WorkflowExecutionCancelRequestedEventAttributes> = None;
    let mut f_290: Option<WorkflowExecutionCanceledEventAttributes> = None;
    let mut f_300: Option<RequestCancelExternalWorkflowExecutionInitiatedEventAttributes> = None;
    let mut f_310: Option<RequestCancelExternalWorkflowExecutionFailedEventAttributes> = None;
    let mut f_320: Option<ExternalWorkflowExecutionCancelRequestedEventAttributes> = None;
    let mut f_330: Option<WorkflowExecutionContinuedAsNewEventAttributes> = None;
    let mut f_340: Option<StartChildWorkflowExecutionInitiatedEventAttributes> = None;
    let mut f_350: Option<StartChildWorkflowExecutionFailedEventAttributes> = None;
    let mut f_360: Option<ChildWorkflowExecutionStartedEventAttributes> = None;
    let mut f_370: Option<ChildWorkflowExecutionCompletedEventAttributes> = None;
    let mut f_380: Option<ChildWorkflowExecutionFailedEventAttributes> = None;
    let mut f_390: Option<ChildWorkflowExecutionCanceledEventAttributes> = None;
    let mut f_400: Option<ChildWorkflowExecutionTimedOutEventAttributes> = None;
    let mut f_410: Option<ChildWorkflowExecutionTerminatedEventAttributes> = None;
    let mut f_420: Option<SignalExternalWorkflowExecutionInitiatedEventAttributes> = None;
    let mut f_430: Option<SignalExternalWorkflowExecutionFailedEventAttributes> = None;
    let mut f_440: Option<ExternalWorkflowExecutionSignaledEventAttributes> = None;
    let mut f_450: Option<UpsertWorkflowSearchAttributesEventAttributes> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_i64()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_i64()?;
          f_20 = Some(val);
        },
        30 => {
          let val = EventType::read_from_in_protocol(i_prot)?;
          f_30 = Some(val);
        },
        35 => {
          let val = i_prot.read_i64()?;
          f_35 = Some(val);
        },
        36 => {
          let val = i_prot.read_i64()?;
          f_36 = Some(val);
        },
        40 => {
          let val = WorkflowExecutionStartedEventAttributes::read_from_in_protocol(i_prot)?;
          f_40 = Some(val);
        },
        50 => {
          let val = WorkflowExecutionCompletedEventAttributes::read_from_in_protocol(i_prot)?;
          f_50 = Some(val);
        },
        60 => {
          let val = WorkflowExecutionFailedEventAttributes::read_from_in_protocol(i_prot)?;
          f_60 = Some(val);
        },
        70 => {
          let val = WorkflowExecutionTimedOutEventAttributes::read_from_in_protocol(i_prot)?;
          f_70 = Some(val);
        },
        80 => {
          let val = DecisionTaskScheduledEventAttributes::read_from_in_protocol(i_prot)?;
          f_80 = Some(val);
        },
        90 => {
          let val = DecisionTaskStartedEventAttributes::read_from_in_protocol(i_prot)?;
          f_90 = Some(val);
        },
        100 => {
          let val = DecisionTaskCompletedEventAttributes::read_from_in_protocol(i_prot)?;
          f_100 = Some(val);
        },
        110 => {
          let val = DecisionTaskTimedOutEventAttributes::read_from_in_protocol(i_prot)?;
          f_110 = Some(val);
        },
        120 => {
          let val = DecisionTaskFailedEventAttributes::read_from_in_protocol(i_prot)?;
          f_120 = Some(val);
        },
        130 => {
          let val = ActivityTaskScheduledEventAttributes::read_from_in_protocol(i_prot)?;
          f_130 = Some(val);
        },
        140 => {
          let val = ActivityTaskStartedEventAttributes::read_from_in_protocol(i_prot)?;
          f_140 = Some(val);
        },
        150 => {
          let val = ActivityTaskCompletedEventAttributes::read_from_in_protocol(i_prot)?;
          f_150 = Some(val);
        },
        160 => {
          let val = ActivityTaskFailedEventAttributes::read_from_in_protocol(i_prot)?;
          f_160 = Some(val);
        },
        170 => {
          let val = ActivityTaskTimedOutEventAttributes::read_from_in_protocol(i_prot)?;
          f_170 = Some(val);
        },
        180 => {
          let val = TimerStartedEventAttributes::read_from_in_protocol(i_prot)?;
          f_180 = Some(val);
        },
        190 => {
          let val = TimerFiredEventAttributes::read_from_in_protocol(i_prot)?;
          f_190 = Some(val);
        },
        200 => {
          let val = ActivityTaskCancelRequestedEventAttributes::read_from_in_protocol(i_prot)?;
          f_200 = Some(val);
        },
        210 => {
          let val = RequestCancelActivityTaskFailedEventAttributes::read_from_in_protocol(i_prot)?;
          f_210 = Some(val);
        },
        220 => {
          let val = ActivityTaskCanceledEventAttributes::read_from_in_protocol(i_prot)?;
          f_220 = Some(val);
        },
        230 => {
          let val = TimerCanceledEventAttributes::read_from_in_protocol(i_prot)?;
          f_230 = Some(val);
        },
        240 => {
          let val = CancelTimerFailedEventAttributes::read_from_in_protocol(i_prot)?;
          f_240 = Some(val);
        },
        250 => {
          let val = MarkerRecordedEventAttributes::read_from_in_protocol(i_prot)?;
          f_250 = Some(val);
        },
        260 => {
          let val = WorkflowExecutionSignaledEventAttributes::read_from_in_protocol(i_prot)?;
          f_260 = Some(val);
        },
        270 => {
          let val = WorkflowExecutionTerminatedEventAttributes::read_from_in_protocol(i_prot)?;
          f_270 = Some(val);
        },
        280 => {
          let val = WorkflowExecutionCancelRequestedEventAttributes::read_from_in_protocol(i_prot)?;
          f_280 = Some(val);
        },
        290 => {
          let val = WorkflowExecutionCanceledEventAttributes::read_from_in_protocol(i_prot)?;
          f_290 = Some(val);
        },
        300 => {
          let val = RequestCancelExternalWorkflowExecutionInitiatedEventAttributes::read_from_in_protocol(i_prot)?;
          f_300 = Some(val);
        },
        310 => {
          let val = RequestCancelExternalWorkflowExecutionFailedEventAttributes::read_from_in_protocol(i_prot)?;
          f_310 = Some(val);
        },
        320 => {
          let val = ExternalWorkflowExecutionCancelRequestedEventAttributes::read_from_in_protocol(i_prot)?;
          f_320 = Some(val);
        },
        330 => {
          let val = WorkflowExecutionContinuedAsNewEventAttributes::read_from_in_protocol(i_prot)?;
          f_330 = Some(val);
        },
        340 => {
          let val = StartChildWorkflowExecutionInitiatedEventAttributes::read_from_in_protocol(i_prot)?;
          f_340 = Some(val);
        },
        350 => {
          let val = StartChildWorkflowExecutionFailedEventAttributes::read_from_in_protocol(i_prot)?;
          f_350 = Some(val);
        },
        360 => {
          let val = ChildWorkflowExecutionStartedEventAttributes::read_from_in_protocol(i_prot)?;
          f_360 = Some(val);
        },
        370 => {
          let val = ChildWorkflowExecutionCompletedEventAttributes::read_from_in_protocol(i_prot)?;
          f_370 = Some(val);
        },
        380 => {
          let val = ChildWorkflowExecutionFailedEventAttributes::read_from_in_protocol(i_prot)?;
          f_380 = Some(val);
        },
        390 => {
          let val = ChildWorkflowExecutionCanceledEventAttributes::read_from_in_protocol(i_prot)?;
          f_390 = Some(val);
        },
        400 => {
          let val = ChildWorkflowExecutionTimedOutEventAttributes::read_from_in_protocol(i_prot)?;
          f_400 = Some(val);
        },
        410 => {
          let val = ChildWorkflowExecutionTerminatedEventAttributes::read_from_in_protocol(i_prot)?;
          f_410 = Some(val);
        },
        420 => {
          let val = SignalExternalWorkflowExecutionInitiatedEventAttributes::read_from_in_protocol(i_prot)?;
          f_420 = Some(val);
        },
        430 => {
          let val = SignalExternalWorkflowExecutionFailedEventAttributes::read_from_in_protocol(i_prot)?;
          f_430 = Some(val);
        },
        440 => {
          let val = ExternalWorkflowExecutionSignaledEventAttributes::read_from_in_protocol(i_prot)?;
          f_440 = Some(val);
        },
        450 => {
          let val = UpsertWorkflowSearchAttributesEventAttributes::read_from_in_protocol(i_prot)?;
          f_450 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HistoryEvent {
      event_id: f_10,
      timestamp: f_20,
      event_type: f_30,
      version: f_35,
      task_id: f_36,
      workflow_execution_started_event_attributes: f_40,
      workflow_execution_completed_event_attributes: f_50,
      workflow_execution_failed_event_attributes: f_60,
      workflow_execution_timed_out_event_attributes: f_70,
      decision_task_scheduled_event_attributes: f_80,
      decision_task_started_event_attributes: f_90,
      decision_task_completed_event_attributes: f_100,
      decision_task_timed_out_event_attributes: f_110,
      decision_task_failed_event_attributes: f_120,
      activity_task_scheduled_event_attributes: f_130,
      activity_task_started_event_attributes: f_140,
      activity_task_completed_event_attributes: f_150,
      activity_task_failed_event_attributes: f_160,
      activity_task_timed_out_event_attributes: f_170,
      timer_started_event_attributes: f_180,
      timer_fired_event_attributes: f_190,
      activity_task_cancel_requested_event_attributes: f_200,
      request_cancel_activity_task_failed_event_attributes: f_210,
      activity_task_canceled_event_attributes: f_220,
      timer_canceled_event_attributes: f_230,
      cancel_timer_failed_event_attributes: f_240,
      marker_recorded_event_attributes: f_250,
      workflow_execution_signaled_event_attributes: f_260,
      workflow_execution_terminated_event_attributes: f_270,
      workflow_execution_cancel_requested_event_attributes: f_280,
      workflow_execution_canceled_event_attributes: f_290,
      request_cancel_external_workflow_execution_initiated_event_attributes: f_300,
      request_cancel_external_workflow_execution_failed_event_attributes: f_310,
      external_workflow_execution_cancel_requested_event_attributes: f_320,
      workflow_execution_continued_as_new_event_attributes: f_330,
      start_child_workflow_execution_initiated_event_attributes: f_340,
      start_child_workflow_execution_failed_event_attributes: f_350,
      child_workflow_execution_started_event_attributes: f_360,
      child_workflow_execution_completed_event_attributes: f_370,
      child_workflow_execution_failed_event_attributes: f_380,
      child_workflow_execution_canceled_event_attributes: f_390,
      child_workflow_execution_timed_out_event_attributes: f_400,
      child_workflow_execution_terminated_event_attributes: f_410,
      signal_external_workflow_execution_initiated_event_attributes: f_420,
      signal_external_workflow_execution_failed_event_attributes: f_430,
      external_workflow_execution_signaled_event_attributes: f_440,
      upsert_workflow_search_attributes_event_attributes: f_450,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HistoryEvent");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("eventId", TType::I64, 10))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.timestamp {
      o_prot.write_field_begin(&TFieldIdentifier::new("timestamp", TType::I64, 20))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.event_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("eventType", TType::I32, 30))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.version {
      o_prot.write_field_begin(&TFieldIdentifier::new("version", TType::I64, 35))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.task_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskId", TType::I64, 36))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_execution_started_event_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecutionStartedEventAttributes", TType::Struct, 40))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_execution_completed_event_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecutionCompletedEventAttributes", TType::Struct, 50))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_execution_failed_event_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecutionFailedEventAttributes", TType::Struct, 60))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_execution_timed_out_event_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecutionTimedOutEventAttributes", TType::Struct, 70))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.decision_task_scheduled_event_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("decisionTaskScheduledEventAttributes", TType::Struct, 80))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.decision_task_started_event_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("decisionTaskStartedEventAttributes", TType::Struct, 90))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.decision_task_completed_event_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("decisionTaskCompletedEventAttributes", TType::Struct, 100))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.decision_task_timed_out_event_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("decisionTaskTimedOutEventAttributes", TType::Struct, 110))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.decision_task_failed_event_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("decisionTaskFailedEventAttributes", TType::Struct, 120))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.activity_task_scheduled_event_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("activityTaskScheduledEventAttributes", TType::Struct, 130))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.activity_task_started_event_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("activityTaskStartedEventAttributes", TType::Struct, 140))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.activity_task_completed_event_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("activityTaskCompletedEventAttributes", TType::Struct, 150))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.activity_task_failed_event_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("activityTaskFailedEventAttributes", TType::Struct, 160))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.activity_task_timed_out_event_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("activityTaskTimedOutEventAttributes", TType::Struct, 170))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.timer_started_event_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("timerStartedEventAttributes", TType::Struct, 180))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.timer_fired_event_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("timerFiredEventAttributes", TType::Struct, 190))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.activity_task_cancel_requested_event_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("activityTaskCancelRequestedEventAttributes", TType::Struct, 200))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.request_cancel_activity_task_failed_event_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("requestCancelActivityTaskFailedEventAttributes", TType::Struct, 210))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.activity_task_canceled_event_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("activityTaskCanceledEventAttributes", TType::Struct, 220))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.timer_canceled_event_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("timerCanceledEventAttributes", TType::Struct, 230))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cancel_timer_failed_event_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("cancelTimerFailedEventAttributes", TType::Struct, 240))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.marker_recorded_event_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("markerRecordedEventAttributes", TType::Struct, 250))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_execution_signaled_event_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecutionSignaledEventAttributes", TType::Struct, 260))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_execution_terminated_event_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecutionTerminatedEventAttributes", TType::Struct, 270))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_execution_cancel_requested_event_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecutionCancelRequestedEventAttributes", TType::Struct, 280))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_execution_canceled_event_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecutionCanceledEventAttributes", TType::Struct, 290))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.request_cancel_external_workflow_execution_initiated_event_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("requestCancelExternalWorkflowExecutionInitiatedEventAttributes", TType::Struct, 300))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.request_cancel_external_workflow_execution_failed_event_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("requestCancelExternalWorkflowExecutionFailedEventAttributes", TType::Struct, 310))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.external_workflow_execution_cancel_requested_event_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("externalWorkflowExecutionCancelRequestedEventAttributes", TType::Struct, 320))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_execution_continued_as_new_event_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecutionContinuedAsNewEventAttributes", TType::Struct, 330))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.start_child_workflow_execution_initiated_event_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("startChildWorkflowExecutionInitiatedEventAttributes", TType::Struct, 340))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.start_child_workflow_execution_failed_event_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("startChildWorkflowExecutionFailedEventAttributes", TType::Struct, 350))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.child_workflow_execution_started_event_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("childWorkflowExecutionStartedEventAttributes", TType::Struct, 360))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.child_workflow_execution_completed_event_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("childWorkflowExecutionCompletedEventAttributes", TType::Struct, 370))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.child_workflow_execution_failed_event_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("childWorkflowExecutionFailedEventAttributes", TType::Struct, 380))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.child_workflow_execution_canceled_event_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("childWorkflowExecutionCanceledEventAttributes", TType::Struct, 390))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.child_workflow_execution_timed_out_event_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("childWorkflowExecutionTimedOutEventAttributes", TType::Struct, 400))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.child_workflow_execution_terminated_event_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("childWorkflowExecutionTerminatedEventAttributes", TType::Struct, 410))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.signal_external_workflow_execution_initiated_event_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("signalExternalWorkflowExecutionInitiatedEventAttributes", TType::Struct, 420))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.signal_external_workflow_execution_failed_event_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("signalExternalWorkflowExecutionFailedEventAttributes", TType::Struct, 430))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.external_workflow_execution_signaled_event_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("externalWorkflowExecutionSignaledEventAttributes", TType::Struct, 440))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.upsert_workflow_search_attributes_event_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("upsertWorkflowSearchAttributesEventAttributes", TType::Struct, 450))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// History
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct History {
  pub events: Option<Vec<HistoryEvent>>,
}

impl History {
  pub fn new<F10>(events: F10) -> History where F10: Into<Option<Vec<HistoryEvent>>> {
    History {
      events: events.into(),
    }
  }
}

impl TSerializable for History {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<History> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<Vec<HistoryEvent>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<HistoryEvent> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_13 = HistoryEvent::read_from_in_protocol(i_prot)?;
            val.push(list_elem_13);
          }
          i_prot.read_list_end()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = History {
      events: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("History");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.events {
      o_prot.write_field_begin(&TFieldIdentifier::new("events", TType::List, 10))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowExecutionFilter
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WorkflowExecutionFilter {
  pub workflow_id: Option<String>,
  pub run_id: Option<String>,
}

impl WorkflowExecutionFilter {
  pub fn new<F10, F20>(workflow_id: F10, run_id: F20) -> WorkflowExecutionFilter where F10: Into<Option<String>>, F20: Into<Option<String>> {
    WorkflowExecutionFilter {
      workflow_id: workflow_id.into(),
      run_id: run_id.into(),
    }
  }
}

impl TSerializable for WorkflowExecutionFilter {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowExecutionFilter> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowExecutionFilter {
      workflow_id: f_10,
      run_id: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowExecutionFilter");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.workflow_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowId", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.run_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("runId", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowTypeFilter
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WorkflowTypeFilter {
  pub name: Option<String>,
}

impl WorkflowTypeFilter {
  pub fn new<F10>(name: F10) -> WorkflowTypeFilter where F10: Into<Option<String>> {
    WorkflowTypeFilter {
      name: name.into(),
    }
  }
}

impl TSerializable for WorkflowTypeFilter {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowTypeFilter> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowTypeFilter {
      name: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowTypeFilter");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// StartTimeFilter
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct StartTimeFilter {
  pub earliest_time: Option<i64>,
  pub latest_time: Option<i64>,
}

impl StartTimeFilter {
  pub fn new<F10, F20>(earliest_time: F10, latest_time: F20) -> StartTimeFilter where F10: Into<Option<i64>>, F20: Into<Option<i64>> {
    StartTimeFilter {
      earliest_time: earliest_time.into(),
      latest_time: latest_time.into(),
    }
  }
}

impl TSerializable for StartTimeFilter {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<StartTimeFilter> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<i64> = None;
    let mut f_20: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_i64()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_i64()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = StartTimeFilter {
      earliest_time: f_10,
      latest_time: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("StartTimeFilter");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.earliest_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("earliestTime", TType::I64, 10))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.latest_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("latestTime", TType::I64, 20))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DomainInfo
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DomainInfo {
  pub name: Option<String>,
  pub status: Option<DomainStatus>,
  pub description: Option<String>,
  pub owner_email: Option<String>,
  pub data: Option<BTreeMap<String, String>>,
  pub uuid: Option<String>,
}

impl DomainInfo {
  pub fn new<F10, F20, F30, F40, F50, F60>(name: F10, status: F20, description: F30, owner_email: F40, data: F50, uuid: F60) -> DomainInfo where F10: Into<Option<String>>, F20: Into<Option<DomainStatus>>, F30: Into<Option<String>>, F40: Into<Option<String>>, F50: Into<Option<BTreeMap<String, String>>>, F60: Into<Option<String>> {
    DomainInfo {
      name: name.into(),
      status: status.into(),
      description: description.into(),
      owner_email: owner_email.into(),
      data: data.into(),
      uuid: uuid.into(),
    }
  }
}

impl TSerializable for DomainInfo {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DomainInfo> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<DomainStatus> = None;
    let mut f_30: Option<String> = None;
    let mut f_40: Option<String> = None;
    let mut f_50: Option<BTreeMap<String, String>> = None;
    let mut f_60: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = DomainStatus::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_string()?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_string()?;
          f_40 = Some(val);
        },
        50 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_14 = i_prot.read_string()?;
            let map_val_15 = i_prot.read_string()?;
            val.insert(map_key_14, map_val_15);
          }
          i_prot.read_map_end()?;
          f_50 = Some(val);
        },
        60 => {
          let val = i_prot.read_string()?;
          f_60 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DomainInfo {
      name: f_10,
      status: f_20,
      description: f_30,
      owner_email: f_40,
      data: f_50,
      uuid: f_60,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DomainInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.status {
      o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::I32, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.description {
      o_prot.write_field_begin(&TFieldIdentifier::new("description", TType::String, 30))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.owner_email {
      o_prot.write_field_begin(&TFieldIdentifier::new("ownerEmail", TType::String, 40))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.data {
      o_prot.write_field_begin(&TFieldIdentifier::new("data", TType::Map, 50))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.uuid {
      o_prot.write_field_begin(&TFieldIdentifier::new("uuid", TType::String, 60))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DomainConfiguration
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DomainConfiguration {
  pub workflow_execution_retention_period_in_days: Option<i32>,
  pub emit_metric: Option<bool>,
  pub isolationgroups: Option<Box<IsolationGroupConfiguration>>,
  pub bad_binaries: Option<Box<BadBinaries>>,
  pub history_archival_status: Option<ArchivalStatus>,
  pub history_archival_u_r_i: Option<String>,
  pub visibility_archival_status: Option<ArchivalStatus>,
  pub visibility_archival_u_r_i: Option<String>,
  pub async_workflow_configuration: Option<Box<AsyncWorkflowConfiguration>>,
}

impl DomainConfiguration {
  pub fn new<F10, F20, F60, F70, F80, F90, F100, F110, F120>(workflow_execution_retention_period_in_days: F10, emit_metric: F20, isolationgroups: F60, bad_binaries: F70, history_archival_status: F80, history_archival_u_r_i: F90, visibility_archival_status: F100, visibility_archival_u_r_i: F110, async_workflow_configuration: F120) -> DomainConfiguration where F10: Into<Option<i32>>, F20: Into<Option<bool>>, F60: Into<Option<Box<IsolationGroupConfiguration>>>, F70: Into<Option<Box<BadBinaries>>>, F80: Into<Option<ArchivalStatus>>, F90: Into<Option<String>>, F100: Into<Option<ArchivalStatus>>, F110: Into<Option<String>>, F120: Into<Option<Box<AsyncWorkflowConfiguration>>> {
    DomainConfiguration {
      workflow_execution_retention_period_in_days: workflow_execution_retention_period_in_days.into(),
      emit_metric: emit_metric.into(),
      isolationgroups: isolationgroups.into(),
      bad_binaries: bad_binaries.into(),
      history_archival_status: history_archival_status.into(),
      history_archival_u_r_i: history_archival_u_r_i.into(),
      visibility_archival_status: visibility_archival_status.into(),
      visibility_archival_u_r_i: visibility_archival_u_r_i.into(),
      async_workflow_configuration: async_workflow_configuration.into(),
    }
  }
}

impl TSerializable for DomainConfiguration {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DomainConfiguration> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<i32> = None;
    let mut f_20: Option<bool> = None;
    let mut f_60: Option<Box<IsolationGroupConfiguration>> = None;
    let mut f_70: Option<Box<BadBinaries>> = None;
    let mut f_80: Option<ArchivalStatus> = None;
    let mut f_90: Option<String> = None;
    let mut f_100: Option<ArchivalStatus> = None;
    let mut f_110: Option<String> = None;
    let mut f_120: Option<Box<AsyncWorkflowConfiguration>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_i32()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_bool()?;
          f_20 = Some(val);
        },
        60 => {
          let val = Box::new(IsolationGroupConfiguration::read_from_in_protocol(i_prot)?);
          f_60 = Some(val);
        },
        70 => {
          let val = Box::new(BadBinaries::read_from_in_protocol(i_prot)?);
          f_70 = Some(val);
        },
        80 => {
          let val = ArchivalStatus::read_from_in_protocol(i_prot)?;
          f_80 = Some(val);
        },
        90 => {
          let val = i_prot.read_string()?;
          f_90 = Some(val);
        },
        100 => {
          let val = ArchivalStatus::read_from_in_protocol(i_prot)?;
          f_100 = Some(val);
        },
        110 => {
          let val = i_prot.read_string()?;
          f_110 = Some(val);
        },
        120 => {
          let val = Box::new(AsyncWorkflowConfiguration::read_from_in_protocol(i_prot)?);
          f_120 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DomainConfiguration {
      workflow_execution_retention_period_in_days: f_10,
      emit_metric: f_20,
      isolationgroups: f_60,
      bad_binaries: f_70,
      history_archival_status: f_80,
      history_archival_u_r_i: f_90,
      visibility_archival_status: f_100,
      visibility_archival_u_r_i: f_110,
      async_workflow_configuration: f_120,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DomainConfiguration");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.workflow_execution_retention_period_in_days {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecutionRetentionPeriodInDays", TType::I32, 10))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.emit_metric {
      o_prot.write_field_begin(&TFieldIdentifier::new("emitMetric", TType::Bool, 20))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.isolationgroups {
      o_prot.write_field_begin(&TFieldIdentifier::new("isolationgroups", TType::Struct, 60))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.bad_binaries {
      o_prot.write_field_begin(&TFieldIdentifier::new("badBinaries", TType::Struct, 70))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.history_archival_status {
      o_prot.write_field_begin(&TFieldIdentifier::new("historyArchivalStatus", TType::I32, 80))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.history_archival_u_r_i {
      o_prot.write_field_begin(&TFieldIdentifier::new("historyArchivalURI", TType::String, 90))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.visibility_archival_status {
      o_prot.write_field_begin(&TFieldIdentifier::new("visibilityArchivalStatus", TType::I32, 100))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.visibility_archival_u_r_i {
      o_prot.write_field_begin(&TFieldIdentifier::new("visibilityArchivalURI", TType::String, 110))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.async_workflow_configuration {
      o_prot.write_field_begin(&TFieldIdentifier::new("AsyncWorkflowConfiguration", TType::Struct, 120))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// FailoverInfo
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct FailoverInfo {
  pub failover_version: Option<i64>,
  pub failover_start_timestamp: Option<i64>,
  pub failover_expire_timestamp: Option<i64>,
  pub completed_shard_count: Option<i32>,
  pub pending_shards: Option<Vec<i32>>,
}

impl FailoverInfo {
  pub fn new<F10, F20, F30, F40, F50>(failover_version: F10, failover_start_timestamp: F20, failover_expire_timestamp: F30, completed_shard_count: F40, pending_shards: F50) -> FailoverInfo where F10: Into<Option<i64>>, F20: Into<Option<i64>>, F30: Into<Option<i64>>, F40: Into<Option<i32>>, F50: Into<Option<Vec<i32>>> {
    FailoverInfo {
      failover_version: failover_version.into(),
      failover_start_timestamp: failover_start_timestamp.into(),
      failover_expire_timestamp: failover_expire_timestamp.into(),
      completed_shard_count: completed_shard_count.into(),
      pending_shards: pending_shards.into(),
    }
  }
}

impl TSerializable for FailoverInfo {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<FailoverInfo> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<i64> = None;
    let mut f_20: Option<i64> = None;
    let mut f_30: Option<i64> = None;
    let mut f_40: Option<i32> = None;
    let mut f_50: Option<Vec<i32>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_i64()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_i64()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_i64()?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_i32()?;
          f_40 = Some(val);
        },
        50 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_16 = i_prot.read_i32()?;
            val.push(list_elem_16);
          }
          i_prot.read_list_end()?;
          f_50 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = FailoverInfo {
      failover_version: f_10,
      failover_start_timestamp: f_20,
      failover_expire_timestamp: f_30,
      completed_shard_count: f_40,
      pending_shards: f_50,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("FailoverInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.failover_version {
      o_prot.write_field_begin(&TFieldIdentifier::new("failoverVersion", TType::I64, 10))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.failover_start_timestamp {
      o_prot.write_field_begin(&TFieldIdentifier::new("failoverStartTimestamp", TType::I64, 20))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.failover_expire_timestamp {
      o_prot.write_field_begin(&TFieldIdentifier::new("failoverExpireTimestamp", TType::I64, 30))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.completed_shard_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("completedShardCount", TType::I32, 40))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.pending_shards {
      o_prot.write_field_begin(&TFieldIdentifier::new("pendingShards", TType::List, 50))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i32(*e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BadBinaries
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct BadBinaries {
  pub binaries: Option<BTreeMap<String, Box<BadBinaryInfo>>>,
}

impl BadBinaries {
  pub fn new<F10>(binaries: F10) -> BadBinaries where F10: Into<Option<BTreeMap<String, Box<BadBinaryInfo>>>> {
    BadBinaries {
      binaries: binaries.into(),
    }
  }
}

impl TSerializable for BadBinaries {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BadBinaries> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<BTreeMap<String, Box<BadBinaryInfo>>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, Box<BadBinaryInfo>> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_17 = i_prot.read_string()?;
            let map_val_18 = Box::new(BadBinaryInfo::read_from_in_protocol(i_prot)?);
            val.insert(map_key_17, map_val_18);
          }
          i_prot.read_map_end()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BadBinaries {
      binaries: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BadBinaries");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.binaries {
      o_prot.write_field_begin(&TFieldIdentifier::new("binaries", TType::Map, 10))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        v.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BadBinaryInfo
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct BadBinaryInfo {
  pub reason: Option<String>,
  pub operator: Option<String>,
  pub created_time_nano: Option<i64>,
}

impl BadBinaryInfo {
  pub fn new<F10, F20, F30>(reason: F10, operator: F20, created_time_nano: F30) -> BadBinaryInfo where F10: Into<Option<String>>, F20: Into<Option<String>>, F30: Into<Option<i64>> {
    BadBinaryInfo {
      reason: reason.into(),
      operator: operator.into(),
      created_time_nano: created_time_nano.into(),
    }
  }
}

impl TSerializable for BadBinaryInfo {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<BadBinaryInfo> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<String> = None;
    let mut f_30: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_i64()?;
          f_30 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BadBinaryInfo {
      reason: f_10,
      operator: f_20,
      created_time_nano: f_30,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BadBinaryInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.reason {
      o_prot.write_field_begin(&TFieldIdentifier::new("reason", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.operator {
      o_prot.write_field_begin(&TFieldIdentifier::new("operator", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.created_time_nano {
      o_prot.write_field_begin(&TFieldIdentifier::new("createdTimeNano", TType::I64, 30))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// UpdateDomainInfo
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct UpdateDomainInfo {
  pub description: Option<String>,
  pub owner_email: Option<String>,
  pub data: Option<BTreeMap<String, String>>,
}

impl UpdateDomainInfo {
  pub fn new<F10, F20, F30>(description: F10, owner_email: F20, data: F30) -> UpdateDomainInfo where F10: Into<Option<String>>, F20: Into<Option<String>>, F30: Into<Option<BTreeMap<String, String>>> {
    UpdateDomainInfo {
      description: description.into(),
      owner_email: owner_email.into(),
      data: data.into(),
    }
  }
}

impl TSerializable for UpdateDomainInfo {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UpdateDomainInfo> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<String> = None;
    let mut f_30: Option<BTreeMap<String, String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        30 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_19 = i_prot.read_string()?;
            let map_val_20 = i_prot.read_string()?;
            val.insert(map_key_19, map_val_20);
          }
          i_prot.read_map_end()?;
          f_30 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = UpdateDomainInfo {
      description: f_10,
      owner_email: f_20,
      data: f_30,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UpdateDomainInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.description {
      o_prot.write_field_begin(&TFieldIdentifier::new("description", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.owner_email {
      o_prot.write_field_begin(&TFieldIdentifier::new("ownerEmail", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.data {
      o_prot.write_field_begin(&TFieldIdentifier::new("data", TType::Map, 30))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ClusterReplicationConfiguration
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ClusterReplicationConfiguration {
  pub cluster_name: Option<String>,
}

impl ClusterReplicationConfiguration {
  pub fn new<F10>(cluster_name: F10) -> ClusterReplicationConfiguration where F10: Into<Option<String>> {
    ClusterReplicationConfiguration {
      cluster_name: cluster_name.into(),
    }
  }
}

impl TSerializable for ClusterReplicationConfiguration {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ClusterReplicationConfiguration> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ClusterReplicationConfiguration {
      cluster_name: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ClusterReplicationConfiguration");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.cluster_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("clusterName", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DomainReplicationConfiguration
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DomainReplicationConfiguration {
  pub active_cluster_name: Option<String>,
  pub clusters: Option<Vec<ClusterReplicationConfiguration>>,
  pub active_clusters: Option<Box<ActiveClusters>>,
}

impl DomainReplicationConfiguration {
  pub fn new<F10, F20, F30>(active_cluster_name: F10, clusters: F20, active_clusters: F30) -> DomainReplicationConfiguration where F10: Into<Option<String>>, F20: Into<Option<Vec<ClusterReplicationConfiguration>>>, F30: Into<Option<Box<ActiveClusters>>> {
    DomainReplicationConfiguration {
      active_cluster_name: active_cluster_name.into(),
      clusters: clusters.into(),
      active_clusters: active_clusters.into(),
    }
  }
}

impl TSerializable for DomainReplicationConfiguration {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DomainReplicationConfiguration> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<Vec<ClusterReplicationConfiguration>> = None;
    let mut f_30: Option<Box<ActiveClusters>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<ClusterReplicationConfiguration> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_21 = ClusterReplicationConfiguration::read_from_in_protocol(i_prot)?;
            val.push(list_elem_21);
          }
          i_prot.read_list_end()?;
          f_20 = Some(val);
        },
        30 => {
          let val = Box::new(ActiveClusters::read_from_in_protocol(i_prot)?);
          f_30 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DomainReplicationConfiguration {
      active_cluster_name: f_10,
      clusters: f_20,
      active_clusters: f_30,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DomainReplicationConfiguration");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.active_cluster_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("activeClusterName", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.clusters {
      o_prot.write_field_begin(&TFieldIdentifier::new("clusters", TType::List, 20))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.active_clusters {
      o_prot.write_field_begin(&TFieldIdentifier::new("activeClusters", TType::Struct, 30))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ClusterAttributeScope
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ClusterAttributeScope {
  pub cluster_attributes: Option<BTreeMap<String, Box<ActiveClusterInfo>>>,
}

impl ClusterAttributeScope {
  pub fn new<F10>(cluster_attributes: F10) -> ClusterAttributeScope where F10: Into<Option<BTreeMap<String, Box<ActiveClusterInfo>>>> {
    ClusterAttributeScope {
      cluster_attributes: cluster_attributes.into(),
    }
  }
}

impl TSerializable for ClusterAttributeScope {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ClusterAttributeScope> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<BTreeMap<String, Box<ActiveClusterInfo>>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, Box<ActiveClusterInfo>> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_22 = i_prot.read_string()?;
            let map_val_23 = Box::new(ActiveClusterInfo::read_from_in_protocol(i_prot)?);
            val.insert(map_key_22, map_val_23);
          }
          i_prot.read_map_end()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ClusterAttributeScope {
      cluster_attributes: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ClusterAttributeScope");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.cluster_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("clusterAttributes", TType::Map, 10))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        v.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ActiveClusters
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ActiveClusters {
  pub active_clusters_by_region: Option<BTreeMap<String, Box<ActiveClusterInfo>>>,
  pub active_clusters_by_cluster_attribute: Option<BTreeMap<String, ClusterAttributeScope>>,
}

impl ActiveClusters {
  pub fn new<F10, F11>(active_clusters_by_region: F10, active_clusters_by_cluster_attribute: F11) -> ActiveClusters where F10: Into<Option<BTreeMap<String, Box<ActiveClusterInfo>>>>, F11: Into<Option<BTreeMap<String, ClusterAttributeScope>>> {
    ActiveClusters {
      active_clusters_by_region: active_clusters_by_region.into(),
      active_clusters_by_cluster_attribute: active_clusters_by_cluster_attribute.into(),
    }
  }
}

impl TSerializable for ActiveClusters {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ActiveClusters> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<BTreeMap<String, Box<ActiveClusterInfo>>> = None;
    let mut f_11: Option<BTreeMap<String, ClusterAttributeScope>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, Box<ActiveClusterInfo>> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_24 = i_prot.read_string()?;
            let map_val_25 = Box::new(ActiveClusterInfo::read_from_in_protocol(i_prot)?);
            val.insert(map_key_24, map_val_25);
          }
          i_prot.read_map_end()?;
          f_10 = Some(val);
        },
        11 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, ClusterAttributeScope> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_26 = i_prot.read_string()?;
            let map_val_27 = ClusterAttributeScope::read_from_in_protocol(i_prot)?;
            val.insert(map_key_26, map_val_27);
          }
          i_prot.read_map_end()?;
          f_11 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ActiveClusters {
      active_clusters_by_region: f_10,
      active_clusters_by_cluster_attribute: f_11,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ActiveClusters");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.active_clusters_by_region {
      o_prot.write_field_begin(&TFieldIdentifier::new("activeClustersByRegion", TType::Map, 10))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        v.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.active_clusters_by_cluster_attribute {
      o_prot.write_field_begin(&TFieldIdentifier::new("activeClustersByClusterAttribute", TType::Map, 11))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        v.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ActiveClusterInfo
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ActiveClusterInfo {
  pub active_cluster_name: Option<String>,
  pub failover_version: Option<i64>,
}

impl ActiveClusterInfo {
  pub fn new<F10, F20>(active_cluster_name: F10, failover_version: F20) -> ActiveClusterInfo where F10: Into<Option<String>>, F20: Into<Option<i64>> {
    ActiveClusterInfo {
      active_cluster_name: active_cluster_name.into(),
      failover_version: failover_version.into(),
    }
  }
}

impl TSerializable for ActiveClusterInfo {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ActiveClusterInfo> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_i64()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ActiveClusterInfo {
      active_cluster_name: f_10,
      failover_version: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ActiveClusterInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.active_cluster_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("activeClusterName", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.failover_version {
      o_prot.write_field_begin(&TFieldIdentifier::new("failoverVersion", TType::I64, 20))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// RegisterDomainRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RegisterDomainRequest {
  pub name: Option<String>,
  pub description: Option<String>,
  pub owner_email: Option<String>,
  pub workflow_execution_retention_period_in_days: Option<i32>,
  pub emit_metric: Option<bool>,
  pub clusters: Option<Vec<ClusterReplicationConfiguration>>,
  pub active_cluster_name: Option<String>,
  pub active_clusters_by_region: Option<BTreeMap<String, String>>,
  pub active_clusters: Option<ActiveClusters>,
  pub data: Option<BTreeMap<String, String>>,
  pub security_token: Option<String>,
  pub is_global_domain: Option<bool>,
  pub history_archival_status: Option<ArchivalStatus>,
  pub history_archival_u_r_i: Option<String>,
  pub visibility_archival_status: Option<ArchivalStatus>,
  pub visibility_archival_u_r_i: Option<String>,
}

impl RegisterDomainRequest {
  pub fn new<F10, F20, F30, F40, F50, F60, F70, F75, F76, F80, F90, F120, F130, F140, F150, F160>(name: F10, description: F20, owner_email: F30, workflow_execution_retention_period_in_days: F40, emit_metric: F50, clusters: F60, active_cluster_name: F70, active_clusters_by_region: F75, active_clusters: F76, data: F80, security_token: F90, is_global_domain: F120, history_archival_status: F130, history_archival_u_r_i: F140, visibility_archival_status: F150, visibility_archival_u_r_i: F160) -> RegisterDomainRequest where F10: Into<Option<String>>, F20: Into<Option<String>>, F30: Into<Option<String>>, F40: Into<Option<i32>>, F50: Into<Option<bool>>, F60: Into<Option<Vec<ClusterReplicationConfiguration>>>, F70: Into<Option<String>>, F75: Into<Option<BTreeMap<String, String>>>, F76: Into<Option<ActiveClusters>>, F80: Into<Option<BTreeMap<String, String>>>, F90: Into<Option<String>>, F120: Into<Option<bool>>, F130: Into<Option<ArchivalStatus>>, F140: Into<Option<String>>, F150: Into<Option<ArchivalStatus>>, F160: Into<Option<String>> {
    RegisterDomainRequest {
      name: name.into(),
      description: description.into(),
      owner_email: owner_email.into(),
      workflow_execution_retention_period_in_days: workflow_execution_retention_period_in_days.into(),
      emit_metric: emit_metric.into(),
      clusters: clusters.into(),
      active_cluster_name: active_cluster_name.into(),
      active_clusters_by_region: active_clusters_by_region.into(),
      active_clusters: active_clusters.into(),
      data: data.into(),
      security_token: security_token.into(),
      is_global_domain: is_global_domain.into(),
      history_archival_status: history_archival_status.into(),
      history_archival_u_r_i: history_archival_u_r_i.into(),
      visibility_archival_status: visibility_archival_status.into(),
      visibility_archival_u_r_i: visibility_archival_u_r_i.into(),
    }
  }
}

impl TSerializable for RegisterDomainRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RegisterDomainRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<String> = None;
    let mut f_30: Option<String> = None;
    let mut f_40: Option<i32> = None;
    let mut f_50: Option<bool> = None;
    let mut f_60: Option<Vec<ClusterReplicationConfiguration>> = None;
    let mut f_70: Option<String> = None;
    let mut f_75: Option<BTreeMap<String, String>> = None;
    let mut f_76: Option<ActiveClusters> = None;
    let mut f_80: Option<BTreeMap<String, String>> = None;
    let mut f_90: Option<String> = None;
    let mut f_120: Option<bool> = None;
    let mut f_130: Option<ArchivalStatus> = None;
    let mut f_140: Option<String> = None;
    let mut f_150: Option<ArchivalStatus> = None;
    let mut f_160: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_string()?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_i32()?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_bool()?;
          f_50 = Some(val);
        },
        60 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<ClusterReplicationConfiguration> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_28 = ClusterReplicationConfiguration::read_from_in_protocol(i_prot)?;
            val.push(list_elem_28);
          }
          i_prot.read_list_end()?;
          f_60 = Some(val);
        },
        70 => {
          let val = i_prot.read_string()?;
          f_70 = Some(val);
        },
        75 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_29 = i_prot.read_string()?;
            let map_val_30 = i_prot.read_string()?;
            val.insert(map_key_29, map_val_30);
          }
          i_prot.read_map_end()?;
          f_75 = Some(val);
        },
        76 => {
          let val = ActiveClusters::read_from_in_protocol(i_prot)?;
          f_76 = Some(val);
        },
        80 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_31 = i_prot.read_string()?;
            let map_val_32 = i_prot.read_string()?;
            val.insert(map_key_31, map_val_32);
          }
          i_prot.read_map_end()?;
          f_80 = Some(val);
        },
        90 => {
          let val = i_prot.read_string()?;
          f_90 = Some(val);
        },
        120 => {
          let val = i_prot.read_bool()?;
          f_120 = Some(val);
        },
        130 => {
          let val = ArchivalStatus::read_from_in_protocol(i_prot)?;
          f_130 = Some(val);
        },
        140 => {
          let val = i_prot.read_string()?;
          f_140 = Some(val);
        },
        150 => {
          let val = ArchivalStatus::read_from_in_protocol(i_prot)?;
          f_150 = Some(val);
        },
        160 => {
          let val = i_prot.read_string()?;
          f_160 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RegisterDomainRequest {
      name: f_10,
      description: f_20,
      owner_email: f_30,
      workflow_execution_retention_period_in_days: f_40,
      emit_metric: f_50,
      clusters: f_60,
      active_cluster_name: f_70,
      active_clusters_by_region: f_75,
      active_clusters: f_76,
      data: f_80,
      security_token: f_90,
      is_global_domain: f_120,
      history_archival_status: f_130,
      history_archival_u_r_i: f_140,
      visibility_archival_status: f_150,
      visibility_archival_u_r_i: f_160,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RegisterDomainRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.description {
      o_prot.write_field_begin(&TFieldIdentifier::new("description", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.owner_email {
      o_prot.write_field_begin(&TFieldIdentifier::new("ownerEmail", TType::String, 30))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.workflow_execution_retention_period_in_days {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecutionRetentionPeriodInDays", TType::I32, 40))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.emit_metric {
      o_prot.write_field_begin(&TFieldIdentifier::new("emitMetric", TType::Bool, 50))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.clusters {
      o_prot.write_field_begin(&TFieldIdentifier::new("clusters", TType::List, 60))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.active_cluster_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("activeClusterName", TType::String, 70))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.active_clusters_by_region {
      o_prot.write_field_begin(&TFieldIdentifier::new("activeClustersByRegion", TType::Map, 75))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.active_clusters {
      o_prot.write_field_begin(&TFieldIdentifier::new("activeClusters", TType::Struct, 76))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.data {
      o_prot.write_field_begin(&TFieldIdentifier::new("data", TType::Map, 80))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.security_token {
      o_prot.write_field_begin(&TFieldIdentifier::new("securityToken", TType::String, 90))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_global_domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("isGlobalDomain", TType::Bool, 120))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.history_archival_status {
      o_prot.write_field_begin(&TFieldIdentifier::new("historyArchivalStatus", TType::I32, 130))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.history_archival_u_r_i {
      o_prot.write_field_begin(&TFieldIdentifier::new("historyArchivalURI", TType::String, 140))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.visibility_archival_status {
      o_prot.write_field_begin(&TFieldIdentifier::new("visibilityArchivalStatus", TType::I32, 150))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.visibility_archival_u_r_i {
      o_prot.write_field_begin(&TFieldIdentifier::new("visibilityArchivalURI", TType::String, 160))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ListDomainsRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ListDomainsRequest {
  pub page_size: Option<i32>,
  pub next_page_token: Option<Vec<u8>>,
}

impl ListDomainsRequest {
  pub fn new<F10, F20>(page_size: F10, next_page_token: F20) -> ListDomainsRequest where F10: Into<Option<i32>>, F20: Into<Option<Vec<u8>>> {
    ListDomainsRequest {
      page_size: page_size.into(),
      next_page_token: next_page_token.into(),
    }
  }
}

impl TSerializable for ListDomainsRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ListDomainsRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<i32> = None;
    let mut f_20: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_i32()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_bytes()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ListDomainsRequest {
      page_size: f_10,
      next_page_token: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ListDomainsRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.page_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("pageSize", TType::I32, 10))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.next_page_token {
      o_prot.write_field_begin(&TFieldIdentifier::new("nextPageToken", TType::String, 20))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ListDomainsResponse
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ListDomainsResponse {
  pub domains: Option<Vec<Box<DescribeDomainResponse>>>,
  pub next_page_token: Option<Vec<u8>>,
}

impl ListDomainsResponse {
  pub fn new<F10, F20>(domains: F10, next_page_token: F20) -> ListDomainsResponse where F10: Into<Option<Vec<Box<DescribeDomainResponse>>>>, F20: Into<Option<Vec<u8>>> {
    ListDomainsResponse {
      domains: domains.into(),
      next_page_token: next_page_token.into(),
    }
  }
}

impl TSerializable for ListDomainsResponse {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ListDomainsResponse> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<Vec<Box<DescribeDomainResponse>>> = None;
    let mut f_20: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Box<DescribeDomainResponse>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_33 = Box::new(DescribeDomainResponse::read_from_in_protocol(i_prot)?);
            val.push(list_elem_33);
          }
          i_prot.read_list_end()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_bytes()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ListDomainsResponse {
      domains: f_10,
      next_page_token: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ListDomainsResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.domains {
      o_prot.write_field_begin(&TFieldIdentifier::new("domains", TType::List, 10))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.next_page_token {
      o_prot.write_field_begin(&TFieldIdentifier::new("nextPageToken", TType::String, 20))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DescribeDomainRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DescribeDomainRequest {
  pub name: Option<String>,
  pub uuid: Option<String>,
}

impl DescribeDomainRequest {
  pub fn new<F10, F20>(name: F10, uuid: F20) -> DescribeDomainRequest where F10: Into<Option<String>>, F20: Into<Option<String>> {
    DescribeDomainRequest {
      name: name.into(),
      uuid: uuid.into(),
    }
  }
}

impl TSerializable for DescribeDomainRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DescribeDomainRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DescribeDomainRequest {
      name: f_10,
      uuid: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DescribeDomainRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.uuid {
      o_prot.write_field_begin(&TFieldIdentifier::new("uuid", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DescribeDomainResponse
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DescribeDomainResponse {
  pub domain_info: Option<DomainInfo>,
  pub configuration: Option<DomainConfiguration>,
  pub replication_configuration: Option<DomainReplicationConfiguration>,
  pub failover_version: Option<i64>,
  pub is_global_domain: Option<bool>,
  pub failover_info: Option<FailoverInfo>,
}

impl DescribeDomainResponse {
  pub fn new<F10, F20, F30, F40, F50, F60>(domain_info: F10, configuration: F20, replication_configuration: F30, failover_version: F40, is_global_domain: F50, failover_info: F60) -> DescribeDomainResponse where F10: Into<Option<DomainInfo>>, F20: Into<Option<DomainConfiguration>>, F30: Into<Option<DomainReplicationConfiguration>>, F40: Into<Option<i64>>, F50: Into<Option<bool>>, F60: Into<Option<FailoverInfo>> {
    DescribeDomainResponse {
      domain_info: domain_info.into(),
      configuration: configuration.into(),
      replication_configuration: replication_configuration.into(),
      failover_version: failover_version.into(),
      is_global_domain: is_global_domain.into(),
      failover_info: failover_info.into(),
    }
  }
}

impl TSerializable for DescribeDomainResponse {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DescribeDomainResponse> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<DomainInfo> = None;
    let mut f_20: Option<DomainConfiguration> = None;
    let mut f_30: Option<DomainReplicationConfiguration> = None;
    let mut f_40: Option<i64> = None;
    let mut f_50: Option<bool> = None;
    let mut f_60: Option<FailoverInfo> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = DomainInfo::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        20 => {
          let val = DomainConfiguration::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        30 => {
          let val = DomainReplicationConfiguration::read_from_in_protocol(i_prot)?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_i64()?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_bool()?;
          f_50 = Some(val);
        },
        60 => {
          let val = FailoverInfo::read_from_in_protocol(i_prot)?;
          f_60 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DescribeDomainResponse {
      domain_info: f_10,
      configuration: f_20,
      replication_configuration: f_30,
      failover_version: f_40,
      is_global_domain: f_50,
      failover_info: f_60,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DescribeDomainResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.domain_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("domainInfo", TType::Struct, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.configuration {
      o_prot.write_field_begin(&TFieldIdentifier::new("configuration", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.replication_configuration {
      o_prot.write_field_begin(&TFieldIdentifier::new("replicationConfiguration", TType::Struct, 30))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.failover_version {
      o_prot.write_field_begin(&TFieldIdentifier::new("failoverVersion", TType::I64, 40))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_global_domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("isGlobalDomain", TType::Bool, 50))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.failover_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("failoverInfo", TType::Struct, 60))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// UpdateDomainRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct UpdateDomainRequest {
  pub name: Option<String>,
  pub updated_info: Option<UpdateDomainInfo>,
  pub configuration: Option<DomainConfiguration>,
  pub replication_configuration: Option<DomainReplicationConfiguration>,
  pub security_token: Option<String>,
  pub delete_bad_binary: Option<String>,
  pub failover_timeout_in_seconds: Option<i32>,
}

impl UpdateDomainRequest {
  pub fn new<F10, F20, F30, F40, F50, F60, F70>(name: F10, updated_info: F20, configuration: F30, replication_configuration: F40, security_token: F50, delete_bad_binary: F60, failover_timeout_in_seconds: F70) -> UpdateDomainRequest where F10: Into<Option<String>>, F20: Into<Option<UpdateDomainInfo>>, F30: Into<Option<DomainConfiguration>>, F40: Into<Option<DomainReplicationConfiguration>>, F50: Into<Option<String>>, F60: Into<Option<String>>, F70: Into<Option<i32>> {
    UpdateDomainRequest {
      name: name.into(),
      updated_info: updated_info.into(),
      configuration: configuration.into(),
      replication_configuration: replication_configuration.into(),
      security_token: security_token.into(),
      delete_bad_binary: delete_bad_binary.into(),
      failover_timeout_in_seconds: failover_timeout_in_seconds.into(),
    }
  }
}

impl TSerializable for UpdateDomainRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UpdateDomainRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<UpdateDomainInfo> = None;
    let mut f_30: Option<DomainConfiguration> = None;
    let mut f_40: Option<DomainReplicationConfiguration> = None;
    let mut f_50: Option<String> = None;
    let mut f_60: Option<String> = None;
    let mut f_70: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = UpdateDomainInfo::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        30 => {
          let val = DomainConfiguration::read_from_in_protocol(i_prot)?;
          f_30 = Some(val);
        },
        40 => {
          let val = DomainReplicationConfiguration::read_from_in_protocol(i_prot)?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_string()?;
          f_50 = Some(val);
        },
        60 => {
          let val = i_prot.read_string()?;
          f_60 = Some(val);
        },
        70 => {
          let val = i_prot.read_i32()?;
          f_70 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = UpdateDomainRequest {
      name: f_10,
      updated_info: f_20,
      configuration: f_30,
      replication_configuration: f_40,
      security_token: f_50,
      delete_bad_binary: f_60,
      failover_timeout_in_seconds: f_70,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UpdateDomainRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.updated_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("updatedInfo", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.configuration {
      o_prot.write_field_begin(&TFieldIdentifier::new("configuration", TType::Struct, 30))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.replication_configuration {
      o_prot.write_field_begin(&TFieldIdentifier::new("replicationConfiguration", TType::Struct, 40))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.security_token {
      o_prot.write_field_begin(&TFieldIdentifier::new("securityToken", TType::String, 50))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.delete_bad_binary {
      o_prot.write_field_begin(&TFieldIdentifier::new("deleteBadBinary", TType::String, 60))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.failover_timeout_in_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("failoverTimeoutInSeconds", TType::I32, 70))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// UpdateDomainResponse
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct UpdateDomainResponse {
  pub domain_info: Option<DomainInfo>,
  pub configuration: Option<DomainConfiguration>,
  pub replication_configuration: Option<DomainReplicationConfiguration>,
  pub failover_version: Option<i64>,
  pub is_global_domain: Option<bool>,
}

impl UpdateDomainResponse {
  pub fn new<F10, F20, F30, F40, F50>(domain_info: F10, configuration: F20, replication_configuration: F30, failover_version: F40, is_global_domain: F50) -> UpdateDomainResponse where F10: Into<Option<DomainInfo>>, F20: Into<Option<DomainConfiguration>>, F30: Into<Option<DomainReplicationConfiguration>>, F40: Into<Option<i64>>, F50: Into<Option<bool>> {
    UpdateDomainResponse {
      domain_info: domain_info.into(),
      configuration: configuration.into(),
      replication_configuration: replication_configuration.into(),
      failover_version: failover_version.into(),
      is_global_domain: is_global_domain.into(),
    }
  }
}

impl TSerializable for UpdateDomainResponse {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UpdateDomainResponse> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<DomainInfo> = None;
    let mut f_20: Option<DomainConfiguration> = None;
    let mut f_30: Option<DomainReplicationConfiguration> = None;
    let mut f_40: Option<i64> = None;
    let mut f_50: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = DomainInfo::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        20 => {
          let val = DomainConfiguration::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        30 => {
          let val = DomainReplicationConfiguration::read_from_in_protocol(i_prot)?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_i64()?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_bool()?;
          f_50 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = UpdateDomainResponse {
      domain_info: f_10,
      configuration: f_20,
      replication_configuration: f_30,
      failover_version: f_40,
      is_global_domain: f_50,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UpdateDomainResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.domain_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("domainInfo", TType::Struct, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.configuration {
      o_prot.write_field_begin(&TFieldIdentifier::new("configuration", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.replication_configuration {
      o_prot.write_field_begin(&TFieldIdentifier::new("replicationConfiguration", TType::Struct, 30))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.failover_version {
      o_prot.write_field_begin(&TFieldIdentifier::new("failoverVersion", TType::I64, 40))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_global_domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("isGlobalDomain", TType::Bool, 50))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// FailoverDomainRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct FailoverDomainRequest {
  pub domain_name: Option<String>,
  pub domain_active_cluster_name: Option<String>,
  pub active_clusters: Option<ActiveClusters>,
  pub reason: Option<String>,
}

impl FailoverDomainRequest {
  pub fn new<F10, F20, F30, F40>(domain_name: F10, domain_active_cluster_name: F20, active_clusters: F30, reason: F40) -> FailoverDomainRequest where F10: Into<Option<String>>, F20: Into<Option<String>>, F30: Into<Option<ActiveClusters>>, F40: Into<Option<String>> {
    FailoverDomainRequest {
      domain_name: domain_name.into(),
      domain_active_cluster_name: domain_active_cluster_name.into(),
      active_clusters: active_clusters.into(),
      reason: reason.into(),
    }
  }
}

impl TSerializable for FailoverDomainRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<FailoverDomainRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<String> = None;
    let mut f_30: Option<ActiveClusters> = None;
    let mut f_40: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        30 => {
          let val = ActiveClusters::read_from_in_protocol(i_prot)?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_string()?;
          f_40 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = FailoverDomainRequest {
      domain_name: f_10,
      domain_active_cluster_name: f_20,
      active_clusters: f_30,
      reason: f_40,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("FailoverDomainRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.domain_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("domainName", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.domain_active_cluster_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("domainActiveClusterName", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.active_clusters {
      o_prot.write_field_begin(&TFieldIdentifier::new("activeClusters", TType::Struct, 30))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.reason {
      o_prot.write_field_begin(&TFieldIdentifier::new("reason", TType::String, 40))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// FailoverDomainResponse
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct FailoverDomainResponse {
  pub domain_info: Option<DomainInfo>,
  pub configuration: Option<DomainConfiguration>,
  pub replication_configuration: Option<DomainReplicationConfiguration>,
  pub failover_version: Option<i64>,
  pub is_global_domain: Option<bool>,
}

impl FailoverDomainResponse {
  pub fn new<F10, F20, F30, F40, F50>(domain_info: F10, configuration: F20, replication_configuration: F30, failover_version: F40, is_global_domain: F50) -> FailoverDomainResponse where F10: Into<Option<DomainInfo>>, F20: Into<Option<DomainConfiguration>>, F30: Into<Option<DomainReplicationConfiguration>>, F40: Into<Option<i64>>, F50: Into<Option<bool>> {
    FailoverDomainResponse {
      domain_info: domain_info.into(),
      configuration: configuration.into(),
      replication_configuration: replication_configuration.into(),
      failover_version: failover_version.into(),
      is_global_domain: is_global_domain.into(),
    }
  }
}

impl TSerializable for FailoverDomainResponse {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<FailoverDomainResponse> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<DomainInfo> = None;
    let mut f_20: Option<DomainConfiguration> = None;
    let mut f_30: Option<DomainReplicationConfiguration> = None;
    let mut f_40: Option<i64> = None;
    let mut f_50: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = DomainInfo::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        20 => {
          let val = DomainConfiguration::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        30 => {
          let val = DomainReplicationConfiguration::read_from_in_protocol(i_prot)?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_i64()?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_bool()?;
          f_50 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = FailoverDomainResponse {
      domain_info: f_10,
      configuration: f_20,
      replication_configuration: f_30,
      failover_version: f_40,
      is_global_domain: f_50,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("FailoverDomainResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.domain_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("domainInfo", TType::Struct, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.configuration {
      o_prot.write_field_begin(&TFieldIdentifier::new("configuration", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.replication_configuration {
      o_prot.write_field_begin(&TFieldIdentifier::new("replicationConfiguration", TType::Struct, 30))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.failover_version {
      o_prot.write_field_begin(&TFieldIdentifier::new("failoverVersion", TType::I64, 40))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_global_domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("isGlobalDomain", TType::Bool, 50))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DeprecateDomainRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DeprecateDomainRequest {
  pub name: Option<String>,
  pub security_token: Option<String>,
}

impl DeprecateDomainRequest {
  pub fn new<F10, F20>(name: F10, security_token: F20) -> DeprecateDomainRequest where F10: Into<Option<String>>, F20: Into<Option<String>> {
    DeprecateDomainRequest {
      name: name.into(),
      security_token: security_token.into(),
    }
  }
}

impl TSerializable for DeprecateDomainRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DeprecateDomainRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DeprecateDomainRequest {
      name: f_10,
      security_token: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DeprecateDomainRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.security_token {
      o_prot.write_field_begin(&TFieldIdentifier::new("securityToken", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DeleteDomainRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DeleteDomainRequest {
  pub name: Option<String>,
  pub security_token: Option<String>,
}

impl DeleteDomainRequest {
  pub fn new<F10, F20>(name: F10, security_token: F20) -> DeleteDomainRequest where F10: Into<Option<String>>, F20: Into<Option<String>> {
    DeleteDomainRequest {
      name: name.into(),
      security_token: security_token.into(),
    }
  }
}

impl TSerializable for DeleteDomainRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DeleteDomainRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DeleteDomainRequest {
      name: f_10,
      security_token: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DeleteDomainRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.security_token {
      o_prot.write_field_begin(&TFieldIdentifier::new("securityToken", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ListFailoverHistoryRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ListFailoverHistoryRequest {
  pub filters: Option<Box<ListFailoverHistoryRequestFilters>>,
  pub pagination: Option<Box<PaginationOptions>>,
}

impl ListFailoverHistoryRequest {
  pub fn new<F10, F20>(filters: F10, pagination: F20) -> ListFailoverHistoryRequest where F10: Into<Option<Box<ListFailoverHistoryRequestFilters>>>, F20: Into<Option<Box<PaginationOptions>>> {
    ListFailoverHistoryRequest {
      filters: filters.into(),
      pagination: pagination.into(),
    }
  }
}

impl TSerializable for ListFailoverHistoryRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ListFailoverHistoryRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<Box<ListFailoverHistoryRequestFilters>> = None;
    let mut f_20: Option<Box<PaginationOptions>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = Box::new(ListFailoverHistoryRequestFilters::read_from_in_protocol(i_prot)?);
          f_10 = Some(val);
        },
        20 => {
          let val = Box::new(PaginationOptions::read_from_in_protocol(i_prot)?);
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ListFailoverHistoryRequest {
      filters: f_10,
      pagination: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ListFailoverHistoryRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.filters {
      o_prot.write_field_begin(&TFieldIdentifier::new("filters", TType::Struct, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.pagination {
      o_prot.write_field_begin(&TFieldIdentifier::new("pagination", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ListFailoverHistoryRequestFilters
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ListFailoverHistoryRequestFilters {
  pub domain_i_d: Option<String>,
}

impl ListFailoverHistoryRequestFilters {
  pub fn new<F10>(domain_i_d: F10) -> ListFailoverHistoryRequestFilters where F10: Into<Option<String>> {
    ListFailoverHistoryRequestFilters {
      domain_i_d: domain_i_d.into(),
    }
  }
}

impl TSerializable for ListFailoverHistoryRequestFilters {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ListFailoverHistoryRequestFilters> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ListFailoverHistoryRequestFilters {
      domain_i_d: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ListFailoverHistoryRequestFilters");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.domain_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("domainID", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ListFailoverHistoryResponse
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ListFailoverHistoryResponse {
  pub failover_events: Option<Vec<Box<FailoverEvent>>>,
  pub next_page_token: Option<Vec<u8>>,
}

impl ListFailoverHistoryResponse {
  pub fn new<F10, F20>(failover_events: F10, next_page_token: F20) -> ListFailoverHistoryResponse where F10: Into<Option<Vec<Box<FailoverEvent>>>>, F20: Into<Option<Vec<u8>>> {
    ListFailoverHistoryResponse {
      failover_events: failover_events.into(),
      next_page_token: next_page_token.into(),
    }
  }
}

impl TSerializable for ListFailoverHistoryResponse {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ListFailoverHistoryResponse> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<Vec<Box<FailoverEvent>>> = None;
    let mut f_20: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Box<FailoverEvent>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_34 = Box::new(FailoverEvent::read_from_in_protocol(i_prot)?);
            val.push(list_elem_34);
          }
          i_prot.read_list_end()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_bytes()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ListFailoverHistoryResponse {
      failover_events: f_10,
      next_page_token: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ListFailoverHistoryResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.failover_events {
      o_prot.write_field_begin(&TFieldIdentifier::new("failoverEvents", TType::List, 10))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.next_page_token {
      o_prot.write_field_begin(&TFieldIdentifier::new("nextPageToken", TType::String, 20))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// FailoverEvent
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct FailoverEvent {
  pub id: Option<String>,
  pub created_time: Option<i64>,
  pub failover_type: Option<Box<FailoverType>>,
  pub cluster_failovers: Option<Vec<Box<ClusterFailover>>>,
}

impl FailoverEvent {
  pub fn new<F10, F20, F30, F40>(id: F10, created_time: F20, failover_type: F30, cluster_failovers: F40) -> FailoverEvent where F10: Into<Option<String>>, F20: Into<Option<i64>>, F30: Into<Option<Box<FailoverType>>>, F40: Into<Option<Vec<Box<ClusterFailover>>>> {
    FailoverEvent {
      id: id.into(),
      created_time: created_time.into(),
      failover_type: failover_type.into(),
      cluster_failovers: cluster_failovers.into(),
    }
  }
}

impl TSerializable for FailoverEvent {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<FailoverEvent> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<i64> = None;
    let mut f_30: Option<Box<FailoverType>> = None;
    let mut f_40: Option<Vec<Box<ClusterFailover>>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_i64()?;
          f_20 = Some(val);
        },
        30 => {
          let val = Box::new(FailoverType::read_from_in_protocol(i_prot)?);
          f_30 = Some(val);
        },
        40 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Box<ClusterFailover>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_35 = Box::new(ClusterFailover::read_from_in_protocol(i_prot)?);
            val.push(list_elem_35);
          }
          i_prot.read_list_end()?;
          f_40 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = FailoverEvent {
      id: f_10,
      created_time: f_20,
      failover_type: f_30,
      cluster_failovers: f_40,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("FailoverEvent");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.id {
      o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.created_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("createdTime", TType::I64, 20))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.failover_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("failoverType", TType::I32, 30))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cluster_failovers {
      o_prot.write_field_begin(&TFieldIdentifier::new("clusterFailovers", TType::List, 40))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ClusterFailover
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ClusterFailover {
  pub from_cluster: Option<ActiveClusterInfo>,
  pub to_cluster: Option<ActiveClusterInfo>,
  pub cluster_attribute: Option<Box<ClusterAttribute>>,
}

impl ClusterFailover {
  pub fn new<F10, F20, F30>(from_cluster: F10, to_cluster: F20, cluster_attribute: F30) -> ClusterFailover where F10: Into<Option<ActiveClusterInfo>>, F20: Into<Option<ActiveClusterInfo>>, F30: Into<Option<Box<ClusterAttribute>>> {
    ClusterFailover {
      from_cluster: from_cluster.into(),
      to_cluster: to_cluster.into(),
      cluster_attribute: cluster_attribute.into(),
    }
  }
}

impl TSerializable for ClusterFailover {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ClusterFailover> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<ActiveClusterInfo> = None;
    let mut f_20: Option<ActiveClusterInfo> = None;
    let mut f_30: Option<Box<ClusterAttribute>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = ActiveClusterInfo::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        20 => {
          let val = ActiveClusterInfo::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        30 => {
          let val = Box::new(ClusterAttribute::read_from_in_protocol(i_prot)?);
          f_30 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ClusterFailover {
      from_cluster: f_10,
      to_cluster: f_20,
      cluster_attribute: f_30,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ClusterFailover");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.from_cluster {
      o_prot.write_field_begin(&TFieldIdentifier::new("fromCluster", TType::Struct, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.to_cluster {
      o_prot.write_field_begin(&TFieldIdentifier::new("toCluster", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cluster_attribute {
      o_prot.write_field_begin(&TFieldIdentifier::new("clusterAttribute", TType::Struct, 30))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// StartWorkflowExecutionRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct StartWorkflowExecutionRequest {
  pub domain: Option<String>,
  pub workflow_id: Option<String>,
  pub workflow_type: Option<WorkflowType>,
  pub task_list: Option<TaskList>,
  pub input: Option<Vec<u8>>,
  pub execution_start_to_close_timeout_seconds: Option<i32>,
  pub task_start_to_close_timeout_seconds: Option<i32>,
  pub identity: Option<String>,
  pub request_id: Option<String>,
  pub workflow_id_reuse_policy: Option<WorkflowIdReusePolicy>,
  pub retry_policy: Option<Box<RetryPolicy>>,
  pub cron_schedule: Option<String>,
  pub memo: Option<Memo>,
  pub search_attributes: Option<SearchAttributes>,
  pub header: Option<Header>,
  pub delay_start_seconds: Option<i32>,
  pub jitter_start_seconds: Option<i32>,
  pub first_run_at_timestamp: Option<i64>,
  pub cron_overlap_policy: Option<CronOverlapPolicy>,
  pub active_cluster_selection_policy: Option<Box<ActiveClusterSelectionPolicy>>,
}

impl StartWorkflowExecutionRequest {
  pub fn new<F10, F20, F30, F40, F50, F60, F70, F80, F90, F100, F120, F130, F140, F141, F150, F160, F170, F180, F190, F200>(domain: F10, workflow_id: F20, workflow_type: F30, task_list: F40, input: F50, execution_start_to_close_timeout_seconds: F60, task_start_to_close_timeout_seconds: F70, identity: F80, request_id: F90, workflow_id_reuse_policy: F100, retry_policy: F120, cron_schedule: F130, memo: F140, search_attributes: F141, header: F150, delay_start_seconds: F160, jitter_start_seconds: F170, first_run_at_timestamp: F180, cron_overlap_policy: F190, active_cluster_selection_policy: F200) -> StartWorkflowExecutionRequest where F10: Into<Option<String>>, F20: Into<Option<String>>, F30: Into<Option<WorkflowType>>, F40: Into<Option<TaskList>>, F50: Into<Option<Vec<u8>>>, F60: Into<Option<i32>>, F70: Into<Option<i32>>, F80: Into<Option<String>>, F90: Into<Option<String>>, F100: Into<Option<WorkflowIdReusePolicy>>, F120: Into<Option<Box<RetryPolicy>>>, F130: Into<Option<String>>, F140: Into<Option<Memo>>, F141: Into<Option<SearchAttributes>>, F150: Into<Option<Header>>, F160: Into<Option<i32>>, F170: Into<Option<i32>>, F180: Into<Option<i64>>, F190: Into<Option<CronOverlapPolicy>>, F200: Into<Option<Box<ActiveClusterSelectionPolicy>>> {
    StartWorkflowExecutionRequest {
      domain: domain.into(),
      workflow_id: workflow_id.into(),
      workflow_type: workflow_type.into(),
      task_list: task_list.into(),
      input: input.into(),
      execution_start_to_close_timeout_seconds: execution_start_to_close_timeout_seconds.into(),
      task_start_to_close_timeout_seconds: task_start_to_close_timeout_seconds.into(),
      identity: identity.into(),
      request_id: request_id.into(),
      workflow_id_reuse_policy: workflow_id_reuse_policy.into(),
      retry_policy: retry_policy.into(),
      cron_schedule: cron_schedule.into(),
      memo: memo.into(),
      search_attributes: search_attributes.into(),
      header: header.into(),
      delay_start_seconds: delay_start_seconds.into(),
      jitter_start_seconds: jitter_start_seconds.into(),
      first_run_at_timestamp: first_run_at_timestamp.into(),
      cron_overlap_policy: cron_overlap_policy.into(),
      active_cluster_selection_policy: active_cluster_selection_policy.into(),
    }
  }
}

impl TSerializable for StartWorkflowExecutionRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<StartWorkflowExecutionRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<String> = None;
    let mut f_30: Option<WorkflowType> = None;
    let mut f_40: Option<TaskList> = None;
    let mut f_50: Option<Vec<u8>> = None;
    let mut f_60: Option<i32> = None;
    let mut f_70: Option<i32> = None;
    let mut f_80: Option<String> = None;
    let mut f_90: Option<String> = None;
    let mut f_100: Option<WorkflowIdReusePolicy> = None;
    let mut f_120: Option<Box<RetryPolicy>> = None;
    let mut f_130: Option<String> = None;
    let mut f_140: Option<Memo> = None;
    let mut f_141: Option<SearchAttributes> = None;
    let mut f_150: Option<Header> = None;
    let mut f_160: Option<i32> = None;
    let mut f_170: Option<i32> = None;
    let mut f_180: Option<i64> = None;
    let mut f_190: Option<CronOverlapPolicy> = None;
    let mut f_200: Option<Box<ActiveClusterSelectionPolicy>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        30 => {
          let val = WorkflowType::read_from_in_protocol(i_prot)?;
          f_30 = Some(val);
        },
        40 => {
          let val = TaskList::read_from_in_protocol(i_prot)?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_bytes()?;
          f_50 = Some(val);
        },
        60 => {
          let val = i_prot.read_i32()?;
          f_60 = Some(val);
        },
        70 => {
          let val = i_prot.read_i32()?;
          f_70 = Some(val);
        },
        80 => {
          let val = i_prot.read_string()?;
          f_80 = Some(val);
        },
        90 => {
          let val = i_prot.read_string()?;
          f_90 = Some(val);
        },
        100 => {
          let val = WorkflowIdReusePolicy::read_from_in_protocol(i_prot)?;
          f_100 = Some(val);
        },
        120 => {
          let val = Box::new(RetryPolicy::read_from_in_protocol(i_prot)?);
          f_120 = Some(val);
        },
        130 => {
          let val = i_prot.read_string()?;
          f_130 = Some(val);
        },
        140 => {
          let val = Memo::read_from_in_protocol(i_prot)?;
          f_140 = Some(val);
        },
        141 => {
          let val = SearchAttributes::read_from_in_protocol(i_prot)?;
          f_141 = Some(val);
        },
        150 => {
          let val = Header::read_from_in_protocol(i_prot)?;
          f_150 = Some(val);
        },
        160 => {
          let val = i_prot.read_i32()?;
          f_160 = Some(val);
        },
        170 => {
          let val = i_prot.read_i32()?;
          f_170 = Some(val);
        },
        180 => {
          let val = i_prot.read_i64()?;
          f_180 = Some(val);
        },
        190 => {
          let val = CronOverlapPolicy::read_from_in_protocol(i_prot)?;
          f_190 = Some(val);
        },
        200 => {
          let val = Box::new(ActiveClusterSelectionPolicy::read_from_in_protocol(i_prot)?);
          f_200 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = StartWorkflowExecutionRequest {
      domain: f_10,
      workflow_id: f_20,
      workflow_type: f_30,
      task_list: f_40,
      input: f_50,
      execution_start_to_close_timeout_seconds: f_60,
      task_start_to_close_timeout_seconds: f_70,
      identity: f_80,
      request_id: f_90,
      workflow_id_reuse_policy: f_100,
      retry_policy: f_120,
      cron_schedule: f_130,
      memo: f_140,
      search_attributes: f_141,
      header: f_150,
      delay_start_seconds: f_160,
      jitter_start_seconds: f_170,
      first_run_at_timestamp: f_180,
      cron_overlap_policy: f_190,
      active_cluster_selection_policy: f_200,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("StartWorkflowExecutionRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowId", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowType", TType::Struct, 30))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.task_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskList", TType::Struct, 40))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.input {
      o_prot.write_field_begin(&TFieldIdentifier::new("input", TType::String, 50))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.execution_start_to_close_timeout_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("executionStartToCloseTimeoutSeconds", TType::I32, 60))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.task_start_to_close_timeout_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskStartToCloseTimeoutSeconds", TType::I32, 70))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.identity {
      o_prot.write_field_begin(&TFieldIdentifier::new("identity", TType::String, 80))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.request_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 90))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_id_reuse_policy {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowIdReusePolicy", TType::I32, 100))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.retry_policy {
      o_prot.write_field_begin(&TFieldIdentifier::new("retryPolicy", TType::Struct, 120))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cron_schedule {
      o_prot.write_field_begin(&TFieldIdentifier::new("cronSchedule", TType::String, 130))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.memo {
      o_prot.write_field_begin(&TFieldIdentifier::new("memo", TType::Struct, 140))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.search_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("searchAttributes", TType::Struct, 141))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.header {
      o_prot.write_field_begin(&TFieldIdentifier::new("header", TType::Struct, 150))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.delay_start_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("delayStartSeconds", TType::I32, 160))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.jitter_start_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("jitterStartSeconds", TType::I32, 170))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.first_run_at_timestamp {
      o_prot.write_field_begin(&TFieldIdentifier::new("firstRunAtTimestamp", TType::I64, 180))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cron_overlap_policy {
      o_prot.write_field_begin(&TFieldIdentifier::new("cronOverlapPolicy", TType::I32, 190))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.active_cluster_selection_policy {
      o_prot.write_field_begin(&TFieldIdentifier::new("activeClusterSelectionPolicy", TType::Struct, 200))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// StartWorkflowExecutionResponse
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct StartWorkflowExecutionResponse {
  pub run_id: Option<String>,
}

impl StartWorkflowExecutionResponse {
  pub fn new<F10>(run_id: F10) -> StartWorkflowExecutionResponse where F10: Into<Option<String>> {
    StartWorkflowExecutionResponse {
      run_id: run_id.into(),
    }
  }
}

impl TSerializable for StartWorkflowExecutionResponse {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<StartWorkflowExecutionResponse> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = StartWorkflowExecutionResponse {
      run_id: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("StartWorkflowExecutionResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.run_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("runId", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// StartWorkflowExecutionAsyncRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct StartWorkflowExecutionAsyncRequest {
  pub request: Option<StartWorkflowExecutionRequest>,
}

impl StartWorkflowExecutionAsyncRequest {
  pub fn new<F10>(request: F10) -> StartWorkflowExecutionAsyncRequest where F10: Into<Option<StartWorkflowExecutionRequest>> {
    StartWorkflowExecutionAsyncRequest {
      request: request.into(),
    }
  }
}

impl TSerializable for StartWorkflowExecutionAsyncRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<StartWorkflowExecutionAsyncRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<StartWorkflowExecutionRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = StartWorkflowExecutionRequest::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = StartWorkflowExecutionAsyncRequest {
      request: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("StartWorkflowExecutionAsyncRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.request {
      o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// StartWorkflowExecutionAsyncResponse
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct StartWorkflowExecutionAsyncResponse {
}

impl StartWorkflowExecutionAsyncResponse {
  pub fn new() -> StartWorkflowExecutionAsyncResponse {
    StartWorkflowExecutionAsyncResponse {}
  }
}

impl TSerializable for StartWorkflowExecutionAsyncResponse {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<StartWorkflowExecutionAsyncResponse> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      i_prot.skip(field_ident.field_type)?;
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = StartWorkflowExecutionAsyncResponse {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("StartWorkflowExecutionAsyncResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// RestartWorkflowExecutionResponse
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RestartWorkflowExecutionResponse {
  pub run_id: Option<String>,
}

impl RestartWorkflowExecutionResponse {
  pub fn new<F10>(run_id: F10) -> RestartWorkflowExecutionResponse where F10: Into<Option<String>> {
    RestartWorkflowExecutionResponse {
      run_id: run_id.into(),
    }
  }
}

impl TSerializable for RestartWorkflowExecutionResponse {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RestartWorkflowExecutionResponse> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RestartWorkflowExecutionResponse {
      run_id: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RestartWorkflowExecutionResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.run_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("runId", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DiagnoseWorkflowExecutionRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DiagnoseWorkflowExecutionRequest {
  pub domain: Option<String>,
  pub workflow_execution: Option<WorkflowExecution>,
  pub identity: Option<String>,
}

impl DiagnoseWorkflowExecutionRequest {
  pub fn new<F10, F20, F30>(domain: F10, workflow_execution: F20, identity: F30) -> DiagnoseWorkflowExecutionRequest where F10: Into<Option<String>>, F20: Into<Option<WorkflowExecution>>, F30: Into<Option<String>> {
    DiagnoseWorkflowExecutionRequest {
      domain: domain.into(),
      workflow_execution: workflow_execution.into(),
      identity: identity.into(),
    }
  }
}

impl TSerializable for DiagnoseWorkflowExecutionRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DiagnoseWorkflowExecutionRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<WorkflowExecution> = None;
    let mut f_30: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = WorkflowExecution::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_string()?;
          f_30 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DiagnoseWorkflowExecutionRequest {
      domain: f_10,
      workflow_execution: f_20,
      identity: f_30,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DiagnoseWorkflowExecutionRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_execution {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecution", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.identity {
      o_prot.write_field_begin(&TFieldIdentifier::new("identity", TType::String, 30))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DiagnoseWorkflowExecutionResponse
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DiagnoseWorkflowExecutionResponse {
  pub domain: Option<String>,
  pub diagnostic_workflow_execution: Option<WorkflowExecution>,
}

impl DiagnoseWorkflowExecutionResponse {
  pub fn new<F10, F20>(domain: F10, diagnostic_workflow_execution: F20) -> DiagnoseWorkflowExecutionResponse where F10: Into<Option<String>>, F20: Into<Option<WorkflowExecution>> {
    DiagnoseWorkflowExecutionResponse {
      domain: domain.into(),
      diagnostic_workflow_execution: diagnostic_workflow_execution.into(),
    }
  }
}

impl TSerializable for DiagnoseWorkflowExecutionResponse {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DiagnoseWorkflowExecutionResponse> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<WorkflowExecution> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = WorkflowExecution::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DiagnoseWorkflowExecutionResponse {
      domain: f_10,
      diagnostic_workflow_execution: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DiagnoseWorkflowExecutionResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.diagnostic_workflow_execution {
      o_prot.write_field_begin(&TFieldIdentifier::new("diagnosticWorkflowExecution", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// PollForDecisionTaskRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PollForDecisionTaskRequest {
  pub domain: Option<String>,
  pub task_list: Option<TaskList>,
  pub identity: Option<String>,
  pub binary_checksum: Option<String>,
}

impl PollForDecisionTaskRequest {
  pub fn new<F10, F20, F30, F40>(domain: F10, task_list: F20, identity: F30, binary_checksum: F40) -> PollForDecisionTaskRequest where F10: Into<Option<String>>, F20: Into<Option<TaskList>>, F30: Into<Option<String>>, F40: Into<Option<String>> {
    PollForDecisionTaskRequest {
      domain: domain.into(),
      task_list: task_list.into(),
      identity: identity.into(),
      binary_checksum: binary_checksum.into(),
    }
  }
}

impl TSerializable for PollForDecisionTaskRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PollForDecisionTaskRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<TaskList> = None;
    let mut f_30: Option<String> = None;
    let mut f_40: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = TaskList::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_string()?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_string()?;
          f_40 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = PollForDecisionTaskRequest {
      domain: f_10,
      task_list: f_20,
      identity: f_30,
      binary_checksum: f_40,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PollForDecisionTaskRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.task_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskList", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.identity {
      o_prot.write_field_begin(&TFieldIdentifier::new("identity", TType::String, 30))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.binary_checksum {
      o_prot.write_field_begin(&TFieldIdentifier::new("binaryChecksum", TType::String, 40))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// PollForDecisionTaskResponse
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PollForDecisionTaskResponse {
  pub task_token: Option<Vec<u8>>,
  pub workflow_execution: Option<WorkflowExecution>,
  pub workflow_type: Option<WorkflowType>,
  pub previous_started_event_id: Option<i64>,
  pub started_event_id: Option<i64>,
  pub attempt: Option<i64>,
  pub backlog_count_hint: Option<i64>,
  pub history: Option<History>,
  pub next_page_token: Option<Vec<u8>>,
  pub query: Option<Box<WorkflowQuery>>,
  pub workflow_execution_task_list: Option<TaskList>,
  pub scheduled_timestamp: Option<i64>,
  pub started_timestamp: Option<i64>,
  pub queries: Option<BTreeMap<String, Box<WorkflowQuery>>>,
  pub next_event_id: Option<i64>,
  pub total_history_bytes: Option<i64>,
  pub auto_config_hint: Option<Box<AutoConfigHint>>,
}

impl PollForDecisionTaskResponse {
  pub fn new<F10, F20, F30, F40, F50, F51, F54, F60, F70, F80, F90, F100, F110, F120, F130, F140, F150>(task_token: F10, workflow_execution: F20, workflow_type: F30, previous_started_event_id: F40, started_event_id: F50, attempt: F51, backlog_count_hint: F54, history: F60, next_page_token: F70, query: F80, workflow_execution_task_list: F90, scheduled_timestamp: F100, started_timestamp: F110, queries: F120, next_event_id: F130, total_history_bytes: F140, auto_config_hint: F150) -> PollForDecisionTaskResponse where F10: Into<Option<Vec<u8>>>, F20: Into<Option<WorkflowExecution>>, F30: Into<Option<WorkflowType>>, F40: Into<Option<i64>>, F50: Into<Option<i64>>, F51: Into<Option<i64>>, F54: Into<Option<i64>>, F60: Into<Option<History>>, F70: Into<Option<Vec<u8>>>, F80: Into<Option<Box<WorkflowQuery>>>, F90: Into<Option<TaskList>>, F100: Into<Option<i64>>, F110: Into<Option<i64>>, F120: Into<Option<BTreeMap<String, Box<WorkflowQuery>>>>, F130: Into<Option<i64>>, F140: Into<Option<i64>>, F150: Into<Option<Box<AutoConfigHint>>> {
    PollForDecisionTaskResponse {
      task_token: task_token.into(),
      workflow_execution: workflow_execution.into(),
      workflow_type: workflow_type.into(),
      previous_started_event_id: previous_started_event_id.into(),
      started_event_id: started_event_id.into(),
      attempt: attempt.into(),
      backlog_count_hint: backlog_count_hint.into(),
      history: history.into(),
      next_page_token: next_page_token.into(),
      query: query.into(),
      workflow_execution_task_list: workflow_execution_task_list.into(),
      scheduled_timestamp: scheduled_timestamp.into(),
      started_timestamp: started_timestamp.into(),
      queries: queries.into(),
      next_event_id: next_event_id.into(),
      total_history_bytes: total_history_bytes.into(),
      auto_config_hint: auto_config_hint.into(),
    }
  }
}

impl TSerializable for PollForDecisionTaskResponse {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PollForDecisionTaskResponse> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<Vec<u8>> = None;
    let mut f_20: Option<WorkflowExecution> = None;
    let mut f_30: Option<WorkflowType> = None;
    let mut f_40: Option<i64> = None;
    let mut f_50: Option<i64> = None;
    let mut f_51: Option<i64> = None;
    let mut f_54: Option<i64> = None;
    let mut f_60: Option<History> = None;
    let mut f_70: Option<Vec<u8>> = None;
    let mut f_80: Option<Box<WorkflowQuery>> = None;
    let mut f_90: Option<TaskList> = None;
    let mut f_100: Option<i64> = None;
    let mut f_110: Option<i64> = None;
    let mut f_120: Option<BTreeMap<String, Box<WorkflowQuery>>> = None;
    let mut f_130: Option<i64> = None;
    let mut f_140: Option<i64> = None;
    let mut f_150: Option<Box<AutoConfigHint>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_bytes()?;
          f_10 = Some(val);
        },
        20 => {
          let val = WorkflowExecution::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        30 => {
          let val = WorkflowType::read_from_in_protocol(i_prot)?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_i64()?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_i64()?;
          f_50 = Some(val);
        },
        51 => {
          let val = i_prot.read_i64()?;
          f_51 = Some(val);
        },
        54 => {
          let val = i_prot.read_i64()?;
          f_54 = Some(val);
        },
        60 => {
          let val = History::read_from_in_protocol(i_prot)?;
          f_60 = Some(val);
        },
        70 => {
          let val = i_prot.read_bytes()?;
          f_70 = Some(val);
        },
        80 => {
          let val = Box::new(WorkflowQuery::read_from_in_protocol(i_prot)?);
          f_80 = Some(val);
        },
        90 => {
          let val = TaskList::read_from_in_protocol(i_prot)?;
          f_90 = Some(val);
        },
        100 => {
          let val = i_prot.read_i64()?;
          f_100 = Some(val);
        },
        110 => {
          let val = i_prot.read_i64()?;
          f_110 = Some(val);
        },
        120 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, Box<WorkflowQuery>> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_36 = i_prot.read_string()?;
            let map_val_37 = Box::new(WorkflowQuery::read_from_in_protocol(i_prot)?);
            val.insert(map_key_36, map_val_37);
          }
          i_prot.read_map_end()?;
          f_120 = Some(val);
        },
        130 => {
          let val = i_prot.read_i64()?;
          f_130 = Some(val);
        },
        140 => {
          let val = i_prot.read_i64()?;
          f_140 = Some(val);
        },
        150 => {
          let val = Box::new(AutoConfigHint::read_from_in_protocol(i_prot)?);
          f_150 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = PollForDecisionTaskResponse {
      task_token: f_10,
      workflow_execution: f_20,
      workflow_type: f_30,
      previous_started_event_id: f_40,
      started_event_id: f_50,
      attempt: f_51,
      backlog_count_hint: f_54,
      history: f_60,
      next_page_token: f_70,
      query: f_80,
      workflow_execution_task_list: f_90,
      scheduled_timestamp: f_100,
      started_timestamp: f_110,
      queries: f_120,
      next_event_id: f_130,
      total_history_bytes: f_140,
      auto_config_hint: f_150,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PollForDecisionTaskResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.task_token {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskToken", TType::String, 10))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_execution {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecution", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowType", TType::Struct, 30))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.previous_started_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("previousStartedEventId", TType::I64, 40))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.started_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("startedEventId", TType::I64, 50))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.attempt {
      o_prot.write_field_begin(&TFieldIdentifier::new("attempt", TType::I64, 51))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.backlog_count_hint {
      o_prot.write_field_begin(&TFieldIdentifier::new("backlogCountHint", TType::I64, 54))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.history {
      o_prot.write_field_begin(&TFieldIdentifier::new("history", TType::Struct, 60))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.next_page_token {
      o_prot.write_field_begin(&TFieldIdentifier::new("nextPageToken", TType::String, 70))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.query {
      o_prot.write_field_begin(&TFieldIdentifier::new("query", TType::Struct, 80))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_execution_task_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("WorkflowExecutionTaskList", TType::Struct, 90))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.scheduled_timestamp {
      o_prot.write_field_begin(&TFieldIdentifier::new("scheduledTimestamp", TType::I64, 100))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.started_timestamp {
      o_prot.write_field_begin(&TFieldIdentifier::new("startedTimestamp", TType::I64, 110))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.queries {
      o_prot.write_field_begin(&TFieldIdentifier::new("queries", TType::Map, 120))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        v.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.next_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("nextEventId", TType::I64, 130))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.total_history_bytes {
      o_prot.write_field_begin(&TFieldIdentifier::new("totalHistoryBytes", TType::I64, 140))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.auto_config_hint {
      o_prot.write_field_begin(&TFieldIdentifier::new("autoConfigHint", TType::Struct, 150))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// StickyExecutionAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct StickyExecutionAttributes {
  pub worker_task_list: Option<TaskList>,
  pub schedule_to_start_timeout_seconds: Option<i32>,
}

impl StickyExecutionAttributes {
  pub fn new<F10, F20>(worker_task_list: F10, schedule_to_start_timeout_seconds: F20) -> StickyExecutionAttributes where F10: Into<Option<TaskList>>, F20: Into<Option<i32>> {
    StickyExecutionAttributes {
      worker_task_list: worker_task_list.into(),
      schedule_to_start_timeout_seconds: schedule_to_start_timeout_seconds.into(),
    }
  }
}

impl TSerializable for StickyExecutionAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<StickyExecutionAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<TaskList> = None;
    let mut f_20: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = TaskList::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_i32()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = StickyExecutionAttributes {
      worker_task_list: f_10,
      schedule_to_start_timeout_seconds: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("StickyExecutionAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.worker_task_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("workerTaskList", TType::Struct, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.schedule_to_start_timeout_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("scheduleToStartTimeoutSeconds", TType::I32, 20))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// RespondDecisionTaskCompletedRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RespondDecisionTaskCompletedRequest {
  pub task_token: Option<Vec<u8>>,
  pub decisions: Option<Vec<Decision>>,
  pub execution_context: Option<Vec<u8>>,
  pub identity: Option<String>,
  pub sticky_attributes: Option<StickyExecutionAttributes>,
  pub return_new_decision_task: Option<bool>,
  pub force_create_new_decision_task: Option<bool>,
  pub binary_checksum: Option<String>,
  pub query_results: Option<BTreeMap<String, Box<WorkflowQueryResult>>>,
}

impl RespondDecisionTaskCompletedRequest {
  pub fn new<F10, F20, F30, F40, F50, F60, F70, F80, F90>(task_token: F10, decisions: F20, execution_context: F30, identity: F40, sticky_attributes: F50, return_new_decision_task: F60, force_create_new_decision_task: F70, binary_checksum: F80, query_results: F90) -> RespondDecisionTaskCompletedRequest where F10: Into<Option<Vec<u8>>>, F20: Into<Option<Vec<Decision>>>, F30: Into<Option<Vec<u8>>>, F40: Into<Option<String>>, F50: Into<Option<StickyExecutionAttributes>>, F60: Into<Option<bool>>, F70: Into<Option<bool>>, F80: Into<Option<String>>, F90: Into<Option<BTreeMap<String, Box<WorkflowQueryResult>>>> {
    RespondDecisionTaskCompletedRequest {
      task_token: task_token.into(),
      decisions: decisions.into(),
      execution_context: execution_context.into(),
      identity: identity.into(),
      sticky_attributes: sticky_attributes.into(),
      return_new_decision_task: return_new_decision_task.into(),
      force_create_new_decision_task: force_create_new_decision_task.into(),
      binary_checksum: binary_checksum.into(),
      query_results: query_results.into(),
    }
  }
}

impl TSerializable for RespondDecisionTaskCompletedRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RespondDecisionTaskCompletedRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<Vec<u8>> = None;
    let mut f_20: Option<Vec<Decision>> = None;
    let mut f_30: Option<Vec<u8>> = None;
    let mut f_40: Option<String> = None;
    let mut f_50: Option<StickyExecutionAttributes> = None;
    let mut f_60: Option<bool> = None;
    let mut f_70: Option<bool> = None;
    let mut f_80: Option<String> = None;
    let mut f_90: Option<BTreeMap<String, Box<WorkflowQueryResult>>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_bytes()?;
          f_10 = Some(val);
        },
        20 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Decision> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_38 = Decision::read_from_in_protocol(i_prot)?;
            val.push(list_elem_38);
          }
          i_prot.read_list_end()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_bytes()?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_string()?;
          f_40 = Some(val);
        },
        50 => {
          let val = StickyExecutionAttributes::read_from_in_protocol(i_prot)?;
          f_50 = Some(val);
        },
        60 => {
          let val = i_prot.read_bool()?;
          f_60 = Some(val);
        },
        70 => {
          let val = i_prot.read_bool()?;
          f_70 = Some(val);
        },
        80 => {
          let val = i_prot.read_string()?;
          f_80 = Some(val);
        },
        90 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, Box<WorkflowQueryResult>> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_39 = i_prot.read_string()?;
            let map_val_40 = Box::new(WorkflowQueryResult::read_from_in_protocol(i_prot)?);
            val.insert(map_key_39, map_val_40);
          }
          i_prot.read_map_end()?;
          f_90 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RespondDecisionTaskCompletedRequest {
      task_token: f_10,
      decisions: f_20,
      execution_context: f_30,
      identity: f_40,
      sticky_attributes: f_50,
      return_new_decision_task: f_60,
      force_create_new_decision_task: f_70,
      binary_checksum: f_80,
      query_results: f_90,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RespondDecisionTaskCompletedRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.task_token {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskToken", TType::String, 10))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.decisions {
      o_prot.write_field_begin(&TFieldIdentifier::new("decisions", TType::List, 20))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.execution_context {
      o_prot.write_field_begin(&TFieldIdentifier::new("executionContext", TType::String, 30))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.identity {
      o_prot.write_field_begin(&TFieldIdentifier::new("identity", TType::String, 40))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.sticky_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("stickyAttributes", TType::Struct, 50))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.return_new_decision_task {
      o_prot.write_field_begin(&TFieldIdentifier::new("returnNewDecisionTask", TType::Bool, 60))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.force_create_new_decision_task {
      o_prot.write_field_begin(&TFieldIdentifier::new("forceCreateNewDecisionTask", TType::Bool, 70))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.binary_checksum {
      o_prot.write_field_begin(&TFieldIdentifier::new("binaryChecksum", TType::String, 80))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.query_results {
      o_prot.write_field_begin(&TFieldIdentifier::new("queryResults", TType::Map, 90))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        v.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// RespondDecisionTaskCompletedResponse
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RespondDecisionTaskCompletedResponse {
  pub decision_task: Option<PollForDecisionTaskResponse>,
  pub activities_to_dispatch_locally: Option<BTreeMap<String, ActivityLocalDispatchInfo>>,
}

impl RespondDecisionTaskCompletedResponse {
  pub fn new<F10, F20>(decision_task: F10, activities_to_dispatch_locally: F20) -> RespondDecisionTaskCompletedResponse where F10: Into<Option<PollForDecisionTaskResponse>>, F20: Into<Option<BTreeMap<String, ActivityLocalDispatchInfo>>> {
    RespondDecisionTaskCompletedResponse {
      decision_task: decision_task.into(),
      activities_to_dispatch_locally: activities_to_dispatch_locally.into(),
    }
  }
}

impl TSerializable for RespondDecisionTaskCompletedResponse {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RespondDecisionTaskCompletedResponse> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<PollForDecisionTaskResponse> = None;
    let mut f_20: Option<BTreeMap<String, ActivityLocalDispatchInfo>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = PollForDecisionTaskResponse::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        20 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, ActivityLocalDispatchInfo> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_41 = i_prot.read_string()?;
            let map_val_42 = ActivityLocalDispatchInfo::read_from_in_protocol(i_prot)?;
            val.insert(map_key_41, map_val_42);
          }
          i_prot.read_map_end()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RespondDecisionTaskCompletedResponse {
      decision_task: f_10,
      activities_to_dispatch_locally: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RespondDecisionTaskCompletedResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.decision_task {
      o_prot.write_field_begin(&TFieldIdentifier::new("decisionTask", TType::Struct, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.activities_to_dispatch_locally {
      o_prot.write_field_begin(&TFieldIdentifier::new("activitiesToDispatchLocally", TType::Map, 20))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        v.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// RespondDecisionTaskFailedRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RespondDecisionTaskFailedRequest {
  pub task_token: Option<Vec<u8>>,
  pub cause: Option<DecisionTaskFailedCause>,
  pub details: Option<Vec<u8>>,
  pub identity: Option<String>,
  pub binary_checksum: Option<String>,
}

impl RespondDecisionTaskFailedRequest {
  pub fn new<F10, F20, F30, F40, F50>(task_token: F10, cause: F20, details: F30, identity: F40, binary_checksum: F50) -> RespondDecisionTaskFailedRequest where F10: Into<Option<Vec<u8>>>, F20: Into<Option<DecisionTaskFailedCause>>, F30: Into<Option<Vec<u8>>>, F40: Into<Option<String>>, F50: Into<Option<String>> {
    RespondDecisionTaskFailedRequest {
      task_token: task_token.into(),
      cause: cause.into(),
      details: details.into(),
      identity: identity.into(),
      binary_checksum: binary_checksum.into(),
    }
  }
}

impl TSerializable for RespondDecisionTaskFailedRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RespondDecisionTaskFailedRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<Vec<u8>> = None;
    let mut f_20: Option<DecisionTaskFailedCause> = None;
    let mut f_30: Option<Vec<u8>> = None;
    let mut f_40: Option<String> = None;
    let mut f_50: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_bytes()?;
          f_10 = Some(val);
        },
        20 => {
          let val = DecisionTaskFailedCause::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_bytes()?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_string()?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_string()?;
          f_50 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RespondDecisionTaskFailedRequest {
      task_token: f_10,
      cause: f_20,
      details: f_30,
      identity: f_40,
      binary_checksum: f_50,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RespondDecisionTaskFailedRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.task_token {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskToken", TType::String, 10))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cause {
      o_prot.write_field_begin(&TFieldIdentifier::new("cause", TType::I32, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.details {
      o_prot.write_field_begin(&TFieldIdentifier::new("details", TType::String, 30))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.identity {
      o_prot.write_field_begin(&TFieldIdentifier::new("identity", TType::String, 40))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.binary_checksum {
      o_prot.write_field_begin(&TFieldIdentifier::new("binaryChecksum", TType::String, 50))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// PollForActivityTaskRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PollForActivityTaskRequest {
  pub domain: Option<String>,
  pub task_list: Option<TaskList>,
  pub identity: Option<String>,
  pub task_list_metadata: Option<TaskListMetadata>,
}

impl PollForActivityTaskRequest {
  pub fn new<F10, F20, F30, F40>(domain: F10, task_list: F20, identity: F30, task_list_metadata: F40) -> PollForActivityTaskRequest where F10: Into<Option<String>>, F20: Into<Option<TaskList>>, F30: Into<Option<String>>, F40: Into<Option<TaskListMetadata>> {
    PollForActivityTaskRequest {
      domain: domain.into(),
      task_list: task_list.into(),
      identity: identity.into(),
      task_list_metadata: task_list_metadata.into(),
    }
  }
}

impl TSerializable for PollForActivityTaskRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PollForActivityTaskRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<TaskList> = None;
    let mut f_30: Option<String> = None;
    let mut f_40: Option<TaskListMetadata> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = TaskList::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_string()?;
          f_30 = Some(val);
        },
        40 => {
          let val = TaskListMetadata::read_from_in_protocol(i_prot)?;
          f_40 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = PollForActivityTaskRequest {
      domain: f_10,
      task_list: f_20,
      identity: f_30,
      task_list_metadata: f_40,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PollForActivityTaskRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.task_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskList", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.identity {
      o_prot.write_field_begin(&TFieldIdentifier::new("identity", TType::String, 30))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.task_list_metadata {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskListMetadata", TType::Struct, 40))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// PollForActivityTaskResponse
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PollForActivityTaskResponse {
  pub task_token: Option<Vec<u8>>,
  pub workflow_execution: Option<WorkflowExecution>,
  pub activity_id: Option<String>,
  pub activity_type: Option<ActivityType>,
  pub input: Option<Vec<u8>>,
  pub scheduled_timestamp: Option<i64>,
  pub schedule_to_close_timeout_seconds: Option<i32>,
  pub started_timestamp: Option<i64>,
  pub start_to_close_timeout_seconds: Option<i32>,
  pub heartbeat_timeout_seconds: Option<i32>,
  pub attempt: Option<i32>,
  pub scheduled_timestamp_of_this_attempt: Option<i64>,
  pub heartbeat_details: Option<Vec<u8>>,
  pub workflow_type: Option<WorkflowType>,
  pub workflow_domain: Option<String>,
  pub header: Option<Header>,
  pub auto_config_hint: Option<Box<AutoConfigHint>>,
}

impl PollForActivityTaskResponse {
  pub fn new<F10, F20, F30, F40, F50, F70, F80, F90, F100, F110, F120, F130, F140, F150, F160, F170, F180>(task_token: F10, workflow_execution: F20, activity_id: F30, activity_type: F40, input: F50, scheduled_timestamp: F70, schedule_to_close_timeout_seconds: F80, started_timestamp: F90, start_to_close_timeout_seconds: F100, heartbeat_timeout_seconds: F110, attempt: F120, scheduled_timestamp_of_this_attempt: F130, heartbeat_details: F140, workflow_type: F150, workflow_domain: F160, header: F170, auto_config_hint: F180) -> PollForActivityTaskResponse where F10: Into<Option<Vec<u8>>>, F20: Into<Option<WorkflowExecution>>, F30: Into<Option<String>>, F40: Into<Option<ActivityType>>, F50: Into<Option<Vec<u8>>>, F70: Into<Option<i64>>, F80: Into<Option<i32>>, F90: Into<Option<i64>>, F100: Into<Option<i32>>, F110: Into<Option<i32>>, F120: Into<Option<i32>>, F130: Into<Option<i64>>, F140: Into<Option<Vec<u8>>>, F150: Into<Option<WorkflowType>>, F160: Into<Option<String>>, F170: Into<Option<Header>>, F180: Into<Option<Box<AutoConfigHint>>> {
    PollForActivityTaskResponse {
      task_token: task_token.into(),
      workflow_execution: workflow_execution.into(),
      activity_id: activity_id.into(),
      activity_type: activity_type.into(),
      input: input.into(),
      scheduled_timestamp: scheduled_timestamp.into(),
      schedule_to_close_timeout_seconds: schedule_to_close_timeout_seconds.into(),
      started_timestamp: started_timestamp.into(),
      start_to_close_timeout_seconds: start_to_close_timeout_seconds.into(),
      heartbeat_timeout_seconds: heartbeat_timeout_seconds.into(),
      attempt: attempt.into(),
      scheduled_timestamp_of_this_attempt: scheduled_timestamp_of_this_attempt.into(),
      heartbeat_details: heartbeat_details.into(),
      workflow_type: workflow_type.into(),
      workflow_domain: workflow_domain.into(),
      header: header.into(),
      auto_config_hint: auto_config_hint.into(),
    }
  }
}

impl TSerializable for PollForActivityTaskResponse {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PollForActivityTaskResponse> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<Vec<u8>> = None;
    let mut f_20: Option<WorkflowExecution> = None;
    let mut f_30: Option<String> = None;
    let mut f_40: Option<ActivityType> = None;
    let mut f_50: Option<Vec<u8>> = None;
    let mut f_70: Option<i64> = None;
    let mut f_80: Option<i32> = None;
    let mut f_90: Option<i64> = None;
    let mut f_100: Option<i32> = None;
    let mut f_110: Option<i32> = None;
    let mut f_120: Option<i32> = None;
    let mut f_130: Option<i64> = None;
    let mut f_140: Option<Vec<u8>> = None;
    let mut f_150: Option<WorkflowType> = None;
    let mut f_160: Option<String> = None;
    let mut f_170: Option<Header> = None;
    let mut f_180: Option<Box<AutoConfigHint>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_bytes()?;
          f_10 = Some(val);
        },
        20 => {
          let val = WorkflowExecution::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_string()?;
          f_30 = Some(val);
        },
        40 => {
          let val = ActivityType::read_from_in_protocol(i_prot)?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_bytes()?;
          f_50 = Some(val);
        },
        70 => {
          let val = i_prot.read_i64()?;
          f_70 = Some(val);
        },
        80 => {
          let val = i_prot.read_i32()?;
          f_80 = Some(val);
        },
        90 => {
          let val = i_prot.read_i64()?;
          f_90 = Some(val);
        },
        100 => {
          let val = i_prot.read_i32()?;
          f_100 = Some(val);
        },
        110 => {
          let val = i_prot.read_i32()?;
          f_110 = Some(val);
        },
        120 => {
          let val = i_prot.read_i32()?;
          f_120 = Some(val);
        },
        130 => {
          let val = i_prot.read_i64()?;
          f_130 = Some(val);
        },
        140 => {
          let val = i_prot.read_bytes()?;
          f_140 = Some(val);
        },
        150 => {
          let val = WorkflowType::read_from_in_protocol(i_prot)?;
          f_150 = Some(val);
        },
        160 => {
          let val = i_prot.read_string()?;
          f_160 = Some(val);
        },
        170 => {
          let val = Header::read_from_in_protocol(i_prot)?;
          f_170 = Some(val);
        },
        180 => {
          let val = Box::new(AutoConfigHint::read_from_in_protocol(i_prot)?);
          f_180 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = PollForActivityTaskResponse {
      task_token: f_10,
      workflow_execution: f_20,
      activity_id: f_30,
      activity_type: f_40,
      input: f_50,
      scheduled_timestamp: f_70,
      schedule_to_close_timeout_seconds: f_80,
      started_timestamp: f_90,
      start_to_close_timeout_seconds: f_100,
      heartbeat_timeout_seconds: f_110,
      attempt: f_120,
      scheduled_timestamp_of_this_attempt: f_130,
      heartbeat_details: f_140,
      workflow_type: f_150,
      workflow_domain: f_160,
      header: f_170,
      auto_config_hint: f_180,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PollForActivityTaskResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.task_token {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskToken", TType::String, 10))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_execution {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecution", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.activity_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("activityId", TType::String, 30))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.activity_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("activityType", TType::Struct, 40))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.input {
      o_prot.write_field_begin(&TFieldIdentifier::new("input", TType::String, 50))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.scheduled_timestamp {
      o_prot.write_field_begin(&TFieldIdentifier::new("scheduledTimestamp", TType::I64, 70))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.schedule_to_close_timeout_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("scheduleToCloseTimeoutSeconds", TType::I32, 80))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.started_timestamp {
      o_prot.write_field_begin(&TFieldIdentifier::new("startedTimestamp", TType::I64, 90))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.start_to_close_timeout_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("startToCloseTimeoutSeconds", TType::I32, 100))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.heartbeat_timeout_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("heartbeatTimeoutSeconds", TType::I32, 110))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.attempt {
      o_prot.write_field_begin(&TFieldIdentifier::new("attempt", TType::I32, 120))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.scheduled_timestamp_of_this_attempt {
      o_prot.write_field_begin(&TFieldIdentifier::new("scheduledTimestampOfThisAttempt", TType::I64, 130))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.heartbeat_details {
      o_prot.write_field_begin(&TFieldIdentifier::new("heartbeatDetails", TType::String, 140))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowType", TType::Struct, 150))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowDomain", TType::String, 160))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.header {
      o_prot.write_field_begin(&TFieldIdentifier::new("header", TType::Struct, 170))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.auto_config_hint {
      o_prot.write_field_begin(&TFieldIdentifier::new("autoConfigHint", TType::Struct, 180))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// RecordActivityTaskHeartbeatRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RecordActivityTaskHeartbeatRequest {
  pub task_token: Option<Vec<u8>>,
  pub details: Option<Vec<u8>>,
  pub identity: Option<String>,
}

impl RecordActivityTaskHeartbeatRequest {
  pub fn new<F10, F20, F30>(task_token: F10, details: F20, identity: F30) -> RecordActivityTaskHeartbeatRequest where F10: Into<Option<Vec<u8>>>, F20: Into<Option<Vec<u8>>>, F30: Into<Option<String>> {
    RecordActivityTaskHeartbeatRequest {
      task_token: task_token.into(),
      details: details.into(),
      identity: identity.into(),
    }
  }
}

impl TSerializable for RecordActivityTaskHeartbeatRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RecordActivityTaskHeartbeatRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<Vec<u8>> = None;
    let mut f_20: Option<Vec<u8>> = None;
    let mut f_30: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_bytes()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_bytes()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_string()?;
          f_30 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RecordActivityTaskHeartbeatRequest {
      task_token: f_10,
      details: f_20,
      identity: f_30,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RecordActivityTaskHeartbeatRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.task_token {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskToken", TType::String, 10))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.details {
      o_prot.write_field_begin(&TFieldIdentifier::new("details", TType::String, 20))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.identity {
      o_prot.write_field_begin(&TFieldIdentifier::new("identity", TType::String, 30))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// RecordActivityTaskHeartbeatByIDRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RecordActivityTaskHeartbeatByIDRequest {
  pub domain: Option<String>,
  pub workflow_i_d: Option<String>,
  pub run_i_d: Option<String>,
  pub activity_i_d: Option<String>,
  pub details: Option<Vec<u8>>,
  pub identity: Option<String>,
}

impl RecordActivityTaskHeartbeatByIDRequest {
  pub fn new<F10, F20, F30, F40, F50, F60>(domain: F10, workflow_i_d: F20, run_i_d: F30, activity_i_d: F40, details: F50, identity: F60) -> RecordActivityTaskHeartbeatByIDRequest where F10: Into<Option<String>>, F20: Into<Option<String>>, F30: Into<Option<String>>, F40: Into<Option<String>>, F50: Into<Option<Vec<u8>>>, F60: Into<Option<String>> {
    RecordActivityTaskHeartbeatByIDRequest {
      domain: domain.into(),
      workflow_i_d: workflow_i_d.into(),
      run_i_d: run_i_d.into(),
      activity_i_d: activity_i_d.into(),
      details: details.into(),
      identity: identity.into(),
    }
  }
}

impl TSerializable for RecordActivityTaskHeartbeatByIDRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RecordActivityTaskHeartbeatByIDRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<String> = None;
    let mut f_30: Option<String> = None;
    let mut f_40: Option<String> = None;
    let mut f_50: Option<Vec<u8>> = None;
    let mut f_60: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_string()?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_string()?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_bytes()?;
          f_50 = Some(val);
        },
        60 => {
          let val = i_prot.read_string()?;
          f_60 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RecordActivityTaskHeartbeatByIDRequest {
      domain: f_10,
      workflow_i_d: f_20,
      run_i_d: f_30,
      activity_i_d: f_40,
      details: f_50,
      identity: f_60,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RecordActivityTaskHeartbeatByIDRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowID", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.run_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("runID", TType::String, 30))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.activity_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("activityID", TType::String, 40))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.details {
      o_prot.write_field_begin(&TFieldIdentifier::new("details", TType::String, 50))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.identity {
      o_prot.write_field_begin(&TFieldIdentifier::new("identity", TType::String, 60))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// RecordActivityTaskHeartbeatResponse
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RecordActivityTaskHeartbeatResponse {
  pub cancel_requested: Option<bool>,
}

impl RecordActivityTaskHeartbeatResponse {
  pub fn new<F10>(cancel_requested: F10) -> RecordActivityTaskHeartbeatResponse where F10: Into<Option<bool>> {
    RecordActivityTaskHeartbeatResponse {
      cancel_requested: cancel_requested.into(),
    }
  }
}

impl TSerializable for RecordActivityTaskHeartbeatResponse {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RecordActivityTaskHeartbeatResponse> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_bool()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RecordActivityTaskHeartbeatResponse {
      cancel_requested: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RecordActivityTaskHeartbeatResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.cancel_requested {
      o_prot.write_field_begin(&TFieldIdentifier::new("cancelRequested", TType::Bool, 10))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// RespondActivityTaskCompletedRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RespondActivityTaskCompletedRequest {
  pub task_token: Option<Vec<u8>>,
  pub result: Option<Vec<u8>>,
  pub identity: Option<String>,
}

impl RespondActivityTaskCompletedRequest {
  pub fn new<F10, F20, F30>(task_token: F10, result: F20, identity: F30) -> RespondActivityTaskCompletedRequest where F10: Into<Option<Vec<u8>>>, F20: Into<Option<Vec<u8>>>, F30: Into<Option<String>> {
    RespondActivityTaskCompletedRequest {
      task_token: task_token.into(),
      result: result.into(),
      identity: identity.into(),
    }
  }
}

impl TSerializable for RespondActivityTaskCompletedRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RespondActivityTaskCompletedRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<Vec<u8>> = None;
    let mut f_20: Option<Vec<u8>> = None;
    let mut f_30: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_bytes()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_bytes()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_string()?;
          f_30 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RespondActivityTaskCompletedRequest {
      task_token: f_10,
      result: f_20,
      identity: f_30,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RespondActivityTaskCompletedRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.task_token {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskToken", TType::String, 10))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.result {
      o_prot.write_field_begin(&TFieldIdentifier::new("result", TType::String, 20))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.identity {
      o_prot.write_field_begin(&TFieldIdentifier::new("identity", TType::String, 30))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// RespondActivityTaskFailedRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RespondActivityTaskFailedRequest {
  pub task_token: Option<Vec<u8>>,
  pub reason: Option<String>,
  pub details: Option<Vec<u8>>,
  pub identity: Option<String>,
}

impl RespondActivityTaskFailedRequest {
  pub fn new<F10, F20, F30, F40>(task_token: F10, reason: F20, details: F30, identity: F40) -> RespondActivityTaskFailedRequest where F10: Into<Option<Vec<u8>>>, F20: Into<Option<String>>, F30: Into<Option<Vec<u8>>>, F40: Into<Option<String>> {
    RespondActivityTaskFailedRequest {
      task_token: task_token.into(),
      reason: reason.into(),
      details: details.into(),
      identity: identity.into(),
    }
  }
}

impl TSerializable for RespondActivityTaskFailedRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RespondActivityTaskFailedRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<Vec<u8>> = None;
    let mut f_20: Option<String> = None;
    let mut f_30: Option<Vec<u8>> = None;
    let mut f_40: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_bytes()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_bytes()?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_string()?;
          f_40 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RespondActivityTaskFailedRequest {
      task_token: f_10,
      reason: f_20,
      details: f_30,
      identity: f_40,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RespondActivityTaskFailedRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.task_token {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskToken", TType::String, 10))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.reason {
      o_prot.write_field_begin(&TFieldIdentifier::new("reason", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.details {
      o_prot.write_field_begin(&TFieldIdentifier::new("details", TType::String, 30))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.identity {
      o_prot.write_field_begin(&TFieldIdentifier::new("identity", TType::String, 40))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// RespondActivityTaskCanceledRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RespondActivityTaskCanceledRequest {
  pub task_token: Option<Vec<u8>>,
  pub details: Option<Vec<u8>>,
  pub identity: Option<String>,
}

impl RespondActivityTaskCanceledRequest {
  pub fn new<F10, F20, F30>(task_token: F10, details: F20, identity: F30) -> RespondActivityTaskCanceledRequest where F10: Into<Option<Vec<u8>>>, F20: Into<Option<Vec<u8>>>, F30: Into<Option<String>> {
    RespondActivityTaskCanceledRequest {
      task_token: task_token.into(),
      details: details.into(),
      identity: identity.into(),
    }
  }
}

impl TSerializable for RespondActivityTaskCanceledRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RespondActivityTaskCanceledRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<Vec<u8>> = None;
    let mut f_20: Option<Vec<u8>> = None;
    let mut f_30: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_bytes()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_bytes()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_string()?;
          f_30 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RespondActivityTaskCanceledRequest {
      task_token: f_10,
      details: f_20,
      identity: f_30,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RespondActivityTaskCanceledRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.task_token {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskToken", TType::String, 10))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.details {
      o_prot.write_field_begin(&TFieldIdentifier::new("details", TType::String, 20))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.identity {
      o_prot.write_field_begin(&TFieldIdentifier::new("identity", TType::String, 30))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// RespondActivityTaskCompletedByIDRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RespondActivityTaskCompletedByIDRequest {
  pub domain: Option<String>,
  pub workflow_i_d: Option<String>,
  pub run_i_d: Option<String>,
  pub activity_i_d: Option<String>,
  pub result: Option<Vec<u8>>,
  pub identity: Option<String>,
}

impl RespondActivityTaskCompletedByIDRequest {
  pub fn new<F10, F20, F30, F40, F50, F60>(domain: F10, workflow_i_d: F20, run_i_d: F30, activity_i_d: F40, result: F50, identity: F60) -> RespondActivityTaskCompletedByIDRequest where F10: Into<Option<String>>, F20: Into<Option<String>>, F30: Into<Option<String>>, F40: Into<Option<String>>, F50: Into<Option<Vec<u8>>>, F60: Into<Option<String>> {
    RespondActivityTaskCompletedByIDRequest {
      domain: domain.into(),
      workflow_i_d: workflow_i_d.into(),
      run_i_d: run_i_d.into(),
      activity_i_d: activity_i_d.into(),
      result: result.into(),
      identity: identity.into(),
    }
  }
}

impl TSerializable for RespondActivityTaskCompletedByIDRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RespondActivityTaskCompletedByIDRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<String> = None;
    let mut f_30: Option<String> = None;
    let mut f_40: Option<String> = None;
    let mut f_50: Option<Vec<u8>> = None;
    let mut f_60: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_string()?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_string()?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_bytes()?;
          f_50 = Some(val);
        },
        60 => {
          let val = i_prot.read_string()?;
          f_60 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RespondActivityTaskCompletedByIDRequest {
      domain: f_10,
      workflow_i_d: f_20,
      run_i_d: f_30,
      activity_i_d: f_40,
      result: f_50,
      identity: f_60,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RespondActivityTaskCompletedByIDRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowID", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.run_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("runID", TType::String, 30))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.activity_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("activityID", TType::String, 40))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.result {
      o_prot.write_field_begin(&TFieldIdentifier::new("result", TType::String, 50))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.identity {
      o_prot.write_field_begin(&TFieldIdentifier::new("identity", TType::String, 60))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// RespondActivityTaskFailedByIDRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RespondActivityTaskFailedByIDRequest {
  pub domain: Option<String>,
  pub workflow_i_d: Option<String>,
  pub run_i_d: Option<String>,
  pub activity_i_d: Option<String>,
  pub reason: Option<String>,
  pub details: Option<Vec<u8>>,
  pub identity: Option<String>,
}

impl RespondActivityTaskFailedByIDRequest {
  pub fn new<F10, F20, F30, F40, F50, F60, F70>(domain: F10, workflow_i_d: F20, run_i_d: F30, activity_i_d: F40, reason: F50, details: F60, identity: F70) -> RespondActivityTaskFailedByIDRequest where F10: Into<Option<String>>, F20: Into<Option<String>>, F30: Into<Option<String>>, F40: Into<Option<String>>, F50: Into<Option<String>>, F60: Into<Option<Vec<u8>>>, F70: Into<Option<String>> {
    RespondActivityTaskFailedByIDRequest {
      domain: domain.into(),
      workflow_i_d: workflow_i_d.into(),
      run_i_d: run_i_d.into(),
      activity_i_d: activity_i_d.into(),
      reason: reason.into(),
      details: details.into(),
      identity: identity.into(),
    }
  }
}

impl TSerializable for RespondActivityTaskFailedByIDRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RespondActivityTaskFailedByIDRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<String> = None;
    let mut f_30: Option<String> = None;
    let mut f_40: Option<String> = None;
    let mut f_50: Option<String> = None;
    let mut f_60: Option<Vec<u8>> = None;
    let mut f_70: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_string()?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_string()?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_string()?;
          f_50 = Some(val);
        },
        60 => {
          let val = i_prot.read_bytes()?;
          f_60 = Some(val);
        },
        70 => {
          let val = i_prot.read_string()?;
          f_70 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RespondActivityTaskFailedByIDRequest {
      domain: f_10,
      workflow_i_d: f_20,
      run_i_d: f_30,
      activity_i_d: f_40,
      reason: f_50,
      details: f_60,
      identity: f_70,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RespondActivityTaskFailedByIDRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowID", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.run_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("runID", TType::String, 30))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.activity_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("activityID", TType::String, 40))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.reason {
      o_prot.write_field_begin(&TFieldIdentifier::new("reason", TType::String, 50))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.details {
      o_prot.write_field_begin(&TFieldIdentifier::new("details", TType::String, 60))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.identity {
      o_prot.write_field_begin(&TFieldIdentifier::new("identity", TType::String, 70))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// RespondActivityTaskCanceledByIDRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RespondActivityTaskCanceledByIDRequest {
  pub domain: Option<String>,
  pub workflow_i_d: Option<String>,
  pub run_i_d: Option<String>,
  pub activity_i_d: Option<String>,
  pub details: Option<Vec<u8>>,
  pub identity: Option<String>,
}

impl RespondActivityTaskCanceledByIDRequest {
  pub fn new<F10, F20, F30, F40, F50, F60>(domain: F10, workflow_i_d: F20, run_i_d: F30, activity_i_d: F40, details: F50, identity: F60) -> RespondActivityTaskCanceledByIDRequest where F10: Into<Option<String>>, F20: Into<Option<String>>, F30: Into<Option<String>>, F40: Into<Option<String>>, F50: Into<Option<Vec<u8>>>, F60: Into<Option<String>> {
    RespondActivityTaskCanceledByIDRequest {
      domain: domain.into(),
      workflow_i_d: workflow_i_d.into(),
      run_i_d: run_i_d.into(),
      activity_i_d: activity_i_d.into(),
      details: details.into(),
      identity: identity.into(),
    }
  }
}

impl TSerializable for RespondActivityTaskCanceledByIDRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RespondActivityTaskCanceledByIDRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<String> = None;
    let mut f_30: Option<String> = None;
    let mut f_40: Option<String> = None;
    let mut f_50: Option<Vec<u8>> = None;
    let mut f_60: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_string()?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_string()?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_bytes()?;
          f_50 = Some(val);
        },
        60 => {
          let val = i_prot.read_string()?;
          f_60 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RespondActivityTaskCanceledByIDRequest {
      domain: f_10,
      workflow_i_d: f_20,
      run_i_d: f_30,
      activity_i_d: f_40,
      details: f_50,
      identity: f_60,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RespondActivityTaskCanceledByIDRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowID", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.run_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("runID", TType::String, 30))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.activity_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("activityID", TType::String, 40))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.details {
      o_prot.write_field_begin(&TFieldIdentifier::new("details", TType::String, 50))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.identity {
      o_prot.write_field_begin(&TFieldIdentifier::new("identity", TType::String, 60))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// RequestCancelWorkflowExecutionRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RequestCancelWorkflowExecutionRequest {
  pub domain: Option<String>,
  pub workflow_execution: Option<WorkflowExecution>,
  pub identity: Option<String>,
  pub request_id: Option<String>,
  pub cause: Option<String>,
  pub first_execution_run_i_d: Option<String>,
}

impl RequestCancelWorkflowExecutionRequest {
  pub fn new<F10, F20, F30, F40, F50, F60>(domain: F10, workflow_execution: F20, identity: F30, request_id: F40, cause: F50, first_execution_run_i_d: F60) -> RequestCancelWorkflowExecutionRequest where F10: Into<Option<String>>, F20: Into<Option<WorkflowExecution>>, F30: Into<Option<String>>, F40: Into<Option<String>>, F50: Into<Option<String>>, F60: Into<Option<String>> {
    RequestCancelWorkflowExecutionRequest {
      domain: domain.into(),
      workflow_execution: workflow_execution.into(),
      identity: identity.into(),
      request_id: request_id.into(),
      cause: cause.into(),
      first_execution_run_i_d: first_execution_run_i_d.into(),
    }
  }
}

impl TSerializable for RequestCancelWorkflowExecutionRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RequestCancelWorkflowExecutionRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<WorkflowExecution> = None;
    let mut f_30: Option<String> = None;
    let mut f_40: Option<String> = None;
    let mut f_50: Option<String> = None;
    let mut f_60: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = WorkflowExecution::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_string()?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_string()?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_string()?;
          f_50 = Some(val);
        },
        60 => {
          let val = i_prot.read_string()?;
          f_60 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RequestCancelWorkflowExecutionRequest {
      domain: f_10,
      workflow_execution: f_20,
      identity: f_30,
      request_id: f_40,
      cause: f_50,
      first_execution_run_i_d: f_60,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RequestCancelWorkflowExecutionRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_execution {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecution", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.identity {
      o_prot.write_field_begin(&TFieldIdentifier::new("identity", TType::String, 30))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.request_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 40))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cause {
      o_prot.write_field_begin(&TFieldIdentifier::new("cause", TType::String, 50))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.first_execution_run_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("firstExecutionRunID", TType::String, 60))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// GetWorkflowExecutionHistoryRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GetWorkflowExecutionHistoryRequest {
  pub domain: Option<String>,
  pub execution: Option<WorkflowExecution>,
  pub maximum_page_size: Option<i32>,
  pub next_page_token: Option<Vec<u8>>,
  pub wait_for_new_event: Option<bool>,
  pub history_event_filter_type: Option<HistoryEventFilterType>,
  pub skip_archival: Option<bool>,
  pub query_consistency_level: Option<QueryConsistencyLevel>,
}

impl GetWorkflowExecutionHistoryRequest {
  pub fn new<F10, F20, F30, F40, F50, F60, F70, F80>(domain: F10, execution: F20, maximum_page_size: F30, next_page_token: F40, wait_for_new_event: F50, history_event_filter_type: F60, skip_archival: F70, query_consistency_level: F80) -> GetWorkflowExecutionHistoryRequest where F10: Into<Option<String>>, F20: Into<Option<WorkflowExecution>>, F30: Into<Option<i32>>, F40: Into<Option<Vec<u8>>>, F50: Into<Option<bool>>, F60: Into<Option<HistoryEventFilterType>>, F70: Into<Option<bool>>, F80: Into<Option<QueryConsistencyLevel>> {
    GetWorkflowExecutionHistoryRequest {
      domain: domain.into(),
      execution: execution.into(),
      maximum_page_size: maximum_page_size.into(),
      next_page_token: next_page_token.into(),
      wait_for_new_event: wait_for_new_event.into(),
      history_event_filter_type: history_event_filter_type.into(),
      skip_archival: skip_archival.into(),
      query_consistency_level: query_consistency_level.into(),
    }
  }
}

impl TSerializable for GetWorkflowExecutionHistoryRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GetWorkflowExecutionHistoryRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<WorkflowExecution> = None;
    let mut f_30: Option<i32> = None;
    let mut f_40: Option<Vec<u8>> = None;
    let mut f_50: Option<bool> = None;
    let mut f_60: Option<HistoryEventFilterType> = None;
    let mut f_70: Option<bool> = None;
    let mut f_80: Option<QueryConsistencyLevel> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = WorkflowExecution::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_i32()?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_bytes()?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_bool()?;
          f_50 = Some(val);
        },
        60 => {
          let val = HistoryEventFilterType::read_from_in_protocol(i_prot)?;
          f_60 = Some(val);
        },
        70 => {
          let val = i_prot.read_bool()?;
          f_70 = Some(val);
        },
        80 => {
          let val = QueryConsistencyLevel::read_from_in_protocol(i_prot)?;
          f_80 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = GetWorkflowExecutionHistoryRequest {
      domain: f_10,
      execution: f_20,
      maximum_page_size: f_30,
      next_page_token: f_40,
      wait_for_new_event: f_50,
      history_event_filter_type: f_60,
      skip_archival: f_70,
      query_consistency_level: f_80,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetWorkflowExecutionHistoryRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.execution {
      o_prot.write_field_begin(&TFieldIdentifier::new("execution", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.maximum_page_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("maximumPageSize", TType::I32, 30))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.next_page_token {
      o_prot.write_field_begin(&TFieldIdentifier::new("nextPageToken", TType::String, 40))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.wait_for_new_event {
      o_prot.write_field_begin(&TFieldIdentifier::new("waitForNewEvent", TType::Bool, 50))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.history_event_filter_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("HistoryEventFilterType", TType::I32, 60))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.skip_archival {
      o_prot.write_field_begin(&TFieldIdentifier::new("skipArchival", TType::Bool, 70))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.query_consistency_level {
      o_prot.write_field_begin(&TFieldIdentifier::new("queryConsistencyLevel", TType::I32, 80))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// GetWorkflowExecutionHistoryResponse
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GetWorkflowExecutionHistoryResponse {
  pub history: Option<History>,
  pub raw_history: Option<Vec<DataBlob>>,
  pub next_page_token: Option<Vec<u8>>,
  pub archived: Option<bool>,
}

impl GetWorkflowExecutionHistoryResponse {
  pub fn new<F10, F11, F20, F30>(history: F10, raw_history: F11, next_page_token: F20, archived: F30) -> GetWorkflowExecutionHistoryResponse where F10: Into<Option<History>>, F11: Into<Option<Vec<DataBlob>>>, F20: Into<Option<Vec<u8>>>, F30: Into<Option<bool>> {
    GetWorkflowExecutionHistoryResponse {
      history: history.into(),
      raw_history: raw_history.into(),
      next_page_token: next_page_token.into(),
      archived: archived.into(),
    }
  }
}

impl TSerializable for GetWorkflowExecutionHistoryResponse {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GetWorkflowExecutionHistoryResponse> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<History> = None;
    let mut f_11: Option<Vec<DataBlob>> = None;
    let mut f_20: Option<Vec<u8>> = None;
    let mut f_30: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = History::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        11 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<DataBlob> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_43 = DataBlob::read_from_in_protocol(i_prot)?;
            val.push(list_elem_43);
          }
          i_prot.read_list_end()?;
          f_11 = Some(val);
        },
        20 => {
          let val = i_prot.read_bytes()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_bool()?;
          f_30 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = GetWorkflowExecutionHistoryResponse {
      history: f_10,
      raw_history: f_11,
      next_page_token: f_20,
      archived: f_30,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetWorkflowExecutionHistoryResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.history {
      o_prot.write_field_begin(&TFieldIdentifier::new("history", TType::Struct, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.raw_history {
      o_prot.write_field_begin(&TFieldIdentifier::new("rawHistory", TType::List, 11))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.next_page_token {
      o_prot.write_field_begin(&TFieldIdentifier::new("nextPageToken", TType::String, 20))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.archived {
      o_prot.write_field_begin(&TFieldIdentifier::new("archived", TType::Bool, 30))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SignalWorkflowExecutionRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SignalWorkflowExecutionRequest {
  pub domain: Option<String>,
  pub workflow_execution: Option<WorkflowExecution>,
  pub signal_name: Option<String>,
  pub input: Option<Vec<u8>>,
  pub identity: Option<String>,
  pub request_id: Option<String>,
  pub control: Option<Vec<u8>>,
}

impl SignalWorkflowExecutionRequest {
  pub fn new<F10, F20, F30, F40, F50, F60, F70>(domain: F10, workflow_execution: F20, signal_name: F30, input: F40, identity: F50, request_id: F60, control: F70) -> SignalWorkflowExecutionRequest where F10: Into<Option<String>>, F20: Into<Option<WorkflowExecution>>, F30: Into<Option<String>>, F40: Into<Option<Vec<u8>>>, F50: Into<Option<String>>, F60: Into<Option<String>>, F70: Into<Option<Vec<u8>>> {
    SignalWorkflowExecutionRequest {
      domain: domain.into(),
      workflow_execution: workflow_execution.into(),
      signal_name: signal_name.into(),
      input: input.into(),
      identity: identity.into(),
      request_id: request_id.into(),
      control: control.into(),
    }
  }
}

impl TSerializable for SignalWorkflowExecutionRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SignalWorkflowExecutionRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<WorkflowExecution> = None;
    let mut f_30: Option<String> = None;
    let mut f_40: Option<Vec<u8>> = None;
    let mut f_50: Option<String> = None;
    let mut f_60: Option<String> = None;
    let mut f_70: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = WorkflowExecution::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_string()?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_bytes()?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_string()?;
          f_50 = Some(val);
        },
        60 => {
          let val = i_prot.read_string()?;
          f_60 = Some(val);
        },
        70 => {
          let val = i_prot.read_bytes()?;
          f_70 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SignalWorkflowExecutionRequest {
      domain: f_10,
      workflow_execution: f_20,
      signal_name: f_30,
      input: f_40,
      identity: f_50,
      request_id: f_60,
      control: f_70,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SignalWorkflowExecutionRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_execution {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecution", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.signal_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("signalName", TType::String, 30))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.input {
      o_prot.write_field_begin(&TFieldIdentifier::new("input", TType::String, 40))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.identity {
      o_prot.write_field_begin(&TFieldIdentifier::new("identity", TType::String, 50))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.request_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 60))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.control {
      o_prot.write_field_begin(&TFieldIdentifier::new("control", TType::String, 70))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SignalWithStartWorkflowExecutionRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SignalWithStartWorkflowExecutionRequest {
  pub domain: Option<String>,
  pub workflow_id: Option<String>,
  pub workflow_type: Option<WorkflowType>,
  pub task_list: Option<TaskList>,
  pub input: Option<Vec<u8>>,
  pub execution_start_to_close_timeout_seconds: Option<i32>,
  pub task_start_to_close_timeout_seconds: Option<i32>,
  pub identity: Option<String>,
  pub request_id: Option<String>,
  pub workflow_id_reuse_policy: Option<WorkflowIdReusePolicy>,
  pub signal_name: Option<String>,
  pub signal_input: Option<Vec<u8>>,
  pub control: Option<Vec<u8>>,
  pub retry_policy: Option<Box<RetryPolicy>>,
  pub cron_schedule: Option<String>,
  pub memo: Option<Memo>,
  pub search_attributes: Option<SearchAttributes>,
  pub header: Option<Header>,
  pub delay_start_seconds: Option<i32>,
  pub jitter_start_seconds: Option<i32>,
  pub first_run_at_timestamp: Option<i64>,
  pub cron_overlap_policy: Option<CronOverlapPolicy>,
  pub active_cluster_selection_policy: Option<Box<ActiveClusterSelectionPolicy>>,
}

impl SignalWithStartWorkflowExecutionRequest {
  pub fn new<F10, F20, F30, F40, F50, F60, F70, F80, F90, F100, F110, F120, F130, F140, F150, F160, F161, F170, F180, F190, F200, F210, F220>(domain: F10, workflow_id: F20, workflow_type: F30, task_list: F40, input: F50, execution_start_to_close_timeout_seconds: F60, task_start_to_close_timeout_seconds: F70, identity: F80, request_id: F90, workflow_id_reuse_policy: F100, signal_name: F110, signal_input: F120, control: F130, retry_policy: F140, cron_schedule: F150, memo: F160, search_attributes: F161, header: F170, delay_start_seconds: F180, jitter_start_seconds: F190, first_run_at_timestamp: F200, cron_overlap_policy: F210, active_cluster_selection_policy: F220) -> SignalWithStartWorkflowExecutionRequest where F10: Into<Option<String>>, F20: Into<Option<String>>, F30: Into<Option<WorkflowType>>, F40: Into<Option<TaskList>>, F50: Into<Option<Vec<u8>>>, F60: Into<Option<i32>>, F70: Into<Option<i32>>, F80: Into<Option<String>>, F90: Into<Option<String>>, F100: Into<Option<WorkflowIdReusePolicy>>, F110: Into<Option<String>>, F120: Into<Option<Vec<u8>>>, F130: Into<Option<Vec<u8>>>, F140: Into<Option<Box<RetryPolicy>>>, F150: Into<Option<String>>, F160: Into<Option<Memo>>, F161: Into<Option<SearchAttributes>>, F170: Into<Option<Header>>, F180: Into<Option<i32>>, F190: Into<Option<i32>>, F200: Into<Option<i64>>, F210: Into<Option<CronOverlapPolicy>>, F220: Into<Option<Box<ActiveClusterSelectionPolicy>>> {
    SignalWithStartWorkflowExecutionRequest {
      domain: domain.into(),
      workflow_id: workflow_id.into(),
      workflow_type: workflow_type.into(),
      task_list: task_list.into(),
      input: input.into(),
      execution_start_to_close_timeout_seconds: execution_start_to_close_timeout_seconds.into(),
      task_start_to_close_timeout_seconds: task_start_to_close_timeout_seconds.into(),
      identity: identity.into(),
      request_id: request_id.into(),
      workflow_id_reuse_policy: workflow_id_reuse_policy.into(),
      signal_name: signal_name.into(),
      signal_input: signal_input.into(),
      control: control.into(),
      retry_policy: retry_policy.into(),
      cron_schedule: cron_schedule.into(),
      memo: memo.into(),
      search_attributes: search_attributes.into(),
      header: header.into(),
      delay_start_seconds: delay_start_seconds.into(),
      jitter_start_seconds: jitter_start_seconds.into(),
      first_run_at_timestamp: first_run_at_timestamp.into(),
      cron_overlap_policy: cron_overlap_policy.into(),
      active_cluster_selection_policy: active_cluster_selection_policy.into(),
    }
  }
}

impl TSerializable for SignalWithStartWorkflowExecutionRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SignalWithStartWorkflowExecutionRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<String> = None;
    let mut f_30: Option<WorkflowType> = None;
    let mut f_40: Option<TaskList> = None;
    let mut f_50: Option<Vec<u8>> = None;
    let mut f_60: Option<i32> = None;
    let mut f_70: Option<i32> = None;
    let mut f_80: Option<String> = None;
    let mut f_90: Option<String> = None;
    let mut f_100: Option<WorkflowIdReusePolicy> = None;
    let mut f_110: Option<String> = None;
    let mut f_120: Option<Vec<u8>> = None;
    let mut f_130: Option<Vec<u8>> = None;
    let mut f_140: Option<Box<RetryPolicy>> = None;
    let mut f_150: Option<String> = None;
    let mut f_160: Option<Memo> = None;
    let mut f_161: Option<SearchAttributes> = None;
    let mut f_170: Option<Header> = None;
    let mut f_180: Option<i32> = None;
    let mut f_190: Option<i32> = None;
    let mut f_200: Option<i64> = None;
    let mut f_210: Option<CronOverlapPolicy> = None;
    let mut f_220: Option<Box<ActiveClusterSelectionPolicy>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        30 => {
          let val = WorkflowType::read_from_in_protocol(i_prot)?;
          f_30 = Some(val);
        },
        40 => {
          let val = TaskList::read_from_in_protocol(i_prot)?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_bytes()?;
          f_50 = Some(val);
        },
        60 => {
          let val = i_prot.read_i32()?;
          f_60 = Some(val);
        },
        70 => {
          let val = i_prot.read_i32()?;
          f_70 = Some(val);
        },
        80 => {
          let val = i_prot.read_string()?;
          f_80 = Some(val);
        },
        90 => {
          let val = i_prot.read_string()?;
          f_90 = Some(val);
        },
        100 => {
          let val = WorkflowIdReusePolicy::read_from_in_protocol(i_prot)?;
          f_100 = Some(val);
        },
        110 => {
          let val = i_prot.read_string()?;
          f_110 = Some(val);
        },
        120 => {
          let val = i_prot.read_bytes()?;
          f_120 = Some(val);
        },
        130 => {
          let val = i_prot.read_bytes()?;
          f_130 = Some(val);
        },
        140 => {
          let val = Box::new(RetryPolicy::read_from_in_protocol(i_prot)?);
          f_140 = Some(val);
        },
        150 => {
          let val = i_prot.read_string()?;
          f_150 = Some(val);
        },
        160 => {
          let val = Memo::read_from_in_protocol(i_prot)?;
          f_160 = Some(val);
        },
        161 => {
          let val = SearchAttributes::read_from_in_protocol(i_prot)?;
          f_161 = Some(val);
        },
        170 => {
          let val = Header::read_from_in_protocol(i_prot)?;
          f_170 = Some(val);
        },
        180 => {
          let val = i_prot.read_i32()?;
          f_180 = Some(val);
        },
        190 => {
          let val = i_prot.read_i32()?;
          f_190 = Some(val);
        },
        200 => {
          let val = i_prot.read_i64()?;
          f_200 = Some(val);
        },
        210 => {
          let val = CronOverlapPolicy::read_from_in_protocol(i_prot)?;
          f_210 = Some(val);
        },
        220 => {
          let val = Box::new(ActiveClusterSelectionPolicy::read_from_in_protocol(i_prot)?);
          f_220 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SignalWithStartWorkflowExecutionRequest {
      domain: f_10,
      workflow_id: f_20,
      workflow_type: f_30,
      task_list: f_40,
      input: f_50,
      execution_start_to_close_timeout_seconds: f_60,
      task_start_to_close_timeout_seconds: f_70,
      identity: f_80,
      request_id: f_90,
      workflow_id_reuse_policy: f_100,
      signal_name: f_110,
      signal_input: f_120,
      control: f_130,
      retry_policy: f_140,
      cron_schedule: f_150,
      memo: f_160,
      search_attributes: f_161,
      header: f_170,
      delay_start_seconds: f_180,
      jitter_start_seconds: f_190,
      first_run_at_timestamp: f_200,
      cron_overlap_policy: f_210,
      active_cluster_selection_policy: f_220,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SignalWithStartWorkflowExecutionRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowId", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowType", TType::Struct, 30))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.task_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskList", TType::Struct, 40))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.input {
      o_prot.write_field_begin(&TFieldIdentifier::new("input", TType::String, 50))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.execution_start_to_close_timeout_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("executionStartToCloseTimeoutSeconds", TType::I32, 60))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.task_start_to_close_timeout_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskStartToCloseTimeoutSeconds", TType::I32, 70))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.identity {
      o_prot.write_field_begin(&TFieldIdentifier::new("identity", TType::String, 80))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.request_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 90))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_id_reuse_policy {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowIdReusePolicy", TType::I32, 100))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.signal_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("signalName", TType::String, 110))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.signal_input {
      o_prot.write_field_begin(&TFieldIdentifier::new("signalInput", TType::String, 120))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.control {
      o_prot.write_field_begin(&TFieldIdentifier::new("control", TType::String, 130))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.retry_policy {
      o_prot.write_field_begin(&TFieldIdentifier::new("retryPolicy", TType::Struct, 140))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cron_schedule {
      o_prot.write_field_begin(&TFieldIdentifier::new("cronSchedule", TType::String, 150))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.memo {
      o_prot.write_field_begin(&TFieldIdentifier::new("memo", TType::Struct, 160))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.search_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("searchAttributes", TType::Struct, 161))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.header {
      o_prot.write_field_begin(&TFieldIdentifier::new("header", TType::Struct, 170))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.delay_start_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("delayStartSeconds", TType::I32, 180))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.jitter_start_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("jitterStartSeconds", TType::I32, 190))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.first_run_at_timestamp {
      o_prot.write_field_begin(&TFieldIdentifier::new("firstRunAtTimestamp", TType::I64, 200))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cron_overlap_policy {
      o_prot.write_field_begin(&TFieldIdentifier::new("cronOverlapPolicy", TType::I32, 210))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.active_cluster_selection_policy {
      o_prot.write_field_begin(&TFieldIdentifier::new("activeClusterSelectionPolicy", TType::Struct, 220))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SignalWithStartWorkflowExecutionAsyncRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SignalWithStartWorkflowExecutionAsyncRequest {
  pub request: Option<SignalWithStartWorkflowExecutionRequest>,
}

impl SignalWithStartWorkflowExecutionAsyncRequest {
  pub fn new<F10>(request: F10) -> SignalWithStartWorkflowExecutionAsyncRequest where F10: Into<Option<SignalWithStartWorkflowExecutionRequest>> {
    SignalWithStartWorkflowExecutionAsyncRequest {
      request: request.into(),
    }
  }
}

impl TSerializable for SignalWithStartWorkflowExecutionAsyncRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SignalWithStartWorkflowExecutionAsyncRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<SignalWithStartWorkflowExecutionRequest> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = SignalWithStartWorkflowExecutionRequest::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SignalWithStartWorkflowExecutionAsyncRequest {
      request: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SignalWithStartWorkflowExecutionAsyncRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.request {
      o_prot.write_field_begin(&TFieldIdentifier::new("request", TType::Struct, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SignalWithStartWorkflowExecutionAsyncResponse
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SignalWithStartWorkflowExecutionAsyncResponse {
}

impl SignalWithStartWorkflowExecutionAsyncResponse {
  pub fn new() -> SignalWithStartWorkflowExecutionAsyncResponse {
    SignalWithStartWorkflowExecutionAsyncResponse {}
  }
}

impl TSerializable for SignalWithStartWorkflowExecutionAsyncResponse {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SignalWithStartWorkflowExecutionAsyncResponse> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      i_prot.skip(field_ident.field_type)?;
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SignalWithStartWorkflowExecutionAsyncResponse {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SignalWithStartWorkflowExecutionAsyncResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// RestartWorkflowExecutionRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RestartWorkflowExecutionRequest {
  pub domain: Option<String>,
  pub workflow_execution: Option<WorkflowExecution>,
  pub reason: Option<String>,
  pub identity: Option<String>,
}

impl RestartWorkflowExecutionRequest {
  pub fn new<F10, F20, F30, F40>(domain: F10, workflow_execution: F20, reason: F30, identity: F40) -> RestartWorkflowExecutionRequest where F10: Into<Option<String>>, F20: Into<Option<WorkflowExecution>>, F30: Into<Option<String>>, F40: Into<Option<String>> {
    RestartWorkflowExecutionRequest {
      domain: domain.into(),
      workflow_execution: workflow_execution.into(),
      reason: reason.into(),
      identity: identity.into(),
    }
  }
}

impl TSerializable for RestartWorkflowExecutionRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RestartWorkflowExecutionRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<WorkflowExecution> = None;
    let mut f_30: Option<String> = None;
    let mut f_40: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = WorkflowExecution::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_string()?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_string()?;
          f_40 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RestartWorkflowExecutionRequest {
      domain: f_10,
      workflow_execution: f_20,
      reason: f_30,
      identity: f_40,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RestartWorkflowExecutionRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_execution {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecution", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.reason {
      o_prot.write_field_begin(&TFieldIdentifier::new("reason", TType::String, 30))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.identity {
      o_prot.write_field_begin(&TFieldIdentifier::new("identity", TType::String, 40))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TerminateWorkflowExecutionRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TerminateWorkflowExecutionRequest {
  pub domain: Option<String>,
  pub workflow_execution: Option<WorkflowExecution>,
  pub reason: Option<String>,
  pub details: Option<Vec<u8>>,
  pub identity: Option<String>,
  pub first_execution_run_i_d: Option<String>,
}

impl TerminateWorkflowExecutionRequest {
  pub fn new<F10, F20, F30, F40, F50, F60>(domain: F10, workflow_execution: F20, reason: F30, details: F40, identity: F50, first_execution_run_i_d: F60) -> TerminateWorkflowExecutionRequest where F10: Into<Option<String>>, F20: Into<Option<WorkflowExecution>>, F30: Into<Option<String>>, F40: Into<Option<Vec<u8>>>, F50: Into<Option<String>>, F60: Into<Option<String>> {
    TerminateWorkflowExecutionRequest {
      domain: domain.into(),
      workflow_execution: workflow_execution.into(),
      reason: reason.into(),
      details: details.into(),
      identity: identity.into(),
      first_execution_run_i_d: first_execution_run_i_d.into(),
    }
  }
}

impl TSerializable for TerminateWorkflowExecutionRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TerminateWorkflowExecutionRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<WorkflowExecution> = None;
    let mut f_30: Option<String> = None;
    let mut f_40: Option<Vec<u8>> = None;
    let mut f_50: Option<String> = None;
    let mut f_60: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = WorkflowExecution::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_string()?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_bytes()?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_string()?;
          f_50 = Some(val);
        },
        60 => {
          let val = i_prot.read_string()?;
          f_60 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TerminateWorkflowExecutionRequest {
      domain: f_10,
      workflow_execution: f_20,
      reason: f_30,
      details: f_40,
      identity: f_50,
      first_execution_run_i_d: f_60,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TerminateWorkflowExecutionRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_execution {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecution", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.reason {
      o_prot.write_field_begin(&TFieldIdentifier::new("reason", TType::String, 30))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.details {
      o_prot.write_field_begin(&TFieldIdentifier::new("details", TType::String, 40))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.identity {
      o_prot.write_field_begin(&TFieldIdentifier::new("identity", TType::String, 50))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.first_execution_run_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("firstExecutionRunID", TType::String, 60))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ResetWorkflowExecutionRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ResetWorkflowExecutionRequest {
  pub domain: Option<String>,
  pub workflow_execution: Option<WorkflowExecution>,
  pub reason: Option<String>,
  pub decision_finish_event_id: Option<i64>,
  pub request_id: Option<String>,
  pub skip_signal_reapply: Option<bool>,
}

impl ResetWorkflowExecutionRequest {
  pub fn new<F10, F20, F30, F40, F50, F60>(domain: F10, workflow_execution: F20, reason: F30, decision_finish_event_id: F40, request_id: F50, skip_signal_reapply: F60) -> ResetWorkflowExecutionRequest where F10: Into<Option<String>>, F20: Into<Option<WorkflowExecution>>, F30: Into<Option<String>>, F40: Into<Option<i64>>, F50: Into<Option<String>>, F60: Into<Option<bool>> {
    ResetWorkflowExecutionRequest {
      domain: domain.into(),
      workflow_execution: workflow_execution.into(),
      reason: reason.into(),
      decision_finish_event_id: decision_finish_event_id.into(),
      request_id: request_id.into(),
      skip_signal_reapply: skip_signal_reapply.into(),
    }
  }
}

impl TSerializable for ResetWorkflowExecutionRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ResetWorkflowExecutionRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<WorkflowExecution> = None;
    let mut f_30: Option<String> = None;
    let mut f_40: Option<i64> = None;
    let mut f_50: Option<String> = None;
    let mut f_60: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = WorkflowExecution::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_string()?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_i64()?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_string()?;
          f_50 = Some(val);
        },
        60 => {
          let val = i_prot.read_bool()?;
          f_60 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ResetWorkflowExecutionRequest {
      domain: f_10,
      workflow_execution: f_20,
      reason: f_30,
      decision_finish_event_id: f_40,
      request_id: f_50,
      skip_signal_reapply: f_60,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ResetWorkflowExecutionRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_execution {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecution", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.reason {
      o_prot.write_field_begin(&TFieldIdentifier::new("reason", TType::String, 30))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.decision_finish_event_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("decisionFinishEventId", TType::I64, 40))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.request_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("requestId", TType::String, 50))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.skip_signal_reapply {
      o_prot.write_field_begin(&TFieldIdentifier::new("skipSignalReapply", TType::Bool, 60))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ResetWorkflowExecutionResponse
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ResetWorkflowExecutionResponse {
  pub run_id: Option<String>,
}

impl ResetWorkflowExecutionResponse {
  pub fn new<F10>(run_id: F10) -> ResetWorkflowExecutionResponse where F10: Into<Option<String>> {
    ResetWorkflowExecutionResponse {
      run_id: run_id.into(),
    }
  }
}

impl TSerializable for ResetWorkflowExecutionResponse {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ResetWorkflowExecutionResponse> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ResetWorkflowExecutionResponse {
      run_id: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ResetWorkflowExecutionResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.run_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("runId", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ListOpenWorkflowExecutionsRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ListOpenWorkflowExecutionsRequest {
  pub domain: Option<String>,
  pub maximum_page_size: Option<i32>,
  pub next_page_token: Option<Vec<u8>>,
  pub start_time_filter: Option<StartTimeFilter>,
  pub execution_filter: Option<WorkflowExecutionFilter>,
  pub type_filter: Option<WorkflowTypeFilter>,
}

impl ListOpenWorkflowExecutionsRequest {
  pub fn new<F10, F20, F30, F40, F50, F60>(domain: F10, maximum_page_size: F20, next_page_token: F30, start_time_filter: F40, execution_filter: F50, type_filter: F60) -> ListOpenWorkflowExecutionsRequest where F10: Into<Option<String>>, F20: Into<Option<i32>>, F30: Into<Option<Vec<u8>>>, F40: Into<Option<StartTimeFilter>>, F50: Into<Option<WorkflowExecutionFilter>>, F60: Into<Option<WorkflowTypeFilter>> {
    ListOpenWorkflowExecutionsRequest {
      domain: domain.into(),
      maximum_page_size: maximum_page_size.into(),
      next_page_token: next_page_token.into(),
      start_time_filter: start_time_filter.into(),
      execution_filter: execution_filter.into(),
      type_filter: type_filter.into(),
    }
  }
}

impl TSerializable for ListOpenWorkflowExecutionsRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ListOpenWorkflowExecutionsRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<i32> = None;
    let mut f_30: Option<Vec<u8>> = None;
    let mut f_40: Option<StartTimeFilter> = None;
    let mut f_50: Option<WorkflowExecutionFilter> = None;
    let mut f_60: Option<WorkflowTypeFilter> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_i32()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_bytes()?;
          f_30 = Some(val);
        },
        40 => {
          let val = StartTimeFilter::read_from_in_protocol(i_prot)?;
          f_40 = Some(val);
        },
        50 => {
          let val = WorkflowExecutionFilter::read_from_in_protocol(i_prot)?;
          f_50 = Some(val);
        },
        60 => {
          let val = WorkflowTypeFilter::read_from_in_protocol(i_prot)?;
          f_60 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ListOpenWorkflowExecutionsRequest {
      domain: f_10,
      maximum_page_size: f_20,
      next_page_token: f_30,
      start_time_filter: f_40,
      execution_filter: f_50,
      type_filter: f_60,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ListOpenWorkflowExecutionsRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.maximum_page_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("maximumPageSize", TType::I32, 20))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.next_page_token {
      o_prot.write_field_begin(&TFieldIdentifier::new("nextPageToken", TType::String, 30))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.start_time_filter {
      o_prot.write_field_begin(&TFieldIdentifier::new("StartTimeFilter", TType::Struct, 40))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.execution_filter {
      o_prot.write_field_begin(&TFieldIdentifier::new("executionFilter", TType::Struct, 50))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.type_filter {
      o_prot.write_field_begin(&TFieldIdentifier::new("typeFilter", TType::Struct, 60))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ListOpenWorkflowExecutionsResponse
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ListOpenWorkflowExecutionsResponse {
  pub executions: Option<Vec<WorkflowExecutionInfo>>,
  pub next_page_token: Option<Vec<u8>>,
}

impl ListOpenWorkflowExecutionsResponse {
  pub fn new<F10, F20>(executions: F10, next_page_token: F20) -> ListOpenWorkflowExecutionsResponse where F10: Into<Option<Vec<WorkflowExecutionInfo>>>, F20: Into<Option<Vec<u8>>> {
    ListOpenWorkflowExecutionsResponse {
      executions: executions.into(),
      next_page_token: next_page_token.into(),
    }
  }
}

impl TSerializable for ListOpenWorkflowExecutionsResponse {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ListOpenWorkflowExecutionsResponse> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<Vec<WorkflowExecutionInfo>> = None;
    let mut f_20: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<WorkflowExecutionInfo> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_44 = WorkflowExecutionInfo::read_from_in_protocol(i_prot)?;
            val.push(list_elem_44);
          }
          i_prot.read_list_end()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_bytes()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ListOpenWorkflowExecutionsResponse {
      executions: f_10,
      next_page_token: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ListOpenWorkflowExecutionsResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.executions {
      o_prot.write_field_begin(&TFieldIdentifier::new("executions", TType::List, 10))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.next_page_token {
      o_prot.write_field_begin(&TFieldIdentifier::new("nextPageToken", TType::String, 20))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ListClosedWorkflowExecutionsRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ListClosedWorkflowExecutionsRequest {
  pub domain: Option<String>,
  pub maximum_page_size: Option<i32>,
  pub next_page_token: Option<Vec<u8>>,
  pub start_time_filter: Option<StartTimeFilter>,
  pub execution_filter: Option<WorkflowExecutionFilter>,
  pub type_filter: Option<WorkflowTypeFilter>,
  pub status_filter: Option<WorkflowExecutionCloseStatus>,
}

impl ListClosedWorkflowExecutionsRequest {
  pub fn new<F10, F20, F30, F40, F50, F60, F70>(domain: F10, maximum_page_size: F20, next_page_token: F30, start_time_filter: F40, execution_filter: F50, type_filter: F60, status_filter: F70) -> ListClosedWorkflowExecutionsRequest where F10: Into<Option<String>>, F20: Into<Option<i32>>, F30: Into<Option<Vec<u8>>>, F40: Into<Option<StartTimeFilter>>, F50: Into<Option<WorkflowExecutionFilter>>, F60: Into<Option<WorkflowTypeFilter>>, F70: Into<Option<WorkflowExecutionCloseStatus>> {
    ListClosedWorkflowExecutionsRequest {
      domain: domain.into(),
      maximum_page_size: maximum_page_size.into(),
      next_page_token: next_page_token.into(),
      start_time_filter: start_time_filter.into(),
      execution_filter: execution_filter.into(),
      type_filter: type_filter.into(),
      status_filter: status_filter.into(),
    }
  }
}

impl TSerializable for ListClosedWorkflowExecutionsRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ListClosedWorkflowExecutionsRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<i32> = None;
    let mut f_30: Option<Vec<u8>> = None;
    let mut f_40: Option<StartTimeFilter> = None;
    let mut f_50: Option<WorkflowExecutionFilter> = None;
    let mut f_60: Option<WorkflowTypeFilter> = None;
    let mut f_70: Option<WorkflowExecutionCloseStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_i32()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_bytes()?;
          f_30 = Some(val);
        },
        40 => {
          let val = StartTimeFilter::read_from_in_protocol(i_prot)?;
          f_40 = Some(val);
        },
        50 => {
          let val = WorkflowExecutionFilter::read_from_in_protocol(i_prot)?;
          f_50 = Some(val);
        },
        60 => {
          let val = WorkflowTypeFilter::read_from_in_protocol(i_prot)?;
          f_60 = Some(val);
        },
        70 => {
          let val = WorkflowExecutionCloseStatus::read_from_in_protocol(i_prot)?;
          f_70 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ListClosedWorkflowExecutionsRequest {
      domain: f_10,
      maximum_page_size: f_20,
      next_page_token: f_30,
      start_time_filter: f_40,
      execution_filter: f_50,
      type_filter: f_60,
      status_filter: f_70,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ListClosedWorkflowExecutionsRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.maximum_page_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("maximumPageSize", TType::I32, 20))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.next_page_token {
      o_prot.write_field_begin(&TFieldIdentifier::new("nextPageToken", TType::String, 30))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.start_time_filter {
      o_prot.write_field_begin(&TFieldIdentifier::new("StartTimeFilter", TType::Struct, 40))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.execution_filter {
      o_prot.write_field_begin(&TFieldIdentifier::new("executionFilter", TType::Struct, 50))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.type_filter {
      o_prot.write_field_begin(&TFieldIdentifier::new("typeFilter", TType::Struct, 60))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.status_filter {
      o_prot.write_field_begin(&TFieldIdentifier::new("statusFilter", TType::I32, 70))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ListClosedWorkflowExecutionsResponse
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ListClosedWorkflowExecutionsResponse {
  pub executions: Option<Vec<WorkflowExecutionInfo>>,
  pub next_page_token: Option<Vec<u8>>,
}

impl ListClosedWorkflowExecutionsResponse {
  pub fn new<F10, F20>(executions: F10, next_page_token: F20) -> ListClosedWorkflowExecutionsResponse where F10: Into<Option<Vec<WorkflowExecutionInfo>>>, F20: Into<Option<Vec<u8>>> {
    ListClosedWorkflowExecutionsResponse {
      executions: executions.into(),
      next_page_token: next_page_token.into(),
    }
  }
}

impl TSerializable for ListClosedWorkflowExecutionsResponse {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ListClosedWorkflowExecutionsResponse> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<Vec<WorkflowExecutionInfo>> = None;
    let mut f_20: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<WorkflowExecutionInfo> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_45 = WorkflowExecutionInfo::read_from_in_protocol(i_prot)?;
            val.push(list_elem_45);
          }
          i_prot.read_list_end()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_bytes()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ListClosedWorkflowExecutionsResponse {
      executions: f_10,
      next_page_token: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ListClosedWorkflowExecutionsResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.executions {
      o_prot.write_field_begin(&TFieldIdentifier::new("executions", TType::List, 10))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.next_page_token {
      o_prot.write_field_begin(&TFieldIdentifier::new("nextPageToken", TType::String, 20))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ListWorkflowExecutionsRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ListWorkflowExecutionsRequest {
  pub domain: Option<String>,
  pub page_size: Option<i32>,
  pub next_page_token: Option<Vec<u8>>,
  pub query: Option<String>,
}

impl ListWorkflowExecutionsRequest {
  pub fn new<F10, F20, F30, F40>(domain: F10, page_size: F20, next_page_token: F30, query: F40) -> ListWorkflowExecutionsRequest where F10: Into<Option<String>>, F20: Into<Option<i32>>, F30: Into<Option<Vec<u8>>>, F40: Into<Option<String>> {
    ListWorkflowExecutionsRequest {
      domain: domain.into(),
      page_size: page_size.into(),
      next_page_token: next_page_token.into(),
      query: query.into(),
    }
  }
}

impl TSerializable for ListWorkflowExecutionsRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ListWorkflowExecutionsRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<i32> = None;
    let mut f_30: Option<Vec<u8>> = None;
    let mut f_40: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_i32()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_bytes()?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_string()?;
          f_40 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ListWorkflowExecutionsRequest {
      domain: f_10,
      page_size: f_20,
      next_page_token: f_30,
      query: f_40,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ListWorkflowExecutionsRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.page_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("pageSize", TType::I32, 20))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.next_page_token {
      o_prot.write_field_begin(&TFieldIdentifier::new("nextPageToken", TType::String, 30))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.query {
      o_prot.write_field_begin(&TFieldIdentifier::new("query", TType::String, 40))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ListWorkflowExecutionsResponse
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ListWorkflowExecutionsResponse {
  pub executions: Option<Vec<WorkflowExecutionInfo>>,
  pub next_page_token: Option<Vec<u8>>,
}

impl ListWorkflowExecutionsResponse {
  pub fn new<F10, F20>(executions: F10, next_page_token: F20) -> ListWorkflowExecutionsResponse where F10: Into<Option<Vec<WorkflowExecutionInfo>>>, F20: Into<Option<Vec<u8>>> {
    ListWorkflowExecutionsResponse {
      executions: executions.into(),
      next_page_token: next_page_token.into(),
    }
  }
}

impl TSerializable for ListWorkflowExecutionsResponse {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ListWorkflowExecutionsResponse> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<Vec<WorkflowExecutionInfo>> = None;
    let mut f_20: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<WorkflowExecutionInfo> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_46 = WorkflowExecutionInfo::read_from_in_protocol(i_prot)?;
            val.push(list_elem_46);
          }
          i_prot.read_list_end()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_bytes()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ListWorkflowExecutionsResponse {
      executions: f_10,
      next_page_token: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ListWorkflowExecutionsResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.executions {
      o_prot.write_field_begin(&TFieldIdentifier::new("executions", TType::List, 10))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.next_page_token {
      o_prot.write_field_begin(&TFieldIdentifier::new("nextPageToken", TType::String, 20))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ListArchivedWorkflowExecutionsRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ListArchivedWorkflowExecutionsRequest {
  pub domain: Option<String>,
  pub page_size: Option<i32>,
  pub next_page_token: Option<Vec<u8>>,
  pub query: Option<String>,
}

impl ListArchivedWorkflowExecutionsRequest {
  pub fn new<F10, F20, F30, F40>(domain: F10, page_size: F20, next_page_token: F30, query: F40) -> ListArchivedWorkflowExecutionsRequest where F10: Into<Option<String>>, F20: Into<Option<i32>>, F30: Into<Option<Vec<u8>>>, F40: Into<Option<String>> {
    ListArchivedWorkflowExecutionsRequest {
      domain: domain.into(),
      page_size: page_size.into(),
      next_page_token: next_page_token.into(),
      query: query.into(),
    }
  }
}

impl TSerializable for ListArchivedWorkflowExecutionsRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ListArchivedWorkflowExecutionsRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<i32> = None;
    let mut f_30: Option<Vec<u8>> = None;
    let mut f_40: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_i32()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_bytes()?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_string()?;
          f_40 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ListArchivedWorkflowExecutionsRequest {
      domain: f_10,
      page_size: f_20,
      next_page_token: f_30,
      query: f_40,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ListArchivedWorkflowExecutionsRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.page_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("pageSize", TType::I32, 20))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.next_page_token {
      o_prot.write_field_begin(&TFieldIdentifier::new("nextPageToken", TType::String, 30))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.query {
      o_prot.write_field_begin(&TFieldIdentifier::new("query", TType::String, 40))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ListArchivedWorkflowExecutionsResponse
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ListArchivedWorkflowExecutionsResponse {
  pub executions: Option<Vec<WorkflowExecutionInfo>>,
  pub next_page_token: Option<Vec<u8>>,
}

impl ListArchivedWorkflowExecutionsResponse {
  pub fn new<F10, F20>(executions: F10, next_page_token: F20) -> ListArchivedWorkflowExecutionsResponse where F10: Into<Option<Vec<WorkflowExecutionInfo>>>, F20: Into<Option<Vec<u8>>> {
    ListArchivedWorkflowExecutionsResponse {
      executions: executions.into(),
      next_page_token: next_page_token.into(),
    }
  }
}

impl TSerializable for ListArchivedWorkflowExecutionsResponse {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ListArchivedWorkflowExecutionsResponse> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<Vec<WorkflowExecutionInfo>> = None;
    let mut f_20: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<WorkflowExecutionInfo> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_47 = WorkflowExecutionInfo::read_from_in_protocol(i_prot)?;
            val.push(list_elem_47);
          }
          i_prot.read_list_end()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_bytes()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ListArchivedWorkflowExecutionsResponse {
      executions: f_10,
      next_page_token: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ListArchivedWorkflowExecutionsResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.executions {
      o_prot.write_field_begin(&TFieldIdentifier::new("executions", TType::List, 10))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.next_page_token {
      o_prot.write_field_begin(&TFieldIdentifier::new("nextPageToken", TType::String, 20))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// CountWorkflowExecutionsRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CountWorkflowExecutionsRequest {
  pub domain: Option<String>,
  pub query: Option<String>,
}

impl CountWorkflowExecutionsRequest {
  pub fn new<F10, F20>(domain: F10, query: F20) -> CountWorkflowExecutionsRequest where F10: Into<Option<String>>, F20: Into<Option<String>> {
    CountWorkflowExecutionsRequest {
      domain: domain.into(),
      query: query.into(),
    }
  }
}

impl TSerializable for CountWorkflowExecutionsRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CountWorkflowExecutionsRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CountWorkflowExecutionsRequest {
      domain: f_10,
      query: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CountWorkflowExecutionsRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.query {
      o_prot.write_field_begin(&TFieldIdentifier::new("query", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// CountWorkflowExecutionsResponse
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CountWorkflowExecutionsResponse {
  pub count: Option<i64>,
}

impl CountWorkflowExecutionsResponse {
  pub fn new<F10>(count: F10) -> CountWorkflowExecutionsResponse where F10: Into<Option<i64>> {
    CountWorkflowExecutionsResponse {
      count: count.into(),
    }
  }
}

impl TSerializable for CountWorkflowExecutionsResponse {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CountWorkflowExecutionsResponse> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_i64()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CountWorkflowExecutionsResponse {
      count: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CountWorkflowExecutionsResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.count {
      o_prot.write_field_begin(&TFieldIdentifier::new("count", TType::I64, 10))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// GetSearchAttributesResponse
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GetSearchAttributesResponse {
  pub keys: Option<BTreeMap<String, IndexedValueType>>,
}

impl GetSearchAttributesResponse {
  pub fn new<F10>(keys: F10) -> GetSearchAttributesResponse where F10: Into<Option<BTreeMap<String, IndexedValueType>>> {
    GetSearchAttributesResponse {
      keys: keys.into(),
    }
  }
}

impl TSerializable for GetSearchAttributesResponse {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GetSearchAttributesResponse> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<BTreeMap<String, IndexedValueType>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, IndexedValueType> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_48 = i_prot.read_string()?;
            let map_val_49 = IndexedValueType::read_from_in_protocol(i_prot)?;
            val.insert(map_key_48, map_val_49);
          }
          i_prot.read_map_end()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = GetSearchAttributesResponse {
      keys: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetSearchAttributesResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.keys {
      o_prot.write_field_begin(&TFieldIdentifier::new("keys", TType::Map, 10))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::I32, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        v.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// QueryWorkflowRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct QueryWorkflowRequest {
  pub domain: Option<String>,
  pub execution: Option<WorkflowExecution>,
  pub query: Option<Box<WorkflowQuery>>,
  pub query_reject_condition: Option<QueryRejectCondition>,
  pub query_consistency_level: Option<QueryConsistencyLevel>,
}

impl QueryWorkflowRequest {
  pub fn new<F10, F20, F30, F40, F50>(domain: F10, execution: F20, query: F30, query_reject_condition: F40, query_consistency_level: F50) -> QueryWorkflowRequest where F10: Into<Option<String>>, F20: Into<Option<WorkflowExecution>>, F30: Into<Option<Box<WorkflowQuery>>>, F40: Into<Option<QueryRejectCondition>>, F50: Into<Option<QueryConsistencyLevel>> {
    QueryWorkflowRequest {
      domain: domain.into(),
      execution: execution.into(),
      query: query.into(),
      query_reject_condition: query_reject_condition.into(),
      query_consistency_level: query_consistency_level.into(),
    }
  }
}

impl TSerializable for QueryWorkflowRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<QueryWorkflowRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<WorkflowExecution> = None;
    let mut f_30: Option<Box<WorkflowQuery>> = None;
    let mut f_40: Option<QueryRejectCondition> = None;
    let mut f_50: Option<QueryConsistencyLevel> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = WorkflowExecution::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        30 => {
          let val = Box::new(WorkflowQuery::read_from_in_protocol(i_prot)?);
          f_30 = Some(val);
        },
        40 => {
          let val = QueryRejectCondition::read_from_in_protocol(i_prot)?;
          f_40 = Some(val);
        },
        50 => {
          let val = QueryConsistencyLevel::read_from_in_protocol(i_prot)?;
          f_50 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = QueryWorkflowRequest {
      domain: f_10,
      execution: f_20,
      query: f_30,
      query_reject_condition: f_40,
      query_consistency_level: f_50,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("QueryWorkflowRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.execution {
      o_prot.write_field_begin(&TFieldIdentifier::new("execution", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.query {
      o_prot.write_field_begin(&TFieldIdentifier::new("query", TType::Struct, 30))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.query_reject_condition {
      o_prot.write_field_begin(&TFieldIdentifier::new("queryRejectCondition", TType::I32, 40))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.query_consistency_level {
      o_prot.write_field_begin(&TFieldIdentifier::new("queryConsistencyLevel", TType::I32, 50))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// QueryRejected
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct QueryRejected {
  pub close_status: Option<WorkflowExecutionCloseStatus>,
}

impl QueryRejected {
  pub fn new<F10>(close_status: F10) -> QueryRejected where F10: Into<Option<WorkflowExecutionCloseStatus>> {
    QueryRejected {
      close_status: close_status.into(),
    }
  }
}

impl TSerializable for QueryRejected {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<QueryRejected> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<WorkflowExecutionCloseStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = WorkflowExecutionCloseStatus::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = QueryRejected {
      close_status: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("QueryRejected");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.close_status {
      o_prot.write_field_begin(&TFieldIdentifier::new("closeStatus", TType::I32, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// QueryWorkflowResponse
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct QueryWorkflowResponse {
  pub query_result: Option<Vec<u8>>,
  pub query_rejected: Option<QueryRejected>,
}

impl QueryWorkflowResponse {
  pub fn new<F10, F20>(query_result: F10, query_rejected: F20) -> QueryWorkflowResponse where F10: Into<Option<Vec<u8>>>, F20: Into<Option<QueryRejected>> {
    QueryWorkflowResponse {
      query_result: query_result.into(),
      query_rejected: query_rejected.into(),
    }
  }
}

impl TSerializable for QueryWorkflowResponse {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<QueryWorkflowResponse> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<Vec<u8>> = None;
    let mut f_20: Option<QueryRejected> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_bytes()?;
          f_10 = Some(val);
        },
        20 => {
          let val = QueryRejected::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = QueryWorkflowResponse {
      query_result: f_10,
      query_rejected: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("QueryWorkflowResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.query_result {
      o_prot.write_field_begin(&TFieldIdentifier::new("queryResult", TType::String, 10))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.query_rejected {
      o_prot.write_field_begin(&TFieldIdentifier::new("queryRejected", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowQuery
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WorkflowQuery {
  pub query_type: Option<String>,
  pub query_args: Option<Vec<u8>>,
}

impl WorkflowQuery {
  pub fn new<F10, F20>(query_type: F10, query_args: F20) -> WorkflowQuery where F10: Into<Option<String>>, F20: Into<Option<Vec<u8>>> {
    WorkflowQuery {
      query_type: query_type.into(),
      query_args: query_args.into(),
    }
  }
}

impl TSerializable for WorkflowQuery {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowQuery> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_bytes()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowQuery {
      query_type: f_10,
      query_args: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowQuery");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.query_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("queryType", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.query_args {
      o_prot.write_field_begin(&TFieldIdentifier::new("queryArgs", TType::String, 20))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ResetStickyTaskListRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ResetStickyTaskListRequest {
  pub domain: Option<String>,
  pub execution: Option<WorkflowExecution>,
}

impl ResetStickyTaskListRequest {
  pub fn new<F10, F20>(domain: F10, execution: F20) -> ResetStickyTaskListRequest where F10: Into<Option<String>>, F20: Into<Option<WorkflowExecution>> {
    ResetStickyTaskListRequest {
      domain: domain.into(),
      execution: execution.into(),
    }
  }
}

impl TSerializable for ResetStickyTaskListRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ResetStickyTaskListRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<WorkflowExecution> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = WorkflowExecution::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ResetStickyTaskListRequest {
      domain: f_10,
      execution: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ResetStickyTaskListRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.execution {
      o_prot.write_field_begin(&TFieldIdentifier::new("execution", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ResetStickyTaskListResponse
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ResetStickyTaskListResponse {
}

impl ResetStickyTaskListResponse {
  pub fn new() -> ResetStickyTaskListResponse {
    ResetStickyTaskListResponse {}
  }
}

impl TSerializable for ResetStickyTaskListResponse {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ResetStickyTaskListResponse> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      i_prot.skip(field_ident.field_type)?;
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ResetStickyTaskListResponse {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ResetStickyTaskListResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// RespondQueryTaskCompletedRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RespondQueryTaskCompletedRequest {
  pub task_token: Option<Vec<u8>>,
  pub completed_type: Option<QueryTaskCompletedType>,
  pub query_result: Option<Vec<u8>>,
  pub error_message: Option<String>,
  pub worker_version_info: Option<WorkerVersionInfo>,
}

impl RespondQueryTaskCompletedRequest {
  pub fn new<F10, F20, F30, F40, F50>(task_token: F10, completed_type: F20, query_result: F30, error_message: F40, worker_version_info: F50) -> RespondQueryTaskCompletedRequest where F10: Into<Option<Vec<u8>>>, F20: Into<Option<QueryTaskCompletedType>>, F30: Into<Option<Vec<u8>>>, F40: Into<Option<String>>, F50: Into<Option<WorkerVersionInfo>> {
    RespondQueryTaskCompletedRequest {
      task_token: task_token.into(),
      completed_type: completed_type.into(),
      query_result: query_result.into(),
      error_message: error_message.into(),
      worker_version_info: worker_version_info.into(),
    }
  }
}

impl TSerializable for RespondQueryTaskCompletedRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RespondQueryTaskCompletedRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<Vec<u8>> = None;
    let mut f_20: Option<QueryTaskCompletedType> = None;
    let mut f_30: Option<Vec<u8>> = None;
    let mut f_40: Option<String> = None;
    let mut f_50: Option<WorkerVersionInfo> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_bytes()?;
          f_10 = Some(val);
        },
        20 => {
          let val = QueryTaskCompletedType::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_bytes()?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_string()?;
          f_40 = Some(val);
        },
        50 => {
          let val = WorkerVersionInfo::read_from_in_protocol(i_prot)?;
          f_50 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RespondQueryTaskCompletedRequest {
      task_token: f_10,
      completed_type: f_20,
      query_result: f_30,
      error_message: f_40,
      worker_version_info: f_50,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RespondQueryTaskCompletedRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.task_token {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskToken", TType::String, 10))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.completed_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("completedType", TType::I32, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.query_result {
      o_prot.write_field_begin(&TFieldIdentifier::new("queryResult", TType::String, 30))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.error_message {
      o_prot.write_field_begin(&TFieldIdentifier::new("errorMessage", TType::String, 40))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.worker_version_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("workerVersionInfo", TType::Struct, 50))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// WorkflowQueryResult
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WorkflowQueryResult {
  pub result_type: Option<QueryResultType>,
  pub answer: Option<Vec<u8>>,
  pub error_message: Option<String>,
}

impl WorkflowQueryResult {
  pub fn new<F10, F20, F30>(result_type: F10, answer: F20, error_message: F30) -> WorkflowQueryResult where F10: Into<Option<QueryResultType>>, F20: Into<Option<Vec<u8>>>, F30: Into<Option<String>> {
    WorkflowQueryResult {
      result_type: result_type.into(),
      answer: answer.into(),
      error_message: error_message.into(),
    }
  }
}

impl TSerializable for WorkflowQueryResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<WorkflowQueryResult> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<QueryResultType> = None;
    let mut f_20: Option<Vec<u8>> = None;
    let mut f_30: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = QueryResultType::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_bytes()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_string()?;
          f_30 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WorkflowQueryResult {
      result_type: f_10,
      answer: f_20,
      error_message: f_30,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WorkflowQueryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("resultType", TType::I32, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.answer {
      o_prot.write_field_begin(&TFieldIdentifier::new("answer", TType::String, 20))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.error_message {
      o_prot.write_field_begin(&TFieldIdentifier::new("errorMessage", TType::String, 30))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DescribeWorkflowExecutionRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DescribeWorkflowExecutionRequest {
  pub domain: Option<String>,
  pub execution: Option<WorkflowExecution>,
  pub query_consistency_level: Option<QueryConsistencyLevel>,
}

impl DescribeWorkflowExecutionRequest {
  pub fn new<F10, F20, F30>(domain: F10, execution: F20, query_consistency_level: F30) -> DescribeWorkflowExecutionRequest where F10: Into<Option<String>>, F20: Into<Option<WorkflowExecution>>, F30: Into<Option<QueryConsistencyLevel>> {
    DescribeWorkflowExecutionRequest {
      domain: domain.into(),
      execution: execution.into(),
      query_consistency_level: query_consistency_level.into(),
    }
  }
}

impl TSerializable for DescribeWorkflowExecutionRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DescribeWorkflowExecutionRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<WorkflowExecution> = None;
    let mut f_30: Option<QueryConsistencyLevel> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = WorkflowExecution::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        30 => {
          let val = QueryConsistencyLevel::read_from_in_protocol(i_prot)?;
          f_30 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DescribeWorkflowExecutionRequest {
      domain: f_10,
      execution: f_20,
      query_consistency_level: f_30,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DescribeWorkflowExecutionRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.execution {
      o_prot.write_field_begin(&TFieldIdentifier::new("execution", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.query_consistency_level {
      o_prot.write_field_begin(&TFieldIdentifier::new("queryConsistencyLevel", TType::I32, 30))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// PendingActivityInfo
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PendingActivityInfo {
  pub activity_i_d: Option<String>,
  pub activity_type: Option<ActivityType>,
  pub state: Option<PendingActivityState>,
  pub heartbeat_details: Option<Vec<u8>>,
  pub last_heartbeat_timestamp: Option<i64>,
  pub last_started_timestamp: Option<i64>,
  pub attempt: Option<i32>,
  pub maximum_attempts: Option<i32>,
  pub scheduled_timestamp: Option<i64>,
  pub expiration_timestamp: Option<i64>,
  pub last_failure_reason: Option<String>,
  pub last_worker_identity: Option<String>,
  pub last_failure_details: Option<Vec<u8>>,
  pub started_worker_identity: Option<String>,
  pub schedule_i_d: Option<i64>,
}

impl PendingActivityInfo {
  pub fn new<F10, F20, F30, F40, F50, F60, F70, F80, F90, F100, F110, F120, F130, F140, F150>(activity_i_d: F10, activity_type: F20, state: F30, heartbeat_details: F40, last_heartbeat_timestamp: F50, last_started_timestamp: F60, attempt: F70, maximum_attempts: F80, scheduled_timestamp: F90, expiration_timestamp: F100, last_failure_reason: F110, last_worker_identity: F120, last_failure_details: F130, started_worker_identity: F140, schedule_i_d: F150) -> PendingActivityInfo where F10: Into<Option<String>>, F20: Into<Option<ActivityType>>, F30: Into<Option<PendingActivityState>>, F40: Into<Option<Vec<u8>>>, F50: Into<Option<i64>>, F60: Into<Option<i64>>, F70: Into<Option<i32>>, F80: Into<Option<i32>>, F90: Into<Option<i64>>, F100: Into<Option<i64>>, F110: Into<Option<String>>, F120: Into<Option<String>>, F130: Into<Option<Vec<u8>>>, F140: Into<Option<String>>, F150: Into<Option<i64>> {
    PendingActivityInfo {
      activity_i_d: activity_i_d.into(),
      activity_type: activity_type.into(),
      state: state.into(),
      heartbeat_details: heartbeat_details.into(),
      last_heartbeat_timestamp: last_heartbeat_timestamp.into(),
      last_started_timestamp: last_started_timestamp.into(),
      attempt: attempt.into(),
      maximum_attempts: maximum_attempts.into(),
      scheduled_timestamp: scheduled_timestamp.into(),
      expiration_timestamp: expiration_timestamp.into(),
      last_failure_reason: last_failure_reason.into(),
      last_worker_identity: last_worker_identity.into(),
      last_failure_details: last_failure_details.into(),
      started_worker_identity: started_worker_identity.into(),
      schedule_i_d: schedule_i_d.into(),
    }
  }
}

impl TSerializable for PendingActivityInfo {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PendingActivityInfo> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<ActivityType> = None;
    let mut f_30: Option<PendingActivityState> = None;
    let mut f_40: Option<Vec<u8>> = None;
    let mut f_50: Option<i64> = None;
    let mut f_60: Option<i64> = None;
    let mut f_70: Option<i32> = None;
    let mut f_80: Option<i32> = None;
    let mut f_90: Option<i64> = None;
    let mut f_100: Option<i64> = None;
    let mut f_110: Option<String> = None;
    let mut f_120: Option<String> = None;
    let mut f_130: Option<Vec<u8>> = None;
    let mut f_140: Option<String> = None;
    let mut f_150: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = ActivityType::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        30 => {
          let val = PendingActivityState::read_from_in_protocol(i_prot)?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_bytes()?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_i64()?;
          f_50 = Some(val);
        },
        60 => {
          let val = i_prot.read_i64()?;
          f_60 = Some(val);
        },
        70 => {
          let val = i_prot.read_i32()?;
          f_70 = Some(val);
        },
        80 => {
          let val = i_prot.read_i32()?;
          f_80 = Some(val);
        },
        90 => {
          let val = i_prot.read_i64()?;
          f_90 = Some(val);
        },
        100 => {
          let val = i_prot.read_i64()?;
          f_100 = Some(val);
        },
        110 => {
          let val = i_prot.read_string()?;
          f_110 = Some(val);
        },
        120 => {
          let val = i_prot.read_string()?;
          f_120 = Some(val);
        },
        130 => {
          let val = i_prot.read_bytes()?;
          f_130 = Some(val);
        },
        140 => {
          let val = i_prot.read_string()?;
          f_140 = Some(val);
        },
        150 => {
          let val = i_prot.read_i64()?;
          f_150 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = PendingActivityInfo {
      activity_i_d: f_10,
      activity_type: f_20,
      state: f_30,
      heartbeat_details: f_40,
      last_heartbeat_timestamp: f_50,
      last_started_timestamp: f_60,
      attempt: f_70,
      maximum_attempts: f_80,
      scheduled_timestamp: f_90,
      expiration_timestamp: f_100,
      last_failure_reason: f_110,
      last_worker_identity: f_120,
      last_failure_details: f_130,
      started_worker_identity: f_140,
      schedule_i_d: f_150,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PendingActivityInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.activity_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("activityID", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.activity_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("activityType", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.state {
      o_prot.write_field_begin(&TFieldIdentifier::new("state", TType::I32, 30))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.heartbeat_details {
      o_prot.write_field_begin(&TFieldIdentifier::new("heartbeatDetails", TType::String, 40))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.last_heartbeat_timestamp {
      o_prot.write_field_begin(&TFieldIdentifier::new("lastHeartbeatTimestamp", TType::I64, 50))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.last_started_timestamp {
      o_prot.write_field_begin(&TFieldIdentifier::new("lastStartedTimestamp", TType::I64, 60))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.attempt {
      o_prot.write_field_begin(&TFieldIdentifier::new("attempt", TType::I32, 70))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.maximum_attempts {
      o_prot.write_field_begin(&TFieldIdentifier::new("maximumAttempts", TType::I32, 80))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.scheduled_timestamp {
      o_prot.write_field_begin(&TFieldIdentifier::new("scheduledTimestamp", TType::I64, 90))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.expiration_timestamp {
      o_prot.write_field_begin(&TFieldIdentifier::new("expirationTimestamp", TType::I64, 100))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.last_failure_reason {
      o_prot.write_field_begin(&TFieldIdentifier::new("lastFailureReason", TType::String, 110))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.last_worker_identity {
      o_prot.write_field_begin(&TFieldIdentifier::new("lastWorkerIdentity", TType::String, 120))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.last_failure_details {
      o_prot.write_field_begin(&TFieldIdentifier::new("lastFailureDetails", TType::String, 130))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.started_worker_identity {
      o_prot.write_field_begin(&TFieldIdentifier::new("startedWorkerIdentity", TType::String, 140))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.schedule_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("scheduleID", TType::I64, 150))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// PendingDecisionInfo
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PendingDecisionInfo {
  pub state: Option<PendingDecisionState>,
  pub scheduled_timestamp: Option<i64>,
  pub started_timestamp: Option<i64>,
  pub attempt: Option<i64>,
  pub original_scheduled_timestamp: Option<i64>,
  pub schedule_i_d: Option<i64>,
}

impl PendingDecisionInfo {
  pub fn new<F10, F20, F30, F40, F50, F60>(state: F10, scheduled_timestamp: F20, started_timestamp: F30, attempt: F40, original_scheduled_timestamp: F50, schedule_i_d: F60) -> PendingDecisionInfo where F10: Into<Option<PendingDecisionState>>, F20: Into<Option<i64>>, F30: Into<Option<i64>>, F40: Into<Option<i64>>, F50: Into<Option<i64>>, F60: Into<Option<i64>> {
    PendingDecisionInfo {
      state: state.into(),
      scheduled_timestamp: scheduled_timestamp.into(),
      started_timestamp: started_timestamp.into(),
      attempt: attempt.into(),
      original_scheduled_timestamp: original_scheduled_timestamp.into(),
      schedule_i_d: schedule_i_d.into(),
    }
  }
}

impl TSerializable for PendingDecisionInfo {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PendingDecisionInfo> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<PendingDecisionState> = None;
    let mut f_20: Option<i64> = None;
    let mut f_30: Option<i64> = None;
    let mut f_40: Option<i64> = None;
    let mut f_50: Option<i64> = None;
    let mut f_60: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = PendingDecisionState::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_i64()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_i64()?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_i64()?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_i64()?;
          f_50 = Some(val);
        },
        60 => {
          let val = i_prot.read_i64()?;
          f_60 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = PendingDecisionInfo {
      state: f_10,
      scheduled_timestamp: f_20,
      started_timestamp: f_30,
      attempt: f_40,
      original_scheduled_timestamp: f_50,
      schedule_i_d: f_60,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PendingDecisionInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.state {
      o_prot.write_field_begin(&TFieldIdentifier::new("state", TType::I32, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.scheduled_timestamp {
      o_prot.write_field_begin(&TFieldIdentifier::new("scheduledTimestamp", TType::I64, 20))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.started_timestamp {
      o_prot.write_field_begin(&TFieldIdentifier::new("startedTimestamp", TType::I64, 30))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.attempt {
      o_prot.write_field_begin(&TFieldIdentifier::new("attempt", TType::I64, 40))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.original_scheduled_timestamp {
      o_prot.write_field_begin(&TFieldIdentifier::new("originalScheduledTimestamp", TType::I64, 50))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.schedule_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("scheduleID", TType::I64, 60))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// PendingChildExecutionInfo
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PendingChildExecutionInfo {
  pub domain: Option<String>,
  pub workflow_i_d: Option<String>,
  pub run_i_d: Option<String>,
  pub workflow_typ_name: Option<String>,
  pub initiated_i_d: Option<i64>,
  pub parent_close_policy: Option<ParentClosePolicy>,
}

impl PendingChildExecutionInfo {
  pub fn new<F1, F10, F20, F30, F40, F50>(domain: F1, workflow_i_d: F10, run_i_d: F20, workflow_typ_name: F30, initiated_i_d: F40, parent_close_policy: F50) -> PendingChildExecutionInfo where F1: Into<Option<String>>, F10: Into<Option<String>>, F20: Into<Option<String>>, F30: Into<Option<String>>, F40: Into<Option<i64>>, F50: Into<Option<ParentClosePolicy>> {
    PendingChildExecutionInfo {
      domain: domain.into(),
      workflow_i_d: workflow_i_d.into(),
      run_i_d: run_i_d.into(),
      workflow_typ_name: workflow_typ_name.into(),
      initiated_i_d: initiated_i_d.into(),
      parent_close_policy: parent_close_policy.into(),
    }
  }
}

impl TSerializable for PendingChildExecutionInfo {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PendingChildExecutionInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<String> = None;
    let mut f_30: Option<String> = None;
    let mut f_40: Option<i64> = None;
    let mut f_50: Option<ParentClosePolicy> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_string()?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_i64()?;
          f_40 = Some(val);
        },
        50 => {
          let val = ParentClosePolicy::read_from_in_protocol(i_prot)?;
          f_50 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = PendingChildExecutionInfo {
      domain: f_1,
      workflow_i_d: f_10,
      run_i_d: f_20,
      workflow_typ_name: f_30,
      initiated_i_d: f_40,
      parent_close_policy: f_50,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PendingChildExecutionInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowID", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.run_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("runID", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_typ_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowTypName", TType::String, 30))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.initiated_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("initiatedID", TType::I64, 40))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.parent_close_policy {
      o_prot.write_field_begin(&TFieldIdentifier::new("parentClosePolicy", TType::I32, 50))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DescribeWorkflowExecutionResponse
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DescribeWorkflowExecutionResponse {
  pub execution_configuration: Option<WorkflowExecutionConfiguration>,
  pub workflow_execution_info: Option<WorkflowExecutionInfo>,
  pub pending_activities: Option<Vec<PendingActivityInfo>>,
  pub pending_children: Option<Vec<PendingChildExecutionInfo>>,
  pub pending_decision: Option<PendingDecisionInfo>,
}

impl DescribeWorkflowExecutionResponse {
  pub fn new<F10, F20, F30, F40, F50>(execution_configuration: F10, workflow_execution_info: F20, pending_activities: F30, pending_children: F40, pending_decision: F50) -> DescribeWorkflowExecutionResponse where F10: Into<Option<WorkflowExecutionConfiguration>>, F20: Into<Option<WorkflowExecutionInfo>>, F30: Into<Option<Vec<PendingActivityInfo>>>, F40: Into<Option<Vec<PendingChildExecutionInfo>>>, F50: Into<Option<PendingDecisionInfo>> {
    DescribeWorkflowExecutionResponse {
      execution_configuration: execution_configuration.into(),
      workflow_execution_info: workflow_execution_info.into(),
      pending_activities: pending_activities.into(),
      pending_children: pending_children.into(),
      pending_decision: pending_decision.into(),
    }
  }
}

impl TSerializable for DescribeWorkflowExecutionResponse {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DescribeWorkflowExecutionResponse> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<WorkflowExecutionConfiguration> = None;
    let mut f_20: Option<WorkflowExecutionInfo> = None;
    let mut f_30: Option<Vec<PendingActivityInfo>> = None;
    let mut f_40: Option<Vec<PendingChildExecutionInfo>> = None;
    let mut f_50: Option<PendingDecisionInfo> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = WorkflowExecutionConfiguration::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        20 => {
          let val = WorkflowExecutionInfo::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        30 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<PendingActivityInfo> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_50 = PendingActivityInfo::read_from_in_protocol(i_prot)?;
            val.push(list_elem_50);
          }
          i_prot.read_list_end()?;
          f_30 = Some(val);
        },
        40 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<PendingChildExecutionInfo> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_51 = PendingChildExecutionInfo::read_from_in_protocol(i_prot)?;
            val.push(list_elem_51);
          }
          i_prot.read_list_end()?;
          f_40 = Some(val);
        },
        50 => {
          let val = PendingDecisionInfo::read_from_in_protocol(i_prot)?;
          f_50 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DescribeWorkflowExecutionResponse {
      execution_configuration: f_10,
      workflow_execution_info: f_20,
      pending_activities: f_30,
      pending_children: f_40,
      pending_decision: f_50,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DescribeWorkflowExecutionResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.execution_configuration {
      o_prot.write_field_begin(&TFieldIdentifier::new("executionConfiguration", TType::Struct, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_execution_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecutionInfo", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.pending_activities {
      o_prot.write_field_begin(&TFieldIdentifier::new("pendingActivities", TType::List, 30))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.pending_children {
      o_prot.write_field_begin(&TFieldIdentifier::new("pendingChildren", TType::List, 40))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.pending_decision {
      o_prot.write_field_begin(&TFieldIdentifier::new("pendingDecision", TType::Struct, 50))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DescribeTaskListRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DescribeTaskListRequest {
  pub domain: Option<String>,
  pub task_list: Option<TaskList>,
  pub task_list_type: Option<Box<TaskListType>>,
  pub include_task_list_status: Option<bool>,
}

impl DescribeTaskListRequest {
  pub fn new<F10, F20, F30, F40>(domain: F10, task_list: F20, task_list_type: F30, include_task_list_status: F40) -> DescribeTaskListRequest where F10: Into<Option<String>>, F20: Into<Option<TaskList>>, F30: Into<Option<Box<TaskListType>>>, F40: Into<Option<bool>> {
    DescribeTaskListRequest {
      domain: domain.into(),
      task_list: task_list.into(),
      task_list_type: task_list_type.into(),
      include_task_list_status: include_task_list_status.into(),
    }
  }
}

impl TSerializable for DescribeTaskListRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DescribeTaskListRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<TaskList> = None;
    let mut f_30: Option<Box<TaskListType>> = None;
    let mut f_40: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = TaskList::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        30 => {
          let val = Box::new(TaskListType::read_from_in_protocol(i_prot)?);
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_bool()?;
          f_40 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DescribeTaskListRequest {
      domain: f_10,
      task_list: f_20,
      task_list_type: f_30,
      include_task_list_status: f_40,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DescribeTaskListRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.task_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskList", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.task_list_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskListType", TType::I32, 30))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.include_task_list_status {
      o_prot.write_field_begin(&TFieldIdentifier::new("includeTaskListStatus", TType::Bool, 40))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DescribeTaskListResponse
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DescribeTaskListResponse {
  pub pollers: Option<Vec<Box<PollerInfo>>>,
  pub task_list_status: Option<Box<TaskListStatus>>,
  pub task_list: Option<TaskList>,
}

impl DescribeTaskListResponse {
  pub fn new<F10, F20, F30>(pollers: F10, task_list_status: F20, task_list: F30) -> DescribeTaskListResponse where F10: Into<Option<Vec<Box<PollerInfo>>>>, F20: Into<Option<Box<TaskListStatus>>>, F30: Into<Option<TaskList>> {
    DescribeTaskListResponse {
      pollers: pollers.into(),
      task_list_status: task_list_status.into(),
      task_list: task_list.into(),
    }
  }
}

impl TSerializable for DescribeTaskListResponse {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DescribeTaskListResponse> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<Vec<Box<PollerInfo>>> = None;
    let mut f_20: Option<Box<TaskListStatus>> = None;
    let mut f_30: Option<TaskList> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Box<PollerInfo>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_52 = Box::new(PollerInfo::read_from_in_protocol(i_prot)?);
            val.push(list_elem_52);
          }
          i_prot.read_list_end()?;
          f_10 = Some(val);
        },
        20 => {
          let val = Box::new(TaskListStatus::read_from_in_protocol(i_prot)?);
          f_20 = Some(val);
        },
        30 => {
          let val = TaskList::read_from_in_protocol(i_prot)?;
          f_30 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DescribeTaskListResponse {
      pollers: f_10,
      task_list_status: f_20,
      task_list: f_30,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DescribeTaskListResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.pollers {
      o_prot.write_field_begin(&TFieldIdentifier::new("pollers", TType::List, 10))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.task_list_status {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskListStatus", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.task_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskList", TType::Struct, 30))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// GetTaskListsByDomainRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GetTaskListsByDomainRequest {
  pub domain_name: Option<String>,
}

impl GetTaskListsByDomainRequest {
  pub fn new<F10>(domain_name: F10) -> GetTaskListsByDomainRequest where F10: Into<Option<String>> {
    GetTaskListsByDomainRequest {
      domain_name: domain_name.into(),
    }
  }
}

impl TSerializable for GetTaskListsByDomainRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GetTaskListsByDomainRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = GetTaskListsByDomainRequest {
      domain_name: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetTaskListsByDomainRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.domain_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("domainName", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// GetTaskListsByDomainResponse
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GetTaskListsByDomainResponse {
  pub decision_task_list_map: Option<BTreeMap<String, DescribeTaskListResponse>>,
  pub activity_task_list_map: Option<BTreeMap<String, DescribeTaskListResponse>>,
}

impl GetTaskListsByDomainResponse {
  pub fn new<F10, F20>(decision_task_list_map: F10, activity_task_list_map: F20) -> GetTaskListsByDomainResponse where F10: Into<Option<BTreeMap<String, DescribeTaskListResponse>>>, F20: Into<Option<BTreeMap<String, DescribeTaskListResponse>>> {
    GetTaskListsByDomainResponse {
      decision_task_list_map: decision_task_list_map.into(),
      activity_task_list_map: activity_task_list_map.into(),
    }
  }
}

impl TSerializable for GetTaskListsByDomainResponse {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GetTaskListsByDomainResponse> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<BTreeMap<String, DescribeTaskListResponse>> = None;
    let mut f_20: Option<BTreeMap<String, DescribeTaskListResponse>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, DescribeTaskListResponse> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_53 = i_prot.read_string()?;
            let map_val_54 = DescribeTaskListResponse::read_from_in_protocol(i_prot)?;
            val.insert(map_key_53, map_val_54);
          }
          i_prot.read_map_end()?;
          f_10 = Some(val);
        },
        20 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, DescribeTaskListResponse> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_55 = i_prot.read_string()?;
            let map_val_56 = DescribeTaskListResponse::read_from_in_protocol(i_prot)?;
            val.insert(map_key_55, map_val_56);
          }
          i_prot.read_map_end()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = GetTaskListsByDomainResponse {
      decision_task_list_map: f_10,
      activity_task_list_map: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetTaskListsByDomainResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.decision_task_list_map {
      o_prot.write_field_begin(&TFieldIdentifier::new("decisionTaskListMap", TType::Map, 10))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        v.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.activity_task_list_map {
      o_prot.write_field_begin(&TFieldIdentifier::new("activityTaskListMap", TType::Map, 20))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        v.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ListTaskListPartitionsRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ListTaskListPartitionsRequest {
  pub domain: Option<String>,
  pub task_list: Option<TaskList>,
}

impl ListTaskListPartitionsRequest {
  pub fn new<F10, F20>(domain: F10, task_list: F20) -> ListTaskListPartitionsRequest where F10: Into<Option<String>>, F20: Into<Option<TaskList>> {
    ListTaskListPartitionsRequest {
      domain: domain.into(),
      task_list: task_list.into(),
    }
  }
}

impl TSerializable for ListTaskListPartitionsRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ListTaskListPartitionsRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<TaskList> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = TaskList::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ListTaskListPartitionsRequest {
      domain: f_10,
      task_list: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ListTaskListPartitionsRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.task_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskList", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TaskListPartitionMetadata
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TaskListPartitionMetadata {
  pub key: Option<String>,
  pub owner_host_name: Option<String>,
}

impl TaskListPartitionMetadata {
  pub fn new<F10, F20>(key: F10, owner_host_name: F20) -> TaskListPartitionMetadata where F10: Into<Option<String>>, F20: Into<Option<String>> {
    TaskListPartitionMetadata {
      key: key.into(),
      owner_host_name: owner_host_name.into(),
    }
  }
}

impl TSerializable for TaskListPartitionMetadata {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TaskListPartitionMetadata> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TaskListPartitionMetadata {
      key: f_10,
      owner_host_name: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TaskListPartitionMetadata");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.key {
      o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.owner_host_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("ownerHostName", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ListTaskListPartitionsResponse
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ListTaskListPartitionsResponse {
  pub activity_task_list_partitions: Option<Vec<TaskListPartitionMetadata>>,
  pub decision_task_list_partitions: Option<Vec<TaskListPartitionMetadata>>,
}

impl ListTaskListPartitionsResponse {
  pub fn new<F10, F20>(activity_task_list_partitions: F10, decision_task_list_partitions: F20) -> ListTaskListPartitionsResponse where F10: Into<Option<Vec<TaskListPartitionMetadata>>>, F20: Into<Option<Vec<TaskListPartitionMetadata>>> {
    ListTaskListPartitionsResponse {
      activity_task_list_partitions: activity_task_list_partitions.into(),
      decision_task_list_partitions: decision_task_list_partitions.into(),
    }
  }
}

impl TSerializable for ListTaskListPartitionsResponse {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ListTaskListPartitionsResponse> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<Vec<TaskListPartitionMetadata>> = None;
    let mut f_20: Option<Vec<TaskListPartitionMetadata>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TaskListPartitionMetadata> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_57 = TaskListPartitionMetadata::read_from_in_protocol(i_prot)?;
            val.push(list_elem_57);
          }
          i_prot.read_list_end()?;
          f_10 = Some(val);
        },
        20 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TaskListPartitionMetadata> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_58 = TaskListPartitionMetadata::read_from_in_protocol(i_prot)?;
            val.push(list_elem_58);
          }
          i_prot.read_list_end()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ListTaskListPartitionsResponse {
      activity_task_list_partitions: f_10,
      decision_task_list_partitions: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ListTaskListPartitionsResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.activity_task_list_partitions {
      o_prot.write_field_begin(&TFieldIdentifier::new("activityTaskListPartitions", TType::List, 10))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.decision_task_list_partitions {
      o_prot.write_field_begin(&TFieldIdentifier::new("decisionTaskListPartitions", TType::List, 20))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IsolationGroupMetrics
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct IsolationGroupMetrics {
  pub new_tasks_per_second: Option<OrderedFloat<f64>>,
  pub poller_count: Option<i64>,
}

impl IsolationGroupMetrics {
  pub fn new<F10, F20>(new_tasks_per_second: F10, poller_count: F20) -> IsolationGroupMetrics where F10: Into<Option<OrderedFloat<f64>>>, F20: Into<Option<i64>> {
    IsolationGroupMetrics {
      new_tasks_per_second: new_tasks_per_second.into(),
      poller_count: poller_count.into(),
    }
  }
}

impl TSerializable for IsolationGroupMetrics {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IsolationGroupMetrics> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<OrderedFloat<f64>> = None;
    let mut f_20: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_i64()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IsolationGroupMetrics {
      new_tasks_per_second: f_10,
      poller_count: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IsolationGroupMetrics");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.new_tasks_per_second {
      o_prot.write_field_begin(&TFieldIdentifier::new("newTasksPerSecond", TType::Double, 10))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.poller_count {
      o_prot.write_field_begin(&TFieldIdentifier::new("pollerCount", TType::I64, 20))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TaskListStatus
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TaskListStatus {
  pub backlog_count_hint: Option<i64>,
  pub read_level: Option<i64>,
  pub ack_level: Option<i64>,
  pub rate_per_second: Option<OrderedFloat<f64>>,
  pub task_i_d_block: Option<Box<TaskIDBlock>>,
  pub isolation_group_metrics: Option<BTreeMap<String, IsolationGroupMetrics>>,
  pub new_tasks_per_second: Option<OrderedFloat<f64>>,
  pub empty: Option<bool>,
}

impl TaskListStatus {
  pub fn new<F10, F20, F30, F35, F40, F50, F60, F70>(backlog_count_hint: F10, read_level: F20, ack_level: F30, rate_per_second: F35, task_i_d_block: F40, isolation_group_metrics: F50, new_tasks_per_second: F60, empty: F70) -> TaskListStatus where F10: Into<Option<i64>>, F20: Into<Option<i64>>, F30: Into<Option<i64>>, F35: Into<Option<OrderedFloat<f64>>>, F40: Into<Option<Box<TaskIDBlock>>>, F50: Into<Option<BTreeMap<String, IsolationGroupMetrics>>>, F60: Into<Option<OrderedFloat<f64>>>, F70: Into<Option<bool>> {
    TaskListStatus {
      backlog_count_hint: backlog_count_hint.into(),
      read_level: read_level.into(),
      ack_level: ack_level.into(),
      rate_per_second: rate_per_second.into(),
      task_i_d_block: task_i_d_block.into(),
      isolation_group_metrics: isolation_group_metrics.into(),
      new_tasks_per_second: new_tasks_per_second.into(),
      empty: empty.into(),
    }
  }
}

impl TSerializable for TaskListStatus {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TaskListStatus> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<i64> = None;
    let mut f_20: Option<i64> = None;
    let mut f_30: Option<i64> = None;
    let mut f_35: Option<OrderedFloat<f64>> = None;
    let mut f_40: Option<Box<TaskIDBlock>> = None;
    let mut f_50: Option<BTreeMap<String, IsolationGroupMetrics>> = None;
    let mut f_60: Option<OrderedFloat<f64>> = None;
    let mut f_70: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_i64()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_i64()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_i64()?;
          f_30 = Some(val);
        },
        35 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_35 = Some(val);
        },
        40 => {
          let val = Box::new(TaskIDBlock::read_from_in_protocol(i_prot)?);
          f_40 = Some(val);
        },
        50 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, IsolationGroupMetrics> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_59 = i_prot.read_string()?;
            let map_val_60 = IsolationGroupMetrics::read_from_in_protocol(i_prot)?;
            val.insert(map_key_59, map_val_60);
          }
          i_prot.read_map_end()?;
          f_50 = Some(val);
        },
        60 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_60 = Some(val);
        },
        70 => {
          let val = i_prot.read_bool()?;
          f_70 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TaskListStatus {
      backlog_count_hint: f_10,
      read_level: f_20,
      ack_level: f_30,
      rate_per_second: f_35,
      task_i_d_block: f_40,
      isolation_group_metrics: f_50,
      new_tasks_per_second: f_60,
      empty: f_70,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TaskListStatus");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.backlog_count_hint {
      o_prot.write_field_begin(&TFieldIdentifier::new("backlogCountHint", TType::I64, 10))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.read_level {
      o_prot.write_field_begin(&TFieldIdentifier::new("readLevel", TType::I64, 20))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.ack_level {
      o_prot.write_field_begin(&TFieldIdentifier::new("ackLevel", TType::I64, 30))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.rate_per_second {
      o_prot.write_field_begin(&TFieldIdentifier::new("ratePerSecond", TType::Double, 35))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.task_i_d_block {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskIDBlock", TType::Struct, 40))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.isolation_group_metrics {
      o_prot.write_field_begin(&TFieldIdentifier::new("isolationGroupMetrics", TType::Map, 50))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        v.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.new_tasks_per_second {
      o_prot.write_field_begin(&TFieldIdentifier::new("newTasksPerSecond", TType::Double, 60))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.empty {
      o_prot.write_field_begin(&TFieldIdentifier::new("empty", TType::Bool, 70))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TaskIDBlock
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TaskIDBlock {
  pub start_i_d: Option<i64>,
  pub end_i_d: Option<i64>,
}

impl TaskIDBlock {
  pub fn new<F10, F20>(start_i_d: F10, end_i_d: F20) -> TaskIDBlock where F10: Into<Option<i64>>, F20: Into<Option<i64>> {
    TaskIDBlock {
      start_i_d: start_i_d.into(),
      end_i_d: end_i_d.into(),
    }
  }
}

impl TSerializable for TaskIDBlock {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TaskIDBlock> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<i64> = None;
    let mut f_20: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_i64()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_i64()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TaskIDBlock {
      start_i_d: f_10,
      end_i_d: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TaskIDBlock");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.start_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("startID", TType::I64, 10))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.end_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("endID", TType::I64, 20))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DescribeHistoryHostRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DescribeHistoryHostRequest {
  pub host_address: Option<String>,
  pub shard_id_for_host: Option<i32>,
  pub execution_for_host: Option<WorkflowExecution>,
}

impl DescribeHistoryHostRequest {
  pub fn new<F10, F20, F30>(host_address: F10, shard_id_for_host: F20, execution_for_host: F30) -> DescribeHistoryHostRequest where F10: Into<Option<String>>, F20: Into<Option<i32>>, F30: Into<Option<WorkflowExecution>> {
    DescribeHistoryHostRequest {
      host_address: host_address.into(),
      shard_id_for_host: shard_id_for_host.into(),
      execution_for_host: execution_for_host.into(),
    }
  }
}

impl TSerializable for DescribeHistoryHostRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DescribeHistoryHostRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<i32> = None;
    let mut f_30: Option<WorkflowExecution> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_i32()?;
          f_20 = Some(val);
        },
        30 => {
          let val = WorkflowExecution::read_from_in_protocol(i_prot)?;
          f_30 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DescribeHistoryHostRequest {
      host_address: f_10,
      shard_id_for_host: f_20,
      execution_for_host: f_30,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DescribeHistoryHostRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.host_address {
      o_prot.write_field_begin(&TFieldIdentifier::new("hostAddress", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.shard_id_for_host {
      o_prot.write_field_begin(&TFieldIdentifier::new("shardIdForHost", TType::I32, 20))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.execution_for_host {
      o_prot.write_field_begin(&TFieldIdentifier::new("executionForHost", TType::Struct, 30))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// RemoveTaskRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RemoveTaskRequest {
  pub shard_i_d: Option<i32>,
  pub type_: Option<i32>,
  pub task_i_d: Option<i64>,
  pub visibility_timestamp: Option<i64>,
  pub cluster_name: Option<String>,
}

impl RemoveTaskRequest {
  pub fn new<F10, F20, F30, F40, F50>(shard_i_d: F10, type_: F20, task_i_d: F30, visibility_timestamp: F40, cluster_name: F50) -> RemoveTaskRequest where F10: Into<Option<i32>>, F20: Into<Option<i32>>, F30: Into<Option<i64>>, F40: Into<Option<i64>>, F50: Into<Option<String>> {
    RemoveTaskRequest {
      shard_i_d: shard_i_d.into(),
      type_: type_.into(),
      task_i_d: task_i_d.into(),
      visibility_timestamp: visibility_timestamp.into(),
      cluster_name: cluster_name.into(),
    }
  }
}

impl TSerializable for RemoveTaskRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RemoveTaskRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<i32> = None;
    let mut f_20: Option<i32> = None;
    let mut f_30: Option<i64> = None;
    let mut f_40: Option<i64> = None;
    let mut f_50: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_i32()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_i32()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_i64()?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_i64()?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_string()?;
          f_50 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RemoveTaskRequest {
      shard_i_d: f_10,
      type_: f_20,
      task_i_d: f_30,
      visibility_timestamp: f_40,
      cluster_name: f_50,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RemoveTaskRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.shard_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("shardID", TType::I32, 10))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.type_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 20))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.task_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskID", TType::I64, 30))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.visibility_timestamp {
      o_prot.write_field_begin(&TFieldIdentifier::new("visibilityTimestamp", TType::I64, 40))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cluster_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("clusterName", TType::String, 50))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// CloseShardRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CloseShardRequest {
  pub shard_i_d: Option<i32>,
}

impl CloseShardRequest {
  pub fn new<F10>(shard_i_d: F10) -> CloseShardRequest where F10: Into<Option<i32>> {
    CloseShardRequest {
      shard_i_d: shard_i_d.into(),
    }
  }
}

impl TSerializable for CloseShardRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CloseShardRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_i32()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CloseShardRequest {
      shard_i_d: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CloseShardRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.shard_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("shardID", TType::I32, 10))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ResetQueueRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ResetQueueRequest {
  pub shard_i_d: Option<i32>,
  pub cluster_name: Option<String>,
  pub type_: Option<i32>,
}

impl ResetQueueRequest {
  pub fn new<F10, F20, F30>(shard_i_d: F10, cluster_name: F20, type_: F30) -> ResetQueueRequest where F10: Into<Option<i32>>, F20: Into<Option<String>>, F30: Into<Option<i32>> {
    ResetQueueRequest {
      shard_i_d: shard_i_d.into(),
      cluster_name: cluster_name.into(),
      type_: type_.into(),
    }
  }
}

impl TSerializable for ResetQueueRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ResetQueueRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<i32> = None;
    let mut f_20: Option<String> = None;
    let mut f_30: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_i32()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_i32()?;
          f_30 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ResetQueueRequest {
      shard_i_d: f_10,
      cluster_name: f_20,
      type_: f_30,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ResetQueueRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.shard_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("shardID", TType::I32, 10))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cluster_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("clusterName", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.type_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 30))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DescribeQueueRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DescribeQueueRequest {
  pub shard_i_d: Option<i32>,
  pub cluster_name: Option<String>,
  pub type_: Option<i32>,
}

impl DescribeQueueRequest {
  pub fn new<F10, F20, F30>(shard_i_d: F10, cluster_name: F20, type_: F30) -> DescribeQueueRequest where F10: Into<Option<i32>>, F20: Into<Option<String>>, F30: Into<Option<i32>> {
    DescribeQueueRequest {
      shard_i_d: shard_i_d.into(),
      cluster_name: cluster_name.into(),
      type_: type_.into(),
    }
  }
}

impl TSerializable for DescribeQueueRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DescribeQueueRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<i32> = None;
    let mut f_20: Option<String> = None;
    let mut f_30: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_i32()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_i32()?;
          f_30 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DescribeQueueRequest {
      shard_i_d: f_10,
      cluster_name: f_20,
      type_: f_30,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DescribeQueueRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.shard_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("shardID", TType::I32, 10))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cluster_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("clusterName", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.type_ {
      o_prot.write_field_begin(&TFieldIdentifier::new("type", TType::I32, 30))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DescribeQueueResponse
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DescribeQueueResponse {
  pub processing_queue_states: Option<Vec<String>>,
}

impl DescribeQueueResponse {
  pub fn new<F10>(processing_queue_states: F10) -> DescribeQueueResponse where F10: Into<Option<Vec<String>>> {
    DescribeQueueResponse {
      processing_queue_states: processing_queue_states.into(),
    }
  }
}

impl TSerializable for DescribeQueueResponse {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DescribeQueueResponse> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_61 = i_prot.read_string()?;
            val.push(list_elem_61);
          }
          i_prot.read_list_end()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DescribeQueueResponse {
      processing_queue_states: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DescribeQueueResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.processing_queue_states {
      o_prot.write_field_begin(&TFieldIdentifier::new("processingQueueStates", TType::List, 10))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DescribeShardDistributionRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DescribeShardDistributionRequest {
  pub page_size: Option<i32>,
  pub page_i_d: Option<i32>,
}

impl DescribeShardDistributionRequest {
  pub fn new<F10, F20>(page_size: F10, page_i_d: F20) -> DescribeShardDistributionRequest where F10: Into<Option<i32>>, F20: Into<Option<i32>> {
    DescribeShardDistributionRequest {
      page_size: page_size.into(),
      page_i_d: page_i_d.into(),
    }
  }
}

impl TSerializable for DescribeShardDistributionRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DescribeShardDistributionRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<i32> = None;
    let mut f_20: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_i32()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_i32()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DescribeShardDistributionRequest {
      page_size: f_10,
      page_i_d: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DescribeShardDistributionRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.page_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("pageSize", TType::I32, 10))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.page_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("pageID", TType::I32, 20))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DescribeShardDistributionResponse
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DescribeShardDistributionResponse {
  pub number_of_shards: Option<i32>,
  pub shards: Option<BTreeMap<i32, String>>,
}

impl DescribeShardDistributionResponse {
  pub fn new<F10, F20>(number_of_shards: F10, shards: F20) -> DescribeShardDistributionResponse where F10: Into<Option<i32>>, F20: Into<Option<BTreeMap<i32, String>>> {
    DescribeShardDistributionResponse {
      number_of_shards: number_of_shards.into(),
      shards: shards.into(),
    }
  }
}

impl TSerializable for DescribeShardDistributionResponse {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DescribeShardDistributionResponse> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<i32> = None;
    let mut f_20: Option<BTreeMap<i32, String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_i32()?;
          f_10 = Some(val);
        },
        20 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<i32, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_62 = i_prot.read_i32()?;
            let map_val_63 = i_prot.read_string()?;
            val.insert(map_key_62, map_val_63);
          }
          i_prot.read_map_end()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DescribeShardDistributionResponse {
      number_of_shards: f_10,
      shards: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DescribeShardDistributionResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.number_of_shards {
      o_prot.write_field_begin(&TFieldIdentifier::new("numberOfShards", TType::I32, 10))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.shards {
      o_prot.write_field_begin(&TFieldIdentifier::new("shards", TType::Map, 20))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::I32, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_i32(*k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DescribeHistoryHostResponse
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DescribeHistoryHostResponse {
  pub number_of_shards: Option<i32>,
  pub shard_i_ds: Option<Vec<i32>>,
  pub domain_cache: Option<Box<DomainCacheInfo>>,
  pub shard_controller_status: Option<String>,
  pub address: Option<String>,
}

impl DescribeHistoryHostResponse {
  pub fn new<F10, F20, F30, F40, F50>(number_of_shards: F10, shard_i_ds: F20, domain_cache: F30, shard_controller_status: F40, address: F50) -> DescribeHistoryHostResponse where F10: Into<Option<i32>>, F20: Into<Option<Vec<i32>>>, F30: Into<Option<Box<DomainCacheInfo>>>, F40: Into<Option<String>>, F50: Into<Option<String>> {
    DescribeHistoryHostResponse {
      number_of_shards: number_of_shards.into(),
      shard_i_ds: shard_i_ds.into(),
      domain_cache: domain_cache.into(),
      shard_controller_status: shard_controller_status.into(),
      address: address.into(),
    }
  }
}

impl TSerializable for DescribeHistoryHostResponse {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DescribeHistoryHostResponse> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<i32> = None;
    let mut f_20: Option<Vec<i32>> = None;
    let mut f_30: Option<Box<DomainCacheInfo>> = None;
    let mut f_40: Option<String> = None;
    let mut f_50: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_i32()?;
          f_10 = Some(val);
        },
        20 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_64 = i_prot.read_i32()?;
            val.push(list_elem_64);
          }
          i_prot.read_list_end()?;
          f_20 = Some(val);
        },
        30 => {
          let val = Box::new(DomainCacheInfo::read_from_in_protocol(i_prot)?);
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_string()?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_string()?;
          f_50 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DescribeHistoryHostResponse {
      number_of_shards: f_10,
      shard_i_ds: f_20,
      domain_cache: f_30,
      shard_controller_status: f_40,
      address: f_50,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DescribeHistoryHostResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.number_of_shards {
      o_prot.write_field_begin(&TFieldIdentifier::new("numberOfShards", TType::I32, 10))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.shard_i_ds {
      o_prot.write_field_begin(&TFieldIdentifier::new("shardIDs", TType::List, 20))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i32(*e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.domain_cache {
      o_prot.write_field_begin(&TFieldIdentifier::new("domainCache", TType::Struct, 30))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.shard_controller_status {
      o_prot.write_field_begin(&TFieldIdentifier::new("shardControllerStatus", TType::String, 40))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.address {
      o_prot.write_field_begin(&TFieldIdentifier::new("address", TType::String, 50))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DomainCacheInfo
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DomainCacheInfo {
  pub num_of_items_in_cache_by_i_d: Option<i64>,
  pub num_of_items_in_cache_by_name: Option<i64>,
}

impl DomainCacheInfo {
  pub fn new<F10, F20>(num_of_items_in_cache_by_i_d: F10, num_of_items_in_cache_by_name: F20) -> DomainCacheInfo where F10: Into<Option<i64>>, F20: Into<Option<i64>> {
    DomainCacheInfo {
      num_of_items_in_cache_by_i_d: num_of_items_in_cache_by_i_d.into(),
      num_of_items_in_cache_by_name: num_of_items_in_cache_by_name.into(),
    }
  }
}

impl TSerializable for DomainCacheInfo {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DomainCacheInfo> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<i64> = None;
    let mut f_20: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_i64()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_i64()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DomainCacheInfo {
      num_of_items_in_cache_by_i_d: f_10,
      num_of_items_in_cache_by_name: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DomainCacheInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.num_of_items_in_cache_by_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("numOfItemsInCacheByID", TType::I64, 10))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.num_of_items_in_cache_by_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("numOfItemsInCacheByName", TType::I64, 20))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// PollerInfo
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PollerInfo {
  pub last_access_time: Option<i64>,
  pub identity: Option<String>,
  pub rate_per_second: Option<OrderedFloat<f64>>,
}

impl PollerInfo {
  pub fn new<F10, F20, F30>(last_access_time: F10, identity: F20, rate_per_second: F30) -> PollerInfo where F10: Into<Option<i64>>, F20: Into<Option<String>>, F30: Into<Option<OrderedFloat<f64>>> {
    PollerInfo {
      last_access_time: last_access_time.into(),
      identity: identity.into(),
      rate_per_second: rate_per_second.into(),
    }
  }
}

impl TSerializable for PollerInfo {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PollerInfo> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<i64> = None;
    let mut f_20: Option<String> = None;
    let mut f_30: Option<OrderedFloat<f64>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_i64()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        30 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_30 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = PollerInfo {
      last_access_time: f_10,
      identity: f_20,
      rate_per_second: f_30,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PollerInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.last_access_time {
      o_prot.write_field_begin(&TFieldIdentifier::new("lastAccessTime", TType::I64, 10))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.identity {
      o_prot.write_field_begin(&TFieldIdentifier::new("identity", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.rate_per_second {
      o_prot.write_field_begin(&TFieldIdentifier::new("ratePerSecond", TType::Double, 30))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// RetryPolicy
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RetryPolicy {
  pub initial_interval_in_seconds: Option<i32>,
  pub backoff_coefficient: Option<OrderedFloat<f64>>,
  pub maximum_interval_in_seconds: Option<i32>,
  pub maximum_attempts: Option<i32>,
  pub non_retriable_error_reasons: Option<Vec<String>>,
  pub expiration_interval_in_seconds: Option<i32>,
}

impl RetryPolicy {
  pub fn new<F10, F20, F30, F40, F50, F60>(initial_interval_in_seconds: F10, backoff_coefficient: F20, maximum_interval_in_seconds: F30, maximum_attempts: F40, non_retriable_error_reasons: F50, expiration_interval_in_seconds: F60) -> RetryPolicy where F10: Into<Option<i32>>, F20: Into<Option<OrderedFloat<f64>>>, F30: Into<Option<i32>>, F40: Into<Option<i32>>, F50: Into<Option<Vec<String>>>, F60: Into<Option<i32>> {
    RetryPolicy {
      initial_interval_in_seconds: initial_interval_in_seconds.into(),
      backoff_coefficient: backoff_coefficient.into(),
      maximum_interval_in_seconds: maximum_interval_in_seconds.into(),
      maximum_attempts: maximum_attempts.into(),
      non_retriable_error_reasons: non_retriable_error_reasons.into(),
      expiration_interval_in_seconds: expiration_interval_in_seconds.into(),
    }
  }
}

impl TSerializable for RetryPolicy {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RetryPolicy> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<i32> = None;
    let mut f_20: Option<OrderedFloat<f64>> = None;
    let mut f_30: Option<i32> = None;
    let mut f_40: Option<i32> = None;
    let mut f_50: Option<Vec<String>> = None;
    let mut f_60: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_i32()?;
          f_10 = Some(val);
        },
        20 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_i32()?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_i32()?;
          f_40 = Some(val);
        },
        50 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_65 = i_prot.read_string()?;
            val.push(list_elem_65);
          }
          i_prot.read_list_end()?;
          f_50 = Some(val);
        },
        60 => {
          let val = i_prot.read_i32()?;
          f_60 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RetryPolicy {
      initial_interval_in_seconds: f_10,
      backoff_coefficient: f_20,
      maximum_interval_in_seconds: f_30,
      maximum_attempts: f_40,
      non_retriable_error_reasons: f_50,
      expiration_interval_in_seconds: f_60,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RetryPolicy");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.initial_interval_in_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("initialIntervalInSeconds", TType::I32, 10))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.backoff_coefficient {
      o_prot.write_field_begin(&TFieldIdentifier::new("backoffCoefficient", TType::Double, 20))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.maximum_interval_in_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("maximumIntervalInSeconds", TType::I32, 30))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.maximum_attempts {
      o_prot.write_field_begin(&TFieldIdentifier::new("maximumAttempts", TType::I32, 40))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.non_retriable_error_reasons {
      o_prot.write_field_begin(&TFieldIdentifier::new("nonRetriableErrorReasons", TType::List, 50))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.expiration_interval_in_seconds {
      o_prot.write_field_begin(&TFieldIdentifier::new("expirationIntervalInSeconds", TType::I32, 60))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HistoryBranchRange
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct HistoryBranchRange {
  pub branch_i_d: Option<String>,
  pub begin_node_i_d: Option<i64>,
  pub end_node_i_d: Option<i64>,
}

impl HistoryBranchRange {
  pub fn new<F10, F20, F30>(branch_i_d: F10, begin_node_i_d: F20, end_node_i_d: F30) -> HistoryBranchRange where F10: Into<Option<String>>, F20: Into<Option<i64>>, F30: Into<Option<i64>> {
    HistoryBranchRange {
      branch_i_d: branch_i_d.into(),
      begin_node_i_d: begin_node_i_d.into(),
      end_node_i_d: end_node_i_d.into(),
    }
  }
}

impl TSerializable for HistoryBranchRange {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HistoryBranchRange> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<i64> = None;
    let mut f_30: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_i64()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_i64()?;
          f_30 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HistoryBranchRange {
      branch_i_d: f_10,
      begin_node_i_d: f_20,
      end_node_i_d: f_30,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HistoryBranchRange");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.branch_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("branchID", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.begin_node_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("beginNodeID", TType::I64, 20))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.end_node_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("endNodeID", TType::I64, 30))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// HistoryBranch
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct HistoryBranch {
  pub tree_i_d: Option<String>,
  pub branch_i_d: Option<String>,
  pub ancestors: Option<Vec<HistoryBranchRange>>,
}

impl HistoryBranch {
  pub fn new<F10, F20, F30>(tree_i_d: F10, branch_i_d: F20, ancestors: F30) -> HistoryBranch where F10: Into<Option<String>>, F20: Into<Option<String>>, F30: Into<Option<Vec<HistoryBranchRange>>> {
    HistoryBranch {
      tree_i_d: tree_i_d.into(),
      branch_i_d: branch_i_d.into(),
      ancestors: ancestors.into(),
    }
  }
}

impl TSerializable for HistoryBranch {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<HistoryBranch> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<String> = None;
    let mut f_30: Option<Vec<HistoryBranchRange>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        30 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<HistoryBranchRange> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_66 = HistoryBranchRange::read_from_in_protocol(i_prot)?;
            val.push(list_elem_66);
          }
          i_prot.read_list_end()?;
          f_30 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = HistoryBranch {
      tree_i_d: f_10,
      branch_i_d: f_20,
      ancestors: f_30,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("HistoryBranch");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.tree_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("treeID", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.branch_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("branchID", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.ancestors {
      o_prot.write_field_begin(&TFieldIdentifier::new("ancestors", TType::List, 30))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// VersionHistoryItem
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct VersionHistoryItem {
  pub event_i_d: Option<i64>,
  pub version: Option<i64>,
}

impl VersionHistoryItem {
  pub fn new<F10, F20>(event_i_d: F10, version: F20) -> VersionHistoryItem where F10: Into<Option<i64>>, F20: Into<Option<i64>> {
    VersionHistoryItem {
      event_i_d: event_i_d.into(),
      version: version.into(),
    }
  }
}

impl TSerializable for VersionHistoryItem {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<VersionHistoryItem> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<i64> = None;
    let mut f_20: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_i64()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_i64()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = VersionHistoryItem {
      event_i_d: f_10,
      version: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("VersionHistoryItem");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.event_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("eventID", TType::I64, 10))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.version {
      o_prot.write_field_begin(&TFieldIdentifier::new("version", TType::I64, 20))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// VersionHistory
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct VersionHistory {
  pub branch_token: Option<Vec<u8>>,
  pub items: Option<Vec<VersionHistoryItem>>,
}

impl VersionHistory {
  pub fn new<F10, F20>(branch_token: F10, items: F20) -> VersionHistory where F10: Into<Option<Vec<u8>>>, F20: Into<Option<Vec<VersionHistoryItem>>> {
    VersionHistory {
      branch_token: branch_token.into(),
      items: items.into(),
    }
  }
}

impl TSerializable for VersionHistory {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<VersionHistory> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<Vec<u8>> = None;
    let mut f_20: Option<Vec<VersionHistoryItem>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_bytes()?;
          f_10 = Some(val);
        },
        20 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<VersionHistoryItem> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_67 = VersionHistoryItem::read_from_in_protocol(i_prot)?;
            val.push(list_elem_67);
          }
          i_prot.read_list_end()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = VersionHistory {
      branch_token: f_10,
      items: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("VersionHistory");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.branch_token {
      o_prot.write_field_begin(&TFieldIdentifier::new("branchToken", TType::String, 10))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.items {
      o_prot.write_field_begin(&TFieldIdentifier::new("items", TType::List, 20))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// VersionHistories
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct VersionHistories {
  pub current_version_history_index: Option<i32>,
  pub histories: Option<Vec<VersionHistory>>,
}

impl VersionHistories {
  pub fn new<F10, F20>(current_version_history_index: F10, histories: F20) -> VersionHistories where F10: Into<Option<i32>>, F20: Into<Option<Vec<VersionHistory>>> {
    VersionHistories {
      current_version_history_index: current_version_history_index.into(),
      histories: histories.into(),
    }
  }
}

impl TSerializable for VersionHistories {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<VersionHistories> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<i32> = None;
    let mut f_20: Option<Vec<VersionHistory>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_i32()?;
          f_10 = Some(val);
        },
        20 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<VersionHistory> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_68 = VersionHistory::read_from_in_protocol(i_prot)?;
            val.push(list_elem_68);
          }
          i_prot.read_list_end()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = VersionHistories {
      current_version_history_index: f_10,
      histories: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("VersionHistories");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.current_version_history_index {
      o_prot.write_field_begin(&TFieldIdentifier::new("currentVersionHistoryIndex", TType::I32, 10))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.histories {
      o_prot.write_field_begin(&TFieldIdentifier::new("histories", TType::List, 20))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ReapplyEventsRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ReapplyEventsRequest {
  pub domain_name: Option<String>,
  pub workflow_execution: Option<WorkflowExecution>,
  pub events: Option<DataBlob>,
}

impl ReapplyEventsRequest {
  pub fn new<F10, F20, F30>(domain_name: F10, workflow_execution: F20, events: F30) -> ReapplyEventsRequest where F10: Into<Option<String>>, F20: Into<Option<WorkflowExecution>>, F30: Into<Option<DataBlob>> {
    ReapplyEventsRequest {
      domain_name: domain_name.into(),
      workflow_execution: workflow_execution.into(),
      events: events.into(),
    }
  }
}

impl TSerializable for ReapplyEventsRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ReapplyEventsRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<WorkflowExecution> = None;
    let mut f_30: Option<DataBlob> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = WorkflowExecution::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        30 => {
          let val = DataBlob::read_from_in_protocol(i_prot)?;
          f_30 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ReapplyEventsRequest {
      domain_name: f_10,
      workflow_execution: f_20,
      events: f_30,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ReapplyEventsRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.domain_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("domainName", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_execution {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowExecution", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.events {
      o_prot.write_field_begin(&TFieldIdentifier::new("events", TType::Struct, 30))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SupportedClientVersions
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SupportedClientVersions {
  pub go_sdk: Option<String>,
  pub java_sdk: Option<String>,
}

impl SupportedClientVersions {
  pub fn new<F10, F20>(go_sdk: F10, java_sdk: F20) -> SupportedClientVersions where F10: Into<Option<String>>, F20: Into<Option<String>> {
    SupportedClientVersions {
      go_sdk: go_sdk.into(),
      java_sdk: java_sdk.into(),
    }
  }
}

impl TSerializable for SupportedClientVersions {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SupportedClientVersions> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SupportedClientVersions {
      go_sdk: f_10,
      java_sdk: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SupportedClientVersions");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.go_sdk {
      o_prot.write_field_begin(&TFieldIdentifier::new("goSdk", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.java_sdk {
      o_prot.write_field_begin(&TFieldIdentifier::new("javaSdk", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ClusterInfo
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ClusterInfo {
  pub supported_client_versions: Option<SupportedClientVersions>,
}

impl ClusterInfo {
  pub fn new<F10>(supported_client_versions: F10) -> ClusterInfo where F10: Into<Option<SupportedClientVersions>> {
    ClusterInfo {
      supported_client_versions: supported_client_versions.into(),
    }
  }
}

impl TSerializable for ClusterInfo {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ClusterInfo> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<SupportedClientVersions> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = SupportedClientVersions::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ClusterInfo {
      supported_client_versions: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ClusterInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.supported_client_versions {
      o_prot.write_field_begin(&TFieldIdentifier::new("supportedClientVersions", TType::Struct, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// RefreshWorkflowTasksRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RefreshWorkflowTasksRequest {
  pub domain: Option<String>,
  pub execution: Option<WorkflowExecution>,
}

impl RefreshWorkflowTasksRequest {
  pub fn new<F10, F20>(domain: F10, execution: F20) -> RefreshWorkflowTasksRequest where F10: Into<Option<String>>, F20: Into<Option<WorkflowExecution>> {
    RefreshWorkflowTasksRequest {
      domain: domain.into(),
      execution: execution.into(),
    }
  }
}

impl TSerializable for RefreshWorkflowTasksRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RefreshWorkflowTasksRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<WorkflowExecution> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = WorkflowExecution::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RefreshWorkflowTasksRequest {
      domain: f_10,
      execution: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RefreshWorkflowTasksRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.domain {
      o_prot.write_field_begin(&TFieldIdentifier::new("domain", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.execution {
      o_prot.write_field_begin(&TFieldIdentifier::new("execution", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// FeatureFlags
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct FeatureFlags {
  pub workflow_execution_already_completed_error_enabled: Option<bool>,
}

impl FeatureFlags {
  pub fn new<F10>(workflow_execution_already_completed_error_enabled: F10) -> FeatureFlags where F10: Into<Option<bool>> {
    FeatureFlags {
      workflow_execution_already_completed_error_enabled: workflow_execution_already_completed_error_enabled.into(),
    }
  }
}

impl TSerializable for FeatureFlags {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<FeatureFlags> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_bool()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = FeatureFlags {
      workflow_execution_already_completed_error_enabled: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("FeatureFlags");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.workflow_execution_already_completed_error_enabled {
      o_prot.write_field_begin(&TFieldIdentifier::new("WorkflowExecutionAlreadyCompletedErrorEnabled", TType::Bool, 10))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// CrossClusterTaskInfo
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CrossClusterTaskInfo {
  pub domain_i_d: Option<String>,
  pub workflow_i_d: Option<String>,
  pub run_i_d: Option<String>,
  pub task_type: Option<CrossClusterTaskType>,
  pub task_state: Option<i16>,
  pub task_i_d: Option<i64>,
  pub visibility_timestamp: Option<i64>,
}

impl CrossClusterTaskInfo {
  pub fn new<F10, F20, F30, F40, F50, F60, F70>(domain_i_d: F10, workflow_i_d: F20, run_i_d: F30, task_type: F40, task_state: F50, task_i_d: F60, visibility_timestamp: F70) -> CrossClusterTaskInfo where F10: Into<Option<String>>, F20: Into<Option<String>>, F30: Into<Option<String>>, F40: Into<Option<CrossClusterTaskType>>, F50: Into<Option<i16>>, F60: Into<Option<i64>>, F70: Into<Option<i64>> {
    CrossClusterTaskInfo {
      domain_i_d: domain_i_d.into(),
      workflow_i_d: workflow_i_d.into(),
      run_i_d: run_i_d.into(),
      task_type: task_type.into(),
      task_state: task_state.into(),
      task_i_d: task_i_d.into(),
      visibility_timestamp: visibility_timestamp.into(),
    }
  }
}

impl TSerializable for CrossClusterTaskInfo {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CrossClusterTaskInfo> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<String> = None;
    let mut f_30: Option<String> = None;
    let mut f_40: Option<CrossClusterTaskType> = None;
    let mut f_50: Option<i16> = None;
    let mut f_60: Option<i64> = None;
    let mut f_70: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_string()?;
          f_30 = Some(val);
        },
        40 => {
          let val = CrossClusterTaskType::read_from_in_protocol(i_prot)?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_i16()?;
          f_50 = Some(val);
        },
        60 => {
          let val = i_prot.read_i64()?;
          f_60 = Some(val);
        },
        70 => {
          let val = i_prot.read_i64()?;
          f_70 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CrossClusterTaskInfo {
      domain_i_d: f_10,
      workflow_i_d: f_20,
      run_i_d: f_30,
      task_type: f_40,
      task_state: f_50,
      task_i_d: f_60,
      visibility_timestamp: f_70,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CrossClusterTaskInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.domain_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("domainID", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.workflow_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("workflowID", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.run_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("runID", TType::String, 30))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.task_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskType", TType::I32, 40))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.task_state {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskState", TType::I16, 50))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.task_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskID", TType::I64, 60))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.visibility_timestamp {
      o_prot.write_field_begin(&TFieldIdentifier::new("visibilityTimestamp", TType::I64, 70))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// CrossClusterStartChildExecutionRequestAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CrossClusterStartChildExecutionRequestAttributes {
  pub target_domain_i_d: Option<String>,
  pub request_i_d: Option<String>,
  pub initiated_event_i_d: Option<i64>,
  pub initiated_event_attributes: Option<StartChildWorkflowExecutionInitiatedEventAttributes>,
  pub target_run_i_d: Option<String>,
  pub partition_config: Option<BTreeMap<String, String>>,
}

impl CrossClusterStartChildExecutionRequestAttributes {
  pub fn new<F10, F20, F30, F40, F50, F60>(target_domain_i_d: F10, request_i_d: F20, initiated_event_i_d: F30, initiated_event_attributes: F40, target_run_i_d: F50, partition_config: F60) -> CrossClusterStartChildExecutionRequestAttributes where F10: Into<Option<String>>, F20: Into<Option<String>>, F30: Into<Option<i64>>, F40: Into<Option<StartChildWorkflowExecutionInitiatedEventAttributes>>, F50: Into<Option<String>>, F60: Into<Option<BTreeMap<String, String>>> {
    CrossClusterStartChildExecutionRequestAttributes {
      target_domain_i_d: target_domain_i_d.into(),
      request_i_d: request_i_d.into(),
      initiated_event_i_d: initiated_event_i_d.into(),
      initiated_event_attributes: initiated_event_attributes.into(),
      target_run_i_d: target_run_i_d.into(),
      partition_config: partition_config.into(),
    }
  }
}

impl TSerializable for CrossClusterStartChildExecutionRequestAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CrossClusterStartChildExecutionRequestAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<String> = None;
    let mut f_30: Option<i64> = None;
    let mut f_40: Option<StartChildWorkflowExecutionInitiatedEventAttributes> = None;
    let mut f_50: Option<String> = None;
    let mut f_60: Option<BTreeMap<String, String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_i64()?;
          f_30 = Some(val);
        },
        40 => {
          let val = StartChildWorkflowExecutionInitiatedEventAttributes::read_from_in_protocol(i_prot)?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_string()?;
          f_50 = Some(val);
        },
        60 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_69 = i_prot.read_string()?;
            let map_val_70 = i_prot.read_string()?;
            val.insert(map_key_69, map_val_70);
          }
          i_prot.read_map_end()?;
          f_60 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CrossClusterStartChildExecutionRequestAttributes {
      target_domain_i_d: f_10,
      request_i_d: f_20,
      initiated_event_i_d: f_30,
      initiated_event_attributes: f_40,
      target_run_i_d: f_50,
      partition_config: f_60,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CrossClusterStartChildExecutionRequestAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.target_domain_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("targetDomainID", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.request_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("requestID", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.initiated_event_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("initiatedEventID", TType::I64, 30))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.initiated_event_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("initiatedEventAttributes", TType::Struct, 40))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.target_run_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("targetRunID", TType::String, 50))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.partition_config {
      o_prot.write_field_begin(&TFieldIdentifier::new("partitionConfig", TType::Map, 60))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_string(v)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// CrossClusterStartChildExecutionResponseAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CrossClusterStartChildExecutionResponseAttributes {
  pub run_i_d: Option<String>,
}

impl CrossClusterStartChildExecutionResponseAttributes {
  pub fn new<F10>(run_i_d: F10) -> CrossClusterStartChildExecutionResponseAttributes where F10: Into<Option<String>> {
    CrossClusterStartChildExecutionResponseAttributes {
      run_i_d: run_i_d.into(),
    }
  }
}

impl TSerializable for CrossClusterStartChildExecutionResponseAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CrossClusterStartChildExecutionResponseAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CrossClusterStartChildExecutionResponseAttributes {
      run_i_d: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CrossClusterStartChildExecutionResponseAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.run_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("runID", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// CrossClusterCancelExecutionRequestAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CrossClusterCancelExecutionRequestAttributes {
  pub target_domain_i_d: Option<String>,
  pub target_workflow_i_d: Option<String>,
  pub target_run_i_d: Option<String>,
  pub request_i_d: Option<String>,
  pub initiated_event_i_d: Option<i64>,
  pub child_workflow_only: Option<bool>,
}

impl CrossClusterCancelExecutionRequestAttributes {
  pub fn new<F10, F20, F30, F40, F50, F60>(target_domain_i_d: F10, target_workflow_i_d: F20, target_run_i_d: F30, request_i_d: F40, initiated_event_i_d: F50, child_workflow_only: F60) -> CrossClusterCancelExecutionRequestAttributes where F10: Into<Option<String>>, F20: Into<Option<String>>, F30: Into<Option<String>>, F40: Into<Option<String>>, F50: Into<Option<i64>>, F60: Into<Option<bool>> {
    CrossClusterCancelExecutionRequestAttributes {
      target_domain_i_d: target_domain_i_d.into(),
      target_workflow_i_d: target_workflow_i_d.into(),
      target_run_i_d: target_run_i_d.into(),
      request_i_d: request_i_d.into(),
      initiated_event_i_d: initiated_event_i_d.into(),
      child_workflow_only: child_workflow_only.into(),
    }
  }
}

impl TSerializable for CrossClusterCancelExecutionRequestAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CrossClusterCancelExecutionRequestAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<String> = None;
    let mut f_30: Option<String> = None;
    let mut f_40: Option<String> = None;
    let mut f_50: Option<i64> = None;
    let mut f_60: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_string()?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_string()?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_i64()?;
          f_50 = Some(val);
        },
        60 => {
          let val = i_prot.read_bool()?;
          f_60 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CrossClusterCancelExecutionRequestAttributes {
      target_domain_i_d: f_10,
      target_workflow_i_d: f_20,
      target_run_i_d: f_30,
      request_i_d: f_40,
      initiated_event_i_d: f_50,
      child_workflow_only: f_60,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CrossClusterCancelExecutionRequestAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.target_domain_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("targetDomainID", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.target_workflow_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("targetWorkflowID", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.target_run_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("targetRunID", TType::String, 30))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.request_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("requestID", TType::String, 40))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.initiated_event_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("initiatedEventID", TType::I64, 50))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.child_workflow_only {
      o_prot.write_field_begin(&TFieldIdentifier::new("childWorkflowOnly", TType::Bool, 60))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// CrossClusterCancelExecutionResponseAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CrossClusterCancelExecutionResponseAttributes {
}

impl CrossClusterCancelExecutionResponseAttributes {
  pub fn new() -> CrossClusterCancelExecutionResponseAttributes {
    CrossClusterCancelExecutionResponseAttributes {}
  }
}

impl TSerializable for CrossClusterCancelExecutionResponseAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CrossClusterCancelExecutionResponseAttributes> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      i_prot.skip(field_ident.field_type)?;
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CrossClusterCancelExecutionResponseAttributes {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CrossClusterCancelExecutionResponseAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// CrossClusterSignalExecutionRequestAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CrossClusterSignalExecutionRequestAttributes {
  pub target_domain_i_d: Option<String>,
  pub target_workflow_i_d: Option<String>,
  pub target_run_i_d: Option<String>,
  pub request_i_d: Option<String>,
  pub initiated_event_i_d: Option<i64>,
  pub child_workflow_only: Option<bool>,
  pub signal_name: Option<String>,
  pub signal_input: Option<Vec<u8>>,
  pub control: Option<Vec<u8>>,
}

impl CrossClusterSignalExecutionRequestAttributes {
  pub fn new<F10, F20, F30, F40, F50, F60, F70, F80, F90>(target_domain_i_d: F10, target_workflow_i_d: F20, target_run_i_d: F30, request_i_d: F40, initiated_event_i_d: F50, child_workflow_only: F60, signal_name: F70, signal_input: F80, control: F90) -> CrossClusterSignalExecutionRequestAttributes where F10: Into<Option<String>>, F20: Into<Option<String>>, F30: Into<Option<String>>, F40: Into<Option<String>>, F50: Into<Option<i64>>, F60: Into<Option<bool>>, F70: Into<Option<String>>, F80: Into<Option<Vec<u8>>>, F90: Into<Option<Vec<u8>>> {
    CrossClusterSignalExecutionRequestAttributes {
      target_domain_i_d: target_domain_i_d.into(),
      target_workflow_i_d: target_workflow_i_d.into(),
      target_run_i_d: target_run_i_d.into(),
      request_i_d: request_i_d.into(),
      initiated_event_i_d: initiated_event_i_d.into(),
      child_workflow_only: child_workflow_only.into(),
      signal_name: signal_name.into(),
      signal_input: signal_input.into(),
      control: control.into(),
    }
  }
}

impl TSerializable for CrossClusterSignalExecutionRequestAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CrossClusterSignalExecutionRequestAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<String> = None;
    let mut f_30: Option<String> = None;
    let mut f_40: Option<String> = None;
    let mut f_50: Option<i64> = None;
    let mut f_60: Option<bool> = None;
    let mut f_70: Option<String> = None;
    let mut f_80: Option<Vec<u8>> = None;
    let mut f_90: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_string()?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_string()?;
          f_40 = Some(val);
        },
        50 => {
          let val = i_prot.read_i64()?;
          f_50 = Some(val);
        },
        60 => {
          let val = i_prot.read_bool()?;
          f_60 = Some(val);
        },
        70 => {
          let val = i_prot.read_string()?;
          f_70 = Some(val);
        },
        80 => {
          let val = i_prot.read_bytes()?;
          f_80 = Some(val);
        },
        90 => {
          let val = i_prot.read_bytes()?;
          f_90 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CrossClusterSignalExecutionRequestAttributes {
      target_domain_i_d: f_10,
      target_workflow_i_d: f_20,
      target_run_i_d: f_30,
      request_i_d: f_40,
      initiated_event_i_d: f_50,
      child_workflow_only: f_60,
      signal_name: f_70,
      signal_input: f_80,
      control: f_90,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CrossClusterSignalExecutionRequestAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.target_domain_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("targetDomainID", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.target_workflow_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("targetWorkflowID", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.target_run_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("targetRunID", TType::String, 30))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.request_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("requestID", TType::String, 40))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.initiated_event_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("initiatedEventID", TType::I64, 50))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.child_workflow_only {
      o_prot.write_field_begin(&TFieldIdentifier::new("childWorkflowOnly", TType::Bool, 60))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.signal_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("signalName", TType::String, 70))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.signal_input {
      o_prot.write_field_begin(&TFieldIdentifier::new("signalInput", TType::String, 80))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.control {
      o_prot.write_field_begin(&TFieldIdentifier::new("control", TType::String, 90))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// CrossClusterSignalExecutionResponseAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CrossClusterSignalExecutionResponseAttributes {
}

impl CrossClusterSignalExecutionResponseAttributes {
  pub fn new() -> CrossClusterSignalExecutionResponseAttributes {
    CrossClusterSignalExecutionResponseAttributes {}
  }
}

impl TSerializable for CrossClusterSignalExecutionResponseAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CrossClusterSignalExecutionResponseAttributes> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      i_prot.skip(field_ident.field_type)?;
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CrossClusterSignalExecutionResponseAttributes {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CrossClusterSignalExecutionResponseAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// CrossClusterRecordChildWorkflowExecutionCompleteRequestAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CrossClusterRecordChildWorkflowExecutionCompleteRequestAttributes {
  pub target_domain_i_d: Option<String>,
  pub target_workflow_i_d: Option<String>,
  pub target_run_i_d: Option<String>,
  pub initiated_event_i_d: Option<i64>,
  pub completion_event: Option<HistoryEvent>,
}

impl CrossClusterRecordChildWorkflowExecutionCompleteRequestAttributes {
  pub fn new<F10, F20, F30, F40, F50>(target_domain_i_d: F10, target_workflow_i_d: F20, target_run_i_d: F30, initiated_event_i_d: F40, completion_event: F50) -> CrossClusterRecordChildWorkflowExecutionCompleteRequestAttributes where F10: Into<Option<String>>, F20: Into<Option<String>>, F30: Into<Option<String>>, F40: Into<Option<i64>>, F50: Into<Option<HistoryEvent>> {
    CrossClusterRecordChildWorkflowExecutionCompleteRequestAttributes {
      target_domain_i_d: target_domain_i_d.into(),
      target_workflow_i_d: target_workflow_i_d.into(),
      target_run_i_d: target_run_i_d.into(),
      initiated_event_i_d: initiated_event_i_d.into(),
      completion_event: completion_event.into(),
    }
  }
}

impl TSerializable for CrossClusterRecordChildWorkflowExecutionCompleteRequestAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CrossClusterRecordChildWorkflowExecutionCompleteRequestAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<String> = None;
    let mut f_30: Option<String> = None;
    let mut f_40: Option<i64> = None;
    let mut f_50: Option<HistoryEvent> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_string()?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_i64()?;
          f_40 = Some(val);
        },
        50 => {
          let val = HistoryEvent::read_from_in_protocol(i_prot)?;
          f_50 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CrossClusterRecordChildWorkflowExecutionCompleteRequestAttributes {
      target_domain_i_d: f_10,
      target_workflow_i_d: f_20,
      target_run_i_d: f_30,
      initiated_event_i_d: f_40,
      completion_event: f_50,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CrossClusterRecordChildWorkflowExecutionCompleteRequestAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.target_domain_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("targetDomainID", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.target_workflow_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("targetWorkflowID", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.target_run_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("targetRunID", TType::String, 30))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.initiated_event_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("initiatedEventID", TType::I64, 40))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.completion_event {
      o_prot.write_field_begin(&TFieldIdentifier::new("completionEvent", TType::Struct, 50))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// CrossClusterRecordChildWorkflowExecutionCompleteResponseAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CrossClusterRecordChildWorkflowExecutionCompleteResponseAttributes {
}

impl CrossClusterRecordChildWorkflowExecutionCompleteResponseAttributes {
  pub fn new() -> CrossClusterRecordChildWorkflowExecutionCompleteResponseAttributes {
    CrossClusterRecordChildWorkflowExecutionCompleteResponseAttributes {}
  }
}

impl TSerializable for CrossClusterRecordChildWorkflowExecutionCompleteResponseAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CrossClusterRecordChildWorkflowExecutionCompleteResponseAttributes> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      i_prot.skip(field_ident.field_type)?;
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CrossClusterRecordChildWorkflowExecutionCompleteResponseAttributes {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CrossClusterRecordChildWorkflowExecutionCompleteResponseAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyParentClosePolicyAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ApplyParentClosePolicyAttributes {
  pub child_domain_i_d: Option<String>,
  pub child_workflow_i_d: Option<String>,
  pub child_run_i_d: Option<String>,
  pub parent_close_policy: Option<ParentClosePolicy>,
}

impl ApplyParentClosePolicyAttributes {
  pub fn new<F10, F20, F30, F40>(child_domain_i_d: F10, child_workflow_i_d: F20, child_run_i_d: F30, parent_close_policy: F40) -> ApplyParentClosePolicyAttributes where F10: Into<Option<String>>, F20: Into<Option<String>>, F30: Into<Option<String>>, F40: Into<Option<ParentClosePolicy>> {
    ApplyParentClosePolicyAttributes {
      child_domain_i_d: child_domain_i_d.into(),
      child_workflow_i_d: child_workflow_i_d.into(),
      child_run_i_d: child_run_i_d.into(),
      parent_close_policy: parent_close_policy.into(),
    }
  }
}

impl TSerializable for ApplyParentClosePolicyAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyParentClosePolicyAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<String> = None;
    let mut f_30: Option<String> = None;
    let mut f_40: Option<ParentClosePolicy> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_string()?;
          f_30 = Some(val);
        },
        40 => {
          let val = ParentClosePolicy::read_from_in_protocol(i_prot)?;
          f_40 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyParentClosePolicyAttributes {
      child_domain_i_d: f_10,
      child_workflow_i_d: f_20,
      child_run_i_d: f_30,
      parent_close_policy: f_40,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyParentClosePolicyAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.child_domain_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("childDomainID", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.child_workflow_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("childWorkflowID", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.child_run_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("childRunID", TType::String, 30))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.parent_close_policy {
      o_prot.write_field_begin(&TFieldIdentifier::new("parentClosePolicy", TType::I32, 40))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyParentClosePolicyStatus
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ApplyParentClosePolicyStatus {
  pub completed: Option<bool>,
  pub failed_cause: Option<CrossClusterTaskFailedCause>,
}

impl ApplyParentClosePolicyStatus {
  pub fn new<F10, F20>(completed: F10, failed_cause: F20) -> ApplyParentClosePolicyStatus where F10: Into<Option<bool>>, F20: Into<Option<CrossClusterTaskFailedCause>> {
    ApplyParentClosePolicyStatus {
      completed: completed.into(),
      failed_cause: failed_cause.into(),
    }
  }
}

impl TSerializable for ApplyParentClosePolicyStatus {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyParentClosePolicyStatus> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<bool> = None;
    let mut f_20: Option<CrossClusterTaskFailedCause> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_bool()?;
          f_10 = Some(val);
        },
        20 => {
          let val = CrossClusterTaskFailedCause::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyParentClosePolicyStatus {
      completed: f_10,
      failed_cause: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyParentClosePolicyStatus");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.completed {
      o_prot.write_field_begin(&TFieldIdentifier::new("completed", TType::Bool, 10))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.failed_cause {
      o_prot.write_field_begin(&TFieldIdentifier::new("failedCause", TType::I32, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyParentClosePolicyRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ApplyParentClosePolicyRequest {
  pub child: Option<ApplyParentClosePolicyAttributes>,
  pub status: Option<ApplyParentClosePolicyStatus>,
}

impl ApplyParentClosePolicyRequest {
  pub fn new<F10, F20>(child: F10, status: F20) -> ApplyParentClosePolicyRequest where F10: Into<Option<ApplyParentClosePolicyAttributes>>, F20: Into<Option<ApplyParentClosePolicyStatus>> {
    ApplyParentClosePolicyRequest {
      child: child.into(),
      status: status.into(),
    }
  }
}

impl TSerializable for ApplyParentClosePolicyRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyParentClosePolicyRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<ApplyParentClosePolicyAttributes> = None;
    let mut f_20: Option<ApplyParentClosePolicyStatus> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = ApplyParentClosePolicyAttributes::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        20 => {
          let val = ApplyParentClosePolicyStatus::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyParentClosePolicyRequest {
      child: f_10,
      status: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyParentClosePolicyRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.child {
      o_prot.write_field_begin(&TFieldIdentifier::new("child", TType::Struct, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.status {
      o_prot.write_field_begin(&TFieldIdentifier::new("status", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// CrossClusterApplyParentClosePolicyRequestAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CrossClusterApplyParentClosePolicyRequestAttributes {
  pub children: Option<Vec<ApplyParentClosePolicyRequest>>,
}

impl CrossClusterApplyParentClosePolicyRequestAttributes {
  pub fn new<F10>(children: F10) -> CrossClusterApplyParentClosePolicyRequestAttributes where F10: Into<Option<Vec<ApplyParentClosePolicyRequest>>> {
    CrossClusterApplyParentClosePolicyRequestAttributes {
      children: children.into(),
    }
  }
}

impl TSerializable for CrossClusterApplyParentClosePolicyRequestAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CrossClusterApplyParentClosePolicyRequestAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<Vec<ApplyParentClosePolicyRequest>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<ApplyParentClosePolicyRequest> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_71 = ApplyParentClosePolicyRequest::read_from_in_protocol(i_prot)?;
            val.push(list_elem_71);
          }
          i_prot.read_list_end()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CrossClusterApplyParentClosePolicyRequestAttributes {
      children: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CrossClusterApplyParentClosePolicyRequestAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.children {
      o_prot.write_field_begin(&TFieldIdentifier::new("children", TType::List, 10))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ApplyParentClosePolicyResult
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ApplyParentClosePolicyResult {
  pub child: Option<ApplyParentClosePolicyAttributes>,
  pub failed_cause: Option<CrossClusterTaskFailedCause>,
}

impl ApplyParentClosePolicyResult {
  pub fn new<F10, F20>(child: F10, failed_cause: F20) -> ApplyParentClosePolicyResult where F10: Into<Option<ApplyParentClosePolicyAttributes>>, F20: Into<Option<CrossClusterTaskFailedCause>> {
    ApplyParentClosePolicyResult {
      child: child.into(),
      failed_cause: failed_cause.into(),
    }
  }
}

impl TSerializable for ApplyParentClosePolicyResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ApplyParentClosePolicyResult> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<ApplyParentClosePolicyAttributes> = None;
    let mut f_20: Option<CrossClusterTaskFailedCause> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = ApplyParentClosePolicyAttributes::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        20 => {
          let val = CrossClusterTaskFailedCause::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ApplyParentClosePolicyResult {
      child: f_10,
      failed_cause: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ApplyParentClosePolicyResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.child {
      o_prot.write_field_begin(&TFieldIdentifier::new("child", TType::Struct, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.failed_cause {
      o_prot.write_field_begin(&TFieldIdentifier::new("failedCause", TType::I32, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// CrossClusterApplyParentClosePolicyResponseAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CrossClusterApplyParentClosePolicyResponseAttributes {
  pub children_status: Option<Vec<ApplyParentClosePolicyResult>>,
}

impl CrossClusterApplyParentClosePolicyResponseAttributes {
  pub fn new<F10>(children_status: F10) -> CrossClusterApplyParentClosePolicyResponseAttributes where F10: Into<Option<Vec<ApplyParentClosePolicyResult>>> {
    CrossClusterApplyParentClosePolicyResponseAttributes {
      children_status: children_status.into(),
    }
  }
}

impl TSerializable for CrossClusterApplyParentClosePolicyResponseAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CrossClusterApplyParentClosePolicyResponseAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<Vec<ApplyParentClosePolicyResult>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<ApplyParentClosePolicyResult> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_72 = ApplyParentClosePolicyResult::read_from_in_protocol(i_prot)?;
            val.push(list_elem_72);
          }
          i_prot.read_list_end()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CrossClusterApplyParentClosePolicyResponseAttributes {
      children_status: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CrossClusterApplyParentClosePolicyResponseAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.children_status {
      o_prot.write_field_begin(&TFieldIdentifier::new("childrenStatus", TType::List, 10))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// CrossClusterTaskRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CrossClusterTaskRequest {
  pub task_info: Option<CrossClusterTaskInfo>,
  pub start_child_execution_attributes: Option<CrossClusterStartChildExecutionRequestAttributes>,
  pub cancel_execution_attributes: Option<CrossClusterCancelExecutionRequestAttributes>,
  pub signal_execution_attributes: Option<CrossClusterSignalExecutionRequestAttributes>,
  pub record_child_workflow_execution_complete_attributes: Option<CrossClusterRecordChildWorkflowExecutionCompleteRequestAttributes>,
  pub apply_parent_close_policy_attributes: Option<CrossClusterApplyParentClosePolicyRequestAttributes>,
}

impl CrossClusterTaskRequest {
  pub fn new<F10, F20, F30, F40, F50, F60>(task_info: F10, start_child_execution_attributes: F20, cancel_execution_attributes: F30, signal_execution_attributes: F40, record_child_workflow_execution_complete_attributes: F50, apply_parent_close_policy_attributes: F60) -> CrossClusterTaskRequest where F10: Into<Option<CrossClusterTaskInfo>>, F20: Into<Option<CrossClusterStartChildExecutionRequestAttributes>>, F30: Into<Option<CrossClusterCancelExecutionRequestAttributes>>, F40: Into<Option<CrossClusterSignalExecutionRequestAttributes>>, F50: Into<Option<CrossClusterRecordChildWorkflowExecutionCompleteRequestAttributes>>, F60: Into<Option<CrossClusterApplyParentClosePolicyRequestAttributes>> {
    CrossClusterTaskRequest {
      task_info: task_info.into(),
      start_child_execution_attributes: start_child_execution_attributes.into(),
      cancel_execution_attributes: cancel_execution_attributes.into(),
      signal_execution_attributes: signal_execution_attributes.into(),
      record_child_workflow_execution_complete_attributes: record_child_workflow_execution_complete_attributes.into(),
      apply_parent_close_policy_attributes: apply_parent_close_policy_attributes.into(),
    }
  }
}

impl TSerializable for CrossClusterTaskRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CrossClusterTaskRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<CrossClusterTaskInfo> = None;
    let mut f_20: Option<CrossClusterStartChildExecutionRequestAttributes> = None;
    let mut f_30: Option<CrossClusterCancelExecutionRequestAttributes> = None;
    let mut f_40: Option<CrossClusterSignalExecutionRequestAttributes> = None;
    let mut f_50: Option<CrossClusterRecordChildWorkflowExecutionCompleteRequestAttributes> = None;
    let mut f_60: Option<CrossClusterApplyParentClosePolicyRequestAttributes> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = CrossClusterTaskInfo::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        20 => {
          let val = CrossClusterStartChildExecutionRequestAttributes::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        30 => {
          let val = CrossClusterCancelExecutionRequestAttributes::read_from_in_protocol(i_prot)?;
          f_30 = Some(val);
        },
        40 => {
          let val = CrossClusterSignalExecutionRequestAttributes::read_from_in_protocol(i_prot)?;
          f_40 = Some(val);
        },
        50 => {
          let val = CrossClusterRecordChildWorkflowExecutionCompleteRequestAttributes::read_from_in_protocol(i_prot)?;
          f_50 = Some(val);
        },
        60 => {
          let val = CrossClusterApplyParentClosePolicyRequestAttributes::read_from_in_protocol(i_prot)?;
          f_60 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CrossClusterTaskRequest {
      task_info: f_10,
      start_child_execution_attributes: f_20,
      cancel_execution_attributes: f_30,
      signal_execution_attributes: f_40,
      record_child_workflow_execution_complete_attributes: f_50,
      apply_parent_close_policy_attributes: f_60,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CrossClusterTaskRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.task_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskInfo", TType::Struct, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.start_child_execution_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("startChildExecutionAttributes", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cancel_execution_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("cancelExecutionAttributes", TType::Struct, 30))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.signal_execution_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("signalExecutionAttributes", TType::Struct, 40))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.record_child_workflow_execution_complete_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("recordChildWorkflowExecutionCompleteAttributes", TType::Struct, 50))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.apply_parent_close_policy_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("applyParentClosePolicyAttributes", TType::Struct, 60))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// CrossClusterTaskResponse
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CrossClusterTaskResponse {
  pub task_i_d: Option<i64>,
  pub task_type: Option<CrossClusterTaskType>,
  pub task_state: Option<i16>,
  pub failed_cause: Option<CrossClusterTaskFailedCause>,
  pub start_child_execution_attributes: Option<CrossClusterStartChildExecutionResponseAttributes>,
  pub cancel_execution_attributes: Option<CrossClusterCancelExecutionResponseAttributes>,
  pub signal_execution_attributes: Option<CrossClusterSignalExecutionResponseAttributes>,
  pub record_child_workflow_execution_complete_attributes: Option<CrossClusterRecordChildWorkflowExecutionCompleteResponseAttributes>,
  pub apply_parent_close_policy_attributes: Option<CrossClusterApplyParentClosePolicyResponseAttributes>,
}

impl CrossClusterTaskResponse {
  pub fn new<F10, F20, F30, F40, F50, F60, F70, F80, F90>(task_i_d: F10, task_type: F20, task_state: F30, failed_cause: F40, start_child_execution_attributes: F50, cancel_execution_attributes: F60, signal_execution_attributes: F70, record_child_workflow_execution_complete_attributes: F80, apply_parent_close_policy_attributes: F90) -> CrossClusterTaskResponse where F10: Into<Option<i64>>, F20: Into<Option<CrossClusterTaskType>>, F30: Into<Option<i16>>, F40: Into<Option<CrossClusterTaskFailedCause>>, F50: Into<Option<CrossClusterStartChildExecutionResponseAttributes>>, F60: Into<Option<CrossClusterCancelExecutionResponseAttributes>>, F70: Into<Option<CrossClusterSignalExecutionResponseAttributes>>, F80: Into<Option<CrossClusterRecordChildWorkflowExecutionCompleteResponseAttributes>>, F90: Into<Option<CrossClusterApplyParentClosePolicyResponseAttributes>> {
    CrossClusterTaskResponse {
      task_i_d: task_i_d.into(),
      task_type: task_type.into(),
      task_state: task_state.into(),
      failed_cause: failed_cause.into(),
      start_child_execution_attributes: start_child_execution_attributes.into(),
      cancel_execution_attributes: cancel_execution_attributes.into(),
      signal_execution_attributes: signal_execution_attributes.into(),
      record_child_workflow_execution_complete_attributes: record_child_workflow_execution_complete_attributes.into(),
      apply_parent_close_policy_attributes: apply_parent_close_policy_attributes.into(),
    }
  }
}

impl TSerializable for CrossClusterTaskResponse {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CrossClusterTaskResponse> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<i64> = None;
    let mut f_20: Option<CrossClusterTaskType> = None;
    let mut f_30: Option<i16> = None;
    let mut f_40: Option<CrossClusterTaskFailedCause> = None;
    let mut f_50: Option<CrossClusterStartChildExecutionResponseAttributes> = None;
    let mut f_60: Option<CrossClusterCancelExecutionResponseAttributes> = None;
    let mut f_70: Option<CrossClusterSignalExecutionResponseAttributes> = None;
    let mut f_80: Option<CrossClusterRecordChildWorkflowExecutionCompleteResponseAttributes> = None;
    let mut f_90: Option<CrossClusterApplyParentClosePolicyResponseAttributes> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_i64()?;
          f_10 = Some(val);
        },
        20 => {
          let val = CrossClusterTaskType::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_i16()?;
          f_30 = Some(val);
        },
        40 => {
          let val = CrossClusterTaskFailedCause::read_from_in_protocol(i_prot)?;
          f_40 = Some(val);
        },
        50 => {
          let val = CrossClusterStartChildExecutionResponseAttributes::read_from_in_protocol(i_prot)?;
          f_50 = Some(val);
        },
        60 => {
          let val = CrossClusterCancelExecutionResponseAttributes::read_from_in_protocol(i_prot)?;
          f_60 = Some(val);
        },
        70 => {
          let val = CrossClusterSignalExecutionResponseAttributes::read_from_in_protocol(i_prot)?;
          f_70 = Some(val);
        },
        80 => {
          let val = CrossClusterRecordChildWorkflowExecutionCompleteResponseAttributes::read_from_in_protocol(i_prot)?;
          f_80 = Some(val);
        },
        90 => {
          let val = CrossClusterApplyParentClosePolicyResponseAttributes::read_from_in_protocol(i_prot)?;
          f_90 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CrossClusterTaskResponse {
      task_i_d: f_10,
      task_type: f_20,
      task_state: f_30,
      failed_cause: f_40,
      start_child_execution_attributes: f_50,
      cancel_execution_attributes: f_60,
      signal_execution_attributes: f_70,
      record_child_workflow_execution_complete_attributes: f_80,
      apply_parent_close_policy_attributes: f_90,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CrossClusterTaskResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.task_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskID", TType::I64, 10))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.task_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskType", TType::I32, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.task_state {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskState", TType::I16, 30))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.failed_cause {
      o_prot.write_field_begin(&TFieldIdentifier::new("failedCause", TType::I32, 40))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.start_child_execution_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("startChildExecutionAttributes", TType::Struct, 50))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cancel_execution_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("cancelExecutionAttributes", TType::Struct, 60))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.signal_execution_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("signalExecutionAttributes", TType::Struct, 70))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.record_child_workflow_execution_complete_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("recordChildWorkflowExecutionCompleteAttributes", TType::Struct, 80))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.apply_parent_close_policy_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("applyParentClosePolicyAttributes", TType::Struct, 90))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// GetCrossClusterTasksRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GetCrossClusterTasksRequest {
  pub shard_i_ds: Option<Vec<i32>>,
  pub target_cluster: Option<String>,
}

impl GetCrossClusterTasksRequest {
  pub fn new<F10, F20>(shard_i_ds: F10, target_cluster: F20) -> GetCrossClusterTasksRequest where F10: Into<Option<Vec<i32>>>, F20: Into<Option<String>> {
    GetCrossClusterTasksRequest {
      shard_i_ds: shard_i_ds.into(),
      target_cluster: target_cluster.into(),
    }
  }
}

impl TSerializable for GetCrossClusterTasksRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GetCrossClusterTasksRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<Vec<i32>> = None;
    let mut f_20: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_73 = i_prot.read_i32()?;
            val.push(list_elem_73);
          }
          i_prot.read_list_end()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = GetCrossClusterTasksRequest {
      shard_i_ds: f_10,
      target_cluster: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetCrossClusterTasksRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.shard_i_ds {
      o_prot.write_field_begin(&TFieldIdentifier::new("shardIDs", TType::List, 10))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i32(*e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.target_cluster {
      o_prot.write_field_begin(&TFieldIdentifier::new("targetCluster", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// GetCrossClusterTasksResponse
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GetCrossClusterTasksResponse {
  pub tasks_by_shard: Option<BTreeMap<i32, Vec<CrossClusterTaskRequest>>>,
  pub failed_cause_by_shard: Option<BTreeMap<i32, GetTaskFailedCause>>,
}

impl GetCrossClusterTasksResponse {
  pub fn new<F10, F20>(tasks_by_shard: F10, failed_cause_by_shard: F20) -> GetCrossClusterTasksResponse where F10: Into<Option<BTreeMap<i32, Vec<CrossClusterTaskRequest>>>>, F20: Into<Option<BTreeMap<i32, GetTaskFailedCause>>> {
    GetCrossClusterTasksResponse {
      tasks_by_shard: tasks_by_shard.into(),
      failed_cause_by_shard: failed_cause_by_shard.into(),
    }
  }
}

impl TSerializable for GetCrossClusterTasksResponse {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<GetCrossClusterTasksResponse> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<BTreeMap<i32, Vec<CrossClusterTaskRequest>>> = None;
    let mut f_20: Option<BTreeMap<i32, GetTaskFailedCause>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<i32, Vec<CrossClusterTaskRequest>> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_74 = i_prot.read_i32()?;
            let list_ident = i_prot.read_list_begin()?;
            let mut map_val_75: Vec<CrossClusterTaskRequest> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_76 = CrossClusterTaskRequest::read_from_in_protocol(i_prot)?;
              map_val_75.push(list_elem_76);
            }
            i_prot.read_list_end()?;
            val.insert(map_key_74, map_val_75);
          }
          i_prot.read_map_end()?;
          f_10 = Some(val);
        },
        20 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<i32, GetTaskFailedCause> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_77 = i_prot.read_i32()?;
            let map_val_78 = GetTaskFailedCause::read_from_in_protocol(i_prot)?;
            val.insert(map_key_77, map_val_78);
          }
          i_prot.read_map_end()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = GetCrossClusterTasksResponse {
      tasks_by_shard: f_10,
      failed_cause_by_shard: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetCrossClusterTasksResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.tasks_by_shard {
      o_prot.write_field_begin(&TFieldIdentifier::new("tasksByShard", TType::Map, 10))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::I32, TType::List, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_i32(*k)?;
        o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, v.len() as i32))?;
        for e in v {
          e.write_to_out_protocol(o_prot)?;
        }
        o_prot.write_list_end()?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.failed_cause_by_shard {
      o_prot.write_field_begin(&TFieldIdentifier::new("failedCauseByShard", TType::Map, 20))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::I32, TType::I32, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_i32(*k)?;
        v.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// RespondCrossClusterTasksCompletedRequest
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RespondCrossClusterTasksCompletedRequest {
  pub shard_i_d: Option<i32>,
  pub target_cluster: Option<String>,
  pub task_responses: Option<Vec<CrossClusterTaskResponse>>,
  pub fetch_new_tasks: Option<bool>,
}

impl RespondCrossClusterTasksCompletedRequest {
  pub fn new<F10, F20, F30, F40>(shard_i_d: F10, target_cluster: F20, task_responses: F30, fetch_new_tasks: F40) -> RespondCrossClusterTasksCompletedRequest where F10: Into<Option<i32>>, F20: Into<Option<String>>, F30: Into<Option<Vec<CrossClusterTaskResponse>>>, F40: Into<Option<bool>> {
    RespondCrossClusterTasksCompletedRequest {
      shard_i_d: shard_i_d.into(),
      target_cluster: target_cluster.into(),
      task_responses: task_responses.into(),
      fetch_new_tasks: fetch_new_tasks.into(),
    }
  }
}

impl TSerializable for RespondCrossClusterTasksCompletedRequest {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RespondCrossClusterTasksCompletedRequest> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<i32> = None;
    let mut f_20: Option<String> = None;
    let mut f_30: Option<Vec<CrossClusterTaskResponse>> = None;
    let mut f_40: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_i32()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        30 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<CrossClusterTaskResponse> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_79 = CrossClusterTaskResponse::read_from_in_protocol(i_prot)?;
            val.push(list_elem_79);
          }
          i_prot.read_list_end()?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_bool()?;
          f_40 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RespondCrossClusterTasksCompletedRequest {
      shard_i_d: f_10,
      target_cluster: f_20,
      task_responses: f_30,
      fetch_new_tasks: f_40,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RespondCrossClusterTasksCompletedRequest");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.shard_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("shardID", TType::I32, 10))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.target_cluster {
      o_prot.write_field_begin(&TFieldIdentifier::new("targetCluster", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.task_responses {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskResponses", TType::List, 30))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.fetch_new_tasks {
      o_prot.write_field_begin(&TFieldIdentifier::new("fetchNewTasks", TType::Bool, 40))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// RespondCrossClusterTasksCompletedResponse
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RespondCrossClusterTasksCompletedResponse {
  pub tasks: Option<Vec<CrossClusterTaskRequest>>,
}

impl RespondCrossClusterTasksCompletedResponse {
  pub fn new<F10>(tasks: F10) -> RespondCrossClusterTasksCompletedResponse where F10: Into<Option<Vec<CrossClusterTaskRequest>>> {
    RespondCrossClusterTasksCompletedResponse {
      tasks: tasks.into(),
    }
  }
}

impl TSerializable for RespondCrossClusterTasksCompletedResponse {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<RespondCrossClusterTasksCompletedResponse> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<Vec<CrossClusterTaskRequest>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<CrossClusterTaskRequest> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_80 = CrossClusterTaskRequest::read_from_in_protocol(i_prot)?;
            val.push(list_elem_80);
          }
          i_prot.read_list_end()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RespondCrossClusterTasksCompletedResponse {
      tasks: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RespondCrossClusterTasksCompletedResponse");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.tasks {
      o_prot.write_field_begin(&TFieldIdentifier::new("tasks", TType::List, 10))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IsolationGroupPartition
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct IsolationGroupPartition {
  pub name: Option<String>,
  pub state: Option<IsolationGroupState>,
}

impl IsolationGroupPartition {
  pub fn new<F10, F20>(name: F10, state: F20) -> IsolationGroupPartition where F10: Into<Option<String>>, F20: Into<Option<IsolationGroupState>> {
    IsolationGroupPartition {
      name: name.into(),
      state: state.into(),
    }
  }
}

impl TSerializable for IsolationGroupPartition {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IsolationGroupPartition> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<IsolationGroupState> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = IsolationGroupState::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IsolationGroupPartition {
      name: f_10,
      state: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IsolationGroupPartition");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.state {
      o_prot.write_field_begin(&TFieldIdentifier::new("state", TType::I32, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// IsolationGroupConfiguration
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct IsolationGroupConfiguration {
  pub isolation_groups: Option<Vec<IsolationGroupPartition>>,
}

impl IsolationGroupConfiguration {
  pub fn new<F10>(isolation_groups: F10) -> IsolationGroupConfiguration where F10: Into<Option<Vec<IsolationGroupPartition>>> {
    IsolationGroupConfiguration {
      isolation_groups: isolation_groups.into(),
    }
  }
}

impl TSerializable for IsolationGroupConfiguration {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<IsolationGroupConfiguration> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<Vec<IsolationGroupPartition>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<IsolationGroupPartition> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_81 = IsolationGroupPartition::read_from_in_protocol(i_prot)?;
            val.push(list_elem_81);
          }
          i_prot.read_list_end()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = IsolationGroupConfiguration {
      isolation_groups: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("IsolationGroupConfiguration");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.isolation_groups {
      o_prot.write_field_begin(&TFieldIdentifier::new("isolationGroups", TType::List, 10))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// AsyncWorkflowConfiguration
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AsyncWorkflowConfiguration {
  pub enabled: Option<bool>,
  pub predefined_queue_name: Option<String>,
  pub queue_type: Option<String>,
  pub queue_config: Option<DataBlob>,
}

impl AsyncWorkflowConfiguration {
  pub fn new<F10, F20, F30, F40>(enabled: F10, predefined_queue_name: F20, queue_type: F30, queue_config: F40) -> AsyncWorkflowConfiguration where F10: Into<Option<bool>>, F20: Into<Option<String>>, F30: Into<Option<String>>, F40: Into<Option<DataBlob>> {
    AsyncWorkflowConfiguration {
      enabled: enabled.into(),
      predefined_queue_name: predefined_queue_name.into(),
      queue_type: queue_type.into(),
      queue_config: queue_config.into(),
    }
  }
}

impl TSerializable for AsyncWorkflowConfiguration {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AsyncWorkflowConfiguration> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<bool> = None;
    let mut f_20: Option<String> = None;
    let mut f_30: Option<String> = None;
    let mut f_40: Option<DataBlob> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_bool()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_string()?;
          f_30 = Some(val);
        },
        40 => {
          let val = DataBlob::read_from_in_protocol(i_prot)?;
          f_40 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = AsyncWorkflowConfiguration {
      enabled: f_10,
      predefined_queue_name: f_20,
      queue_type: f_30,
      queue_config: f_40,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AsyncWorkflowConfiguration");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.enabled {
      o_prot.write_field_begin(&TFieldIdentifier::new("enabled", TType::Bool, 10))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.predefined_queue_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("predefinedQueueName", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.queue_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("queueType", TType::String, 30))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.queue_config {
      o_prot.write_field_begin(&TFieldIdentifier::new("queueConfig", TType::Struct, 40))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// Any
//

/// Any is a logical duplicate of google.protobuf.Any.
/// 
/// The intent of the type is the same, but it is not intended to be directly
/// compatible with google.protobuf.Any or any Thrift equivalent - this blob is
/// RPC-type agnostic by design (as the underlying data may be transported over
/// proto or thrift), and the data-bytes may be in any encoding.
/// 
/// This is intentionally different from DataBlob, which supports only a handful
/// of known encodings so it can be interpreted everywhere.  Any supports literally
/// any contents, and needs to be considered opaque until it is given to something
/// that is expecting it.
/// 
/// See ValueType to interpret the contents.
/// 
#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Any {
  pub value_type: Option<String>,
  pub value: Option<Vec<u8>>,
}

impl Any {
  pub fn new<F10, F20>(value_type: F10, value: F20) -> Any where F10: Into<Option<String>>, F20: Into<Option<Vec<u8>>> {
    Any {
      value_type: value_type.into(),
      value: value.into(),
    }
  }
}

impl TSerializable for Any {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Any> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<String> = None;
    let mut f_20: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_bytes()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Any {
      value_type: f_10,
      value: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Any");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.value_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("ValueType", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.value {
      o_prot.write_field_begin(&TFieldIdentifier::new("Value", TType::String, 20))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// AutoConfigHint
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AutoConfigHint {
  pub enable_auto_config: Option<bool>,
  pub poller_wait_time_in_ms: Option<i64>,
}

impl AutoConfigHint {
  pub fn new<F10, F20>(enable_auto_config: F10, poller_wait_time_in_ms: F20) -> AutoConfigHint where F10: Into<Option<bool>>, F20: Into<Option<i64>> {
    AutoConfigHint {
      enable_auto_config: enable_auto_config.into(),
      poller_wait_time_in_ms: poller_wait_time_in_ms.into(),
    }
  }
}

impl TSerializable for AutoConfigHint {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<AutoConfigHint> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<bool> = None;
    let mut f_20: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_bool()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_i64()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = AutoConfigHint {
      enable_auto_config: f_10,
      poller_wait_time_in_ms: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AutoConfigHint");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.enable_auto_config {
      o_prot.write_field_begin(&TFieldIdentifier::new("enableAutoConfig", TType::Bool, 10))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.poller_wait_time_in_ms {
      o_prot.write_field_begin(&TFieldIdentifier::new("pollerWaitTimeInMs", TType::I64, 20))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// QueueState
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct QueueState {
  pub virtual_queue_states: Option<BTreeMap<i64, Box<VirtualQueueState>>>,
  pub exclusive_max_read_level: Option<Box<TaskKey>>,
}

impl QueueState {
  pub fn new<F10, F20>(virtual_queue_states: F10, exclusive_max_read_level: F20) -> QueueState where F10: Into<Option<BTreeMap<i64, Box<VirtualQueueState>>>>, F20: Into<Option<Box<TaskKey>>> {
    QueueState {
      virtual_queue_states: virtual_queue_states.into(),
      exclusive_max_read_level: exclusive_max_read_level.into(),
    }
  }
}

impl TSerializable for QueueState {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<QueueState> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<BTreeMap<i64, Box<VirtualQueueState>>> = None;
    let mut f_20: Option<Box<TaskKey>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<i64, Box<VirtualQueueState>> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_82 = i_prot.read_i64()?;
            let map_val_83 = Box::new(VirtualQueueState::read_from_in_protocol(i_prot)?);
            val.insert(map_key_82, map_val_83);
          }
          i_prot.read_map_end()?;
          f_10 = Some(val);
        },
        20 => {
          let val = Box::new(TaskKey::read_from_in_protocol(i_prot)?);
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = QueueState {
      virtual_queue_states: f_10,
      exclusive_max_read_level: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("QueueState");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.virtual_queue_states {
      o_prot.write_field_begin(&TFieldIdentifier::new("virtualQueueStates", TType::Map, 10))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::I64, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_i64(*k)?;
        v.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.exclusive_max_read_level {
      o_prot.write_field_begin(&TFieldIdentifier::new("exclusiveMaxReadLevel", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// VirtualQueueState
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct VirtualQueueState {
  pub virtual_slice_states: Option<Vec<Box<VirtualSliceState>>>,
}

impl VirtualQueueState {
  pub fn new<F10>(virtual_slice_states: F10) -> VirtualQueueState where F10: Into<Option<Vec<Box<VirtualSliceState>>>> {
    VirtualQueueState {
      virtual_slice_states: virtual_slice_states.into(),
    }
  }
}

impl TSerializable for VirtualQueueState {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<VirtualQueueState> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<Vec<Box<VirtualSliceState>>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Box<VirtualSliceState>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_84 = Box::new(VirtualSliceState::read_from_in_protocol(i_prot)?);
            val.push(list_elem_84);
          }
          i_prot.read_list_end()?;
          f_10 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = VirtualQueueState {
      virtual_slice_states: f_10,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("VirtualQueueState");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.virtual_slice_states {
      o_prot.write_field_begin(&TFieldIdentifier::new("virtualSliceStates", TType::List, 10))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// VirtualSliceState
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct VirtualSliceState {
  pub task_range: Option<Box<TaskRange>>,
  pub predicate: Option<Box<Predicate>>,
}

impl VirtualSliceState {
  pub fn new<F10, F20>(task_range: F10, predicate: F20) -> VirtualSliceState where F10: Into<Option<Box<TaskRange>>>, F20: Into<Option<Box<Predicate>>> {
    VirtualSliceState {
      task_range: task_range.into(),
      predicate: predicate.into(),
    }
  }
}

impl TSerializable for VirtualSliceState {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<VirtualSliceState> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<Box<TaskRange>> = None;
    let mut f_20: Option<Box<Predicate>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = Box::new(TaskRange::read_from_in_protocol(i_prot)?);
          f_10 = Some(val);
        },
        20 => {
          let val = Box::new(Predicate::read_from_in_protocol(i_prot)?);
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = VirtualSliceState {
      task_range: f_10,
      predicate: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("VirtualSliceState");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.task_range {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskRange", TType::Struct, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.predicate {
      o_prot.write_field_begin(&TFieldIdentifier::new("predicate", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TaskRange
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TaskRange {
  pub inclusive_min: Option<Box<TaskKey>>,
  pub exclusive_max: Option<Box<TaskKey>>,
}

impl TaskRange {
  pub fn new<F10, F20>(inclusive_min: F10, exclusive_max: F20) -> TaskRange where F10: Into<Option<Box<TaskKey>>>, F20: Into<Option<Box<TaskKey>>> {
    TaskRange {
      inclusive_min: inclusive_min.into(),
      exclusive_max: exclusive_max.into(),
    }
  }
}

impl TSerializable for TaskRange {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TaskRange> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<Box<TaskKey>> = None;
    let mut f_20: Option<Box<TaskKey>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = Box::new(TaskKey::read_from_in_protocol(i_prot)?);
          f_10 = Some(val);
        },
        20 => {
          let val = Box::new(TaskKey::read_from_in_protocol(i_prot)?);
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TaskRange {
      inclusive_min: f_10,
      exclusive_max: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TaskRange");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.inclusive_min {
      o_prot.write_field_begin(&TFieldIdentifier::new("inclusiveMin", TType::Struct, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.exclusive_max {
      o_prot.write_field_begin(&TFieldIdentifier::new("exclusiveMax", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// TaskKey
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TaskKey {
  pub scheduled_time_nano: Option<i64>,
  pub task_i_d: Option<i64>,
}

impl TaskKey {
  pub fn new<F10, F20>(scheduled_time_nano: F10, task_i_d: F20) -> TaskKey where F10: Into<Option<i64>>, F20: Into<Option<i64>> {
    TaskKey {
      scheduled_time_nano: scheduled_time_nano.into(),
      task_i_d: task_i_d.into(),
    }
  }
}

impl TSerializable for TaskKey {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<TaskKey> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<i64> = None;
    let mut f_20: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_i64()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_i64()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TaskKey {
      scheduled_time_nano: f_10,
      task_i_d: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TaskKey");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.scheduled_time_nano {
      o_prot.write_field_begin(&TFieldIdentifier::new("scheduledTimeNano", TType::I64, 10))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.task_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("taskID", TType::I64, 20))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ActiveClusterSelectionPolicy
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ActiveClusterSelectionPolicy {
  pub cluster_attribute: Option<Box<ClusterAttribute>>,
  pub strategy: Option<Box<ActiveClusterSelectionStrategy>>,
  pub sticky_region: Option<String>,
  pub external_entity_type: Option<String>,
  pub external_entity_key: Option<String>,
}

impl ActiveClusterSelectionPolicy {
  pub fn new<F1, F10, F20, F30, F40>(cluster_attribute: F1, strategy: F10, sticky_region: F20, external_entity_type: F30, external_entity_key: F40) -> ActiveClusterSelectionPolicy where F1: Into<Option<Box<ClusterAttribute>>>, F10: Into<Option<Box<ActiveClusterSelectionStrategy>>>, F20: Into<Option<String>>, F30: Into<Option<String>>, F40: Into<Option<String>> {
    ActiveClusterSelectionPolicy {
      cluster_attribute: cluster_attribute.into(),
      strategy: strategy.into(),
      sticky_region: sticky_region.into(),
      external_entity_type: external_entity_type.into(),
      external_entity_key: external_entity_key.into(),
    }
  }
}

impl TSerializable for ActiveClusterSelectionPolicy {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ActiveClusterSelectionPolicy> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Box<ClusterAttribute>> = None;
    let mut f_10: Option<Box<ActiveClusterSelectionStrategy>> = None;
    let mut f_20: Option<String> = None;
    let mut f_30: Option<String> = None;
    let mut f_40: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Box::new(ClusterAttribute::read_from_in_protocol(i_prot)?);
          f_1 = Some(val);
        },
        10 => {
          let val = Box::new(ActiveClusterSelectionStrategy::read_from_in_protocol(i_prot)?);
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        30 => {
          let val = i_prot.read_string()?;
          f_30 = Some(val);
        },
        40 => {
          let val = i_prot.read_string()?;
          f_40 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ActiveClusterSelectionPolicy {
      cluster_attribute: f_1,
      strategy: f_10,
      sticky_region: f_20,
      external_entity_type: f_30,
      external_entity_key: f_40,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ActiveClusterSelectionPolicy");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.cluster_attribute {
      o_prot.write_field_begin(&TFieldIdentifier::new("clusterAttribute", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.strategy {
      o_prot.write_field_begin(&TFieldIdentifier::new("strategy", TType::I32, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.sticky_region {
      o_prot.write_field_begin(&TFieldIdentifier::new("stickyRegion", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.external_entity_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("externalEntityType", TType::String, 30))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.external_entity_key {
      o_prot.write_field_begin(&TFieldIdentifier::new("externalEntityKey", TType::String, 40))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ClusterAttribute
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ClusterAttribute {
  pub scope: Option<String>,
  pub name: Option<String>,
}

impl ClusterAttribute {
  pub fn new<F1, F2>(scope: F1, name: F2) -> ClusterAttribute where F1: Into<Option<String>>, F2: Into<Option<String>> {
    ClusterAttribute {
      scope: scope.into(),
      name: name.into(),
    }
  }
}

impl TSerializable for ClusterAttribute {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ClusterAttribute> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ClusterAttribute {
      scope: f_1,
      name: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ClusterAttribute");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.scope {
      o_prot.write_field_begin(&TFieldIdentifier::new("scope", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// PaginationOptions
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PaginationOptions {
  pub page_size: Option<i32>,
  pub next_page_token: Option<Vec<u8>>,
}

impl PaginationOptions {
  pub fn new<F10, F20>(page_size: F10, next_page_token: F20) -> PaginationOptions where F10: Into<Option<i32>>, F20: Into<Option<Vec<u8>>> {
    PaginationOptions {
      page_size: page_size.into(),
      next_page_token: next_page_token.into(),
    }
  }
}

impl TSerializable for PaginationOptions {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<PaginationOptions> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<i32> = None;
    let mut f_20: Option<Vec<u8>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = i_prot.read_i32()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_bytes()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = PaginationOptions {
      page_size: f_10,
      next_page_token: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PaginationOptions");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.page_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("pageSize", TType::I32, 10))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.next_page_token {
      o_prot.write_field_begin(&TFieldIdentifier::new("nextPageToken", TType::String, 20))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// UniversalPredicateAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct UniversalPredicateAttributes {
}

impl UniversalPredicateAttributes {
  pub fn new() -> UniversalPredicateAttributes {
    UniversalPredicateAttributes {}
  }
}

impl TSerializable for UniversalPredicateAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UniversalPredicateAttributes> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      i_prot.skip(field_ident.field_type)?;
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = UniversalPredicateAttributes {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UniversalPredicateAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// EmptyPredicateAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct EmptyPredicateAttributes {
}

impl EmptyPredicateAttributes {
  pub fn new() -> EmptyPredicateAttributes {
    EmptyPredicateAttributes {}
  }
}

impl TSerializable for EmptyPredicateAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<EmptyPredicateAttributes> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      i_prot.skip(field_ident.field_type)?;
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = EmptyPredicateAttributes {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("EmptyPredicateAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DomainIDPredicateAttributes
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DomainIDPredicateAttributes {
  pub domain_i_ds: Option<Vec<String>>,
  pub is_exclusive: Option<bool>,
}

impl DomainIDPredicateAttributes {
  pub fn new<F10, F20>(domain_i_ds: F10, is_exclusive: F20) -> DomainIDPredicateAttributes where F10: Into<Option<Vec<String>>>, F20: Into<Option<bool>> {
    DomainIDPredicateAttributes {
      domain_i_ds: domain_i_ds.into(),
      is_exclusive: is_exclusive.into(),
    }
  }
}

impl TSerializable for DomainIDPredicateAttributes {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<DomainIDPredicateAttributes> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<Vec<String>> = None;
    let mut f_20: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_85 = i_prot.read_string()?;
            val.push(list_elem_85);
          }
          i_prot.read_list_end()?;
          f_10 = Some(val);
        },
        20 => {
          let val = i_prot.read_bool()?;
          f_20 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DomainIDPredicateAttributes {
      domain_i_ds: f_10,
      is_exclusive: f_20,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DomainIDPredicateAttributes");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.domain_i_ds {
      o_prot.write_field_begin(&TFieldIdentifier::new("domainIDs", TType::List, 10))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.is_exclusive {
      o_prot.write_field_begin(&TFieldIdentifier::new("isExclusive", TType::Bool, 20))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// Predicate
//

#[derive(Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Predicate {
  pub predicate_type: Option<PredicateType>,
  pub universal_predicate_attributes: Option<UniversalPredicateAttributes>,
  pub empty_predicate_attributes: Option<EmptyPredicateAttributes>,
  pub domain_i_d_predicate_attributes: Option<DomainIDPredicateAttributes>,
}

impl Predicate {
  pub fn new<F10, F20, F30, F40>(predicate_type: F10, universal_predicate_attributes: F20, empty_predicate_attributes: F30, domain_i_d_predicate_attributes: F40) -> Predicate where F10: Into<Option<PredicateType>>, F20: Into<Option<UniversalPredicateAttributes>>, F30: Into<Option<EmptyPredicateAttributes>>, F40: Into<Option<DomainIDPredicateAttributes>> {
    Predicate {
      predicate_type: predicate_type.into(),
      universal_predicate_attributes: universal_predicate_attributes.into(),
      empty_predicate_attributes: empty_predicate_attributes.into(),
      domain_i_d_predicate_attributes: domain_i_d_predicate_attributes.into(),
    }
  }
}

impl TSerializable for Predicate {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Predicate> {
    i_prot.read_struct_begin()?;
    let mut f_10: Option<PredicateType> = None;
    let mut f_20: Option<UniversalPredicateAttributes> = None;
    let mut f_30: Option<EmptyPredicateAttributes> = None;
    let mut f_40: Option<DomainIDPredicateAttributes> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        10 => {
          let val = PredicateType::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        20 => {
          let val = UniversalPredicateAttributes::read_from_in_protocol(i_prot)?;
          f_20 = Some(val);
        },
        30 => {
          let val = EmptyPredicateAttributes::read_from_in_protocol(i_prot)?;
          f_30 = Some(val);
        },
        40 => {
          let val = DomainIDPredicateAttributes::read_from_in_protocol(i_prot)?;
          f_40 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Predicate {
      predicate_type: f_10,
      universal_predicate_attributes: f_20,
      empty_predicate_attributes: f_30,
      domain_i_d_predicate_attributes: f_40,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Predicate");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.predicate_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("predicateType", TType::I32, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.universal_predicate_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("universalPredicateAttributes", TType::Struct, 20))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.empty_predicate_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("emptyPredicateAttributes", TType::Struct, 30))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.domain_i_d_predicate_attributes {
      o_prot.write_field_begin(&TFieldIdentifier::new("domainIDPredicateAttributes", TType::Struct, 40))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

