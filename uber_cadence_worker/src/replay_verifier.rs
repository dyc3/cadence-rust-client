//! Replay verifier module for non-determinism detection.
//!
//! This module provides functionality to verify that replay decisions match
//! the history events, detecting non-deterministic workflow execution.

use uber_cadence_core::{NonDeterminismReason, NonDeterministicError, ReplayContext};
use uber_cadence_proto::shared::{
    Decision, DecisionAttributes, DecisionType, EventAttributes, EventType, HistoryEvent,
};

/// Marker names that should be skipped during deterministic check
const VERSION_MARKER_NAME: &str = "Version";
const MUTABLE_SIDE_EFFECT_MARKER_NAME: &str = "MutableSideEffect";

/// Match replay decisions with history events to verify determinism.
///
/// This function compares the decisions generated by the workflow replay against
/// the actual history events that were recorded. Any mismatch indicates
/// non-deterministic workflow execution.
///
/// # Arguments
/// * `decisions` - The decisions generated by the replay
/// * `history_events` - The history events from the actual execution
/// * `context` - Context information for error reporting
///
/// # Returns
/// * `Ok(())` if replay matches history
/// * `Err(NonDeterministicError)` if there's a mismatch
pub fn match_replay_with_history(
    decisions: &[Decision],
    history_events: &[HistoryEvent],
    context: &ReplayContext,
) -> Result<(), Box<NonDeterministicError>> {
    // Filter to only decision-task-related history events
    let relevant_history_events: Vec<&HistoryEvent> = history_events
        .iter()
        .filter(|e| is_decision_relevant_event(e.event_type))
        .collect();

    let mut decision_idx = 0;
    let mut event_idx = 0;

    while decision_idx < decisions.len() || event_idx < relevant_history_events.len() {
        // Skip markers in decisions (SideEffect, Version, MutableSideEffect are non-deterministic by design)
        while decision_idx < decisions.len()
            && skip_deterministic_check_for_decision(&decisions[decision_idx])
        {
            decision_idx += 1;
        }

        // Skip markers in history events
        while event_idx < relevant_history_events.len()
            && skip_deterministic_check_for_event(relevant_history_events[event_idx])
        {
            event_idx += 1;
        }

        // Check if we've exhausted both lists
        if decision_idx >= decisions.len() && event_idx >= relevant_history_events.len() {
            break;
        }

        // If we have more decisions but no more events -> extra decision
        if decision_idx < decisions.len() && event_idx >= relevant_history_events.len() {
            return Err(create_error(
                NonDeterminismReason::ExtraReplayDecision,
                context,
                None,
                Some(&decisions[decision_idx]),
            ));
        }

        // If we have more events but no more decisions -> missing decision
        if decision_idx >= decisions.len() && event_idx < relevant_history_events.len() {
            return Err(create_error(
                NonDeterminismReason::MissingReplayDecision,
                context,
                Some(relevant_history_events[event_idx]),
                None,
            ));
        }

        let decision = &decisions[decision_idx];
        let event = relevant_history_events[event_idx];

        // Check if decision matches event
        if is_decision_match_event(decision, event) {
            decision_idx += 1;
            event_idx += 1;
        } else {
            return Err(create_error(
                NonDeterminismReason::Mismatch,
                context,
                Some(event),
                Some(decision),
            ));
        }
    }

    Ok(())
}

/// Check if a decision matches a history event
fn is_decision_match_event(decision: &Decision, event: &HistoryEvent) -> bool {
    match (decision.decision_type, event.event_type) {
        // ScheduleActivityTask <-> ActivityTaskScheduled
        (DecisionType::ScheduleActivityTask, EventType::ActivityTaskScheduled) => {
            match (&decision.attributes, &event.attributes) {
                (
                    Some(DecisionAttributes::ScheduleActivityTaskDecisionAttributes(dec_attr)),
                    Some(EventAttributes::ActivityTaskScheduledEventAttributes(event_attr)),
                ) => {
                    // Compare activity_id
                    if dec_attr.activity_id != event_attr.activity_id {
                        return false;
                    }
                    // Compare activity_type name (last part only)
                    let dec_type_name = dec_attr
                        .activity_type
                        .as_ref()
                        .map(|t| last_part_of_name(&t.name))
                        .unwrap_or_default();
                    let event_type_name = event_attr
                        .activity_type
                        .as_ref()
                        .map(|t| last_part_of_name(&t.name))
                        .unwrap_or_default();
                    dec_type_name == event_type_name
                }
                _ => false,
            }
        }

        // RequestCancelActivityTask <-> ActivityTaskCancelRequested
        (DecisionType::RequestCancelActivityTask, EventType::ActivityTaskCancelRequested) => {
            // Activity cancel is initiated by workflow, history tracks the request
            // For simplicity, we consider these to match at the type level
            // Detailed matching would require tracking scheduled_event_id mappings
            true
        }

        // StartTimer <-> TimerStarted
        (DecisionType::StartTimer, EventType::TimerStarted) => {
            match (&decision.attributes, &event.attributes) {
                (
                    Some(DecisionAttributes::StartTimerDecisionAttributes(dec_attr)),
                    Some(EventAttributes::TimerStartedEventAttributes(event_attr)),
                ) => dec_attr.timer_id == event_attr.timer_id,
                _ => false,
            }
        }

        // CancelTimer <-> TimerCanceled
        (DecisionType::CancelTimer, EventType::TimerCanceled) => true,

        // CompleteWorkflowExecution <-> WorkflowExecutionCompleted
        (DecisionType::CompleteWorkflowExecution, EventType::WorkflowExecutionCompleted) => true,

        // FailWorkflowExecution <-> WorkflowExecutionFailed
        (DecisionType::FailWorkflowExecution, EventType::WorkflowExecutionFailed) => true,

        // RecordMarker <-> MarkerRecorded
        (DecisionType::RecordMarker, EventType::MarkerRecorded) => {
            match (&decision.attributes, &event.attributes) {
                (
                    Some(DecisionAttributes::RecordMarkerDecisionAttributes(dec_attr)),
                    Some(EventAttributes::MarkerRecordedEventAttributes(event_attr)),
                ) => dec_attr.marker_name == event_attr.marker_name,
                _ => false,
            }
        }

        // RequestCancelExternalWorkflowExecution <-> RequestCancelExternalWorkflowExecutionInitiated
        (
            DecisionType::RequestCancelExternalWorkflowExecution,
            EventType::RequestCancelExternalWorkflowExecutionInitiated,
        ) => true,

        // SignalExternalWorkflowExecution <-> SignalExternalWorkflowExecutionInitiated
        (
            DecisionType::SignalExternalWorkflowExecution,
            EventType::SignalExternalWorkflowExecutionInitiated,
        ) => true,

        // CancelWorkflowExecution <-> WorkflowExecutionCanceled
        (DecisionType::CancelWorkflowExecution, EventType::WorkflowExecutionCanceled) => true,

        // ContinueAsNewWorkflowExecution - Note: There's no corresponding WorkflowExecutionContinuedAsNew event
        // The workflow continues as new immediately without a specific event for this
        // We skip this matching as the decision creates a new workflow execution
        (DecisionType::ContinueAsNewWorkflowExecution, _) => false,

        // StartChildWorkflowExecution <-> StartChildWorkflowExecutionInitiated
        (
            DecisionType::StartChildWorkflowExecution,
            EventType::StartChildWorkflowExecutionInitiated,
        ) => {
            match (&decision.attributes, &event.attributes) {
                (
                    Some(DecisionAttributes::StartChildWorkflowExecutionDecisionAttributes(
                        dec_attr,
                    )),
                    Some(EventAttributes::StartChildWorkflowExecutionInitiatedEventAttributes(
                        event_attr,
                    )),
                ) => {
                    // Compare workflow_id
                    if dec_attr.workflow_id != event_attr.workflow_id {
                        return false;
                    }
                    // Compare workflow_type name (last part only)
                    let dec_type_name = dec_attr
                        .workflow_type
                        .as_ref()
                        .map(|t| last_part_of_name(&t.name))
                        .unwrap_or_default();
                    let event_type_name = event_attr
                        .workflow_type
                        .as_ref()
                        .map(|t| last_part_of_name(&t.name))
                        .unwrap_or_default();
                    dec_type_name == event_type_name
                }
                _ => false,
            }
        }

        // UpsertWorkflowSearchAttributes <-> UpsertWorkflowSearchAttributes
        (
            DecisionType::UpsertWorkflowSearchAttributes,
            EventType::UpsertWorkflowSearchAttributes,
        ) => true,

        // No match
        _ => false,
    }
}

/// Check if an event should be skipped during deterministic check.
/// Skips markers that are non-deterministic by design (Version, MutableSideEffect).
fn skip_deterministic_check_for_event(event: &HistoryEvent) -> bool {
    if event.event_type != EventType::MarkerRecorded {
        return false;
    }

    if let Some(EventAttributes::MarkerRecordedEventAttributes(attrs)) = &event.attributes {
        let marker_name = attrs.marker_name.as_str();
        marker_name == VERSION_MARKER_NAME || marker_name == MUTABLE_SIDE_EFFECT_MARKER_NAME
    } else {
        false
    }
}

/// Check if a decision should be skipped during deterministic check.
/// Skips markers that are non-deterministic by design (Version, MutableSideEffect).
fn skip_deterministic_check_for_decision(decision: &Decision) -> bool {
    if decision.decision_type != DecisionType::RecordMarker {
        return false;
    }

    if let Some(DecisionAttributes::RecordMarkerDecisionAttributes(attrs)) = &decision.attributes {
        let marker_name = attrs.marker_name.as_str();
        marker_name == VERSION_MARKER_NAME || marker_name == MUTABLE_SIDE_EFFECT_MARKER_NAME
    } else {
        false
    }
}

/// Check if an event type is relevant for decision replay verification.
/// Only includes events that correspond to workflow decisions.
fn is_decision_relevant_event(event_type: EventType) -> bool {
    matches!(
        event_type,
        EventType::ActivityTaskScheduled
            | EventType::ActivityTaskCancelRequested
            | EventType::TimerStarted
            | EventType::TimerCanceled
            | EventType::WorkflowExecutionCompleted
            | EventType::WorkflowExecutionFailed
            | EventType::MarkerRecorded
            | EventType::RequestCancelExternalWorkflowExecutionInitiated
            | EventType::SignalExternalWorkflowExecutionInitiated
            | EventType::WorkflowExecutionCanceled
            | EventType::StartChildWorkflowExecutionInitiated
            | EventType::UpsertWorkflowSearchAttributes
    )
}

/// Extract the last component of a name (used for activity/workflow types).
/// Strips package prefix if present (e.g., "package.Activity" -> "Activity").
fn last_part_of_name(name: &str) -> String {
    name.rsplit('.').next().unwrap_or(name).to_string()
}

/// Create a NonDeterministicError with the given context and details.
fn create_error(
    reason: NonDeterminismReason,
    context: &ReplayContext,
    history_event: Option<&HistoryEvent>,
    decision: Option<&Decision>,
) -> Box<NonDeterministicError> {
    let history_event_text = history_event.map(|e| format!("{:?}", e));
    let decision_text = decision.map(|d| format!("{:?}", d));

    Box::new(NonDeterministicError {
        reason,
        context: context.clone(),
        history_event_text,
        decision_text,
    })
}

#[cfg(test)]
mod tests {
    use super::*;

    fn create_context() -> ReplayContext {
        ReplayContext::new(
            "TestWorkflow",
            "test-workflow-id",
            "test-run-id",
            "test-task-list",
            "test-domain",
        )
    }

    #[test]
    fn test_empty_decisions_and_history() {
        let context = create_context();
        let result = match_replay_with_history(&[], &[], &context);
        assert!(result.is_ok());
    }

    #[test]
    fn test_schedule_activity_match() {
        let context = create_context();

        let decision = Decision {
            decision_type: DecisionType::ScheduleActivityTask,
            attributes: Some(DecisionAttributes::ScheduleActivityTaskDecisionAttributes(
                Box::new(
                    uber_cadence_proto::shared::ScheduleActivityTaskDecisionAttributes {
                        activity_id: "activity-1".to_string(),
                        activity_type: Some(uber_cadence_proto::shared::ActivityType {
                            name: "TestActivity".to_string(),
                        }),
                        task_list: None,
                        input: None,
                        schedule_to_close_timeout_seconds: None,
                        schedule_to_start_timeout_seconds: None,
                        start_to_close_timeout_seconds: None,
                        heartbeat_timeout_seconds: None,
                        retry_policy: None,
                        header: None,
                    },
                ),
            )),
        };

        let event = HistoryEvent {
            event_id: 1,
            timestamp: 1000,
            event_type: EventType::ActivityTaskScheduled,
            version: 0,
            task_id: 1,
            attributes: Some(EventAttributes::ActivityTaskScheduledEventAttributes(
                Box::new(
                    uber_cadence_proto::shared::ActivityTaskScheduledEventAttributes {
                        activity_id: "activity-1".to_string(),
                        activity_type: Some(uber_cadence_proto::shared::ActivityType {
                            name: "TestActivity".to_string(),
                        }),
                        task_list: None,
                        input: None,
                        schedule_to_close_timeout_seconds: None,
                        schedule_to_start_timeout_seconds: None,
                        start_to_close_timeout_seconds: None,
                        heartbeat_timeout_seconds: None,
                        retry_policy: None,
                        decision_task_completed_event_id: 0,
                    },
                ),
            )),
        };

        let result = match_replay_with_history(&[decision], &[event], &context);
        assert!(result.is_ok());
    }

    #[test]
    fn test_schedule_activity_mismatch() {
        let context = create_context();

        let decision = Decision {
            decision_type: DecisionType::ScheduleActivityTask,
            attributes: Some(DecisionAttributes::ScheduleActivityTaskDecisionAttributes(
                Box::new(
                    uber_cadence_proto::shared::ScheduleActivityTaskDecisionAttributes {
                        activity_id: "activity-1".to_string(),
                        activity_type: Some(uber_cadence_proto::shared::ActivityType {
                            name: "ActivityA".to_string(),
                        }),
                        task_list: None,
                        input: None,
                        schedule_to_close_timeout_seconds: None,
                        schedule_to_start_timeout_seconds: None,
                        start_to_close_timeout_seconds: None,
                        heartbeat_timeout_seconds: None,
                        retry_policy: None,
                        header: None,
                    },
                ),
            )),
        };

        let event = HistoryEvent {
            event_id: 1,
            timestamp: 1000,
            event_type: EventType::ActivityTaskScheduled,
            version: 0,
            task_id: 1,
            attributes: Some(EventAttributes::ActivityTaskScheduledEventAttributes(
                Box::new(
                    uber_cadence_proto::shared::ActivityTaskScheduledEventAttributes {
                        activity_id: "activity-1".to_string(),
                        activity_type: Some(uber_cadence_proto::shared::ActivityType {
                            name: "ActivityB".to_string(),
                        }),
                        task_list: None,
                        input: None,
                        schedule_to_close_timeout_seconds: None,
                        schedule_to_start_timeout_seconds: None,
                        start_to_close_timeout_seconds: None,
                        heartbeat_timeout_seconds: None,
                        retry_policy: None,
                        decision_task_completed_event_id: 0,
                    },
                ),
            )),
        };

        let result = match_replay_with_history(&[decision], &[event], &context);
        assert!(result.is_err());
        let err = result.unwrap_err();
        assert!(matches!(err.reason, NonDeterminismReason::Mismatch));
    }

    #[test]
    fn test_missing_decision() {
        let context = create_context();

        let event = HistoryEvent {
            event_id: 1,
            timestamp: 1000,
            event_type: EventType::ActivityTaskScheduled,
            version: 0,
            task_id: 1,
            attributes: Some(EventAttributes::ActivityTaskScheduledEventAttributes(
                Box::new(
                    uber_cadence_proto::shared::ActivityTaskScheduledEventAttributes {
                        activity_id: "activity-1".to_string(),
                        activity_type: Some(uber_cadence_proto::shared::ActivityType {
                            name: "TestActivity".to_string(),
                        }),
                        task_list: None,
                        input: None,
                        schedule_to_close_timeout_seconds: None,
                        schedule_to_start_timeout_seconds: None,
                        start_to_close_timeout_seconds: None,
                        heartbeat_timeout_seconds: None,
                        retry_policy: None,
                        decision_task_completed_event_id: 0,
                    },
                ),
            )),
        };

        let result = match_replay_with_history(&[], &[event], &context);
        assert!(result.is_err());
        let err = result.unwrap_err();
        assert!(matches!(
            err.reason,
            NonDeterminismReason::MissingReplayDecision
        ));
    }

    #[test]
    fn test_extra_decision() {
        let context = create_context();

        let decision = Decision {
            decision_type: DecisionType::ScheduleActivityTask,
            attributes: Some(DecisionAttributes::ScheduleActivityTaskDecisionAttributes(
                Box::new(
                    uber_cadence_proto::shared::ScheduleActivityTaskDecisionAttributes {
                        activity_id: "activity-1".to_string(),
                        activity_type: Some(uber_cadence_proto::shared::ActivityType {
                            name: "TestActivity".to_string(),
                        }),
                        task_list: None,
                        input: None,
                        schedule_to_close_timeout_seconds: None,
                        schedule_to_start_timeout_seconds: None,
                        start_to_close_timeout_seconds: None,
                        heartbeat_timeout_seconds: None,
                        retry_policy: None,
                        header: None,
                    },
                ),
            )),
        };

        let result = match_replay_with_history(&[decision], &[], &context);
        assert!(result.is_err());
        let err = result.unwrap_err();
        assert!(matches!(
            err.reason,
            NonDeterminismReason::ExtraReplayDecision
        ));
    }

    #[test]
    fn test_last_part_of_name() {
        assert_eq!(last_part_of_name("Activity"), "Activity");
        assert_eq!(last_part_of_name("package.Activity"), "Activity");
        assert_eq!(last_part_of_name("com.example.Activity"), "Activity");
        assert_eq!(last_part_of_name(""), "");
    }

    #[test]
    fn test_version_marker_skipped() {
        let context = create_context();

        // Version marker decision should be skipped
        let decision = Decision {
            decision_type: DecisionType::RecordMarker,
            attributes: Some(DecisionAttributes::RecordMarkerDecisionAttributes(
                Box::new(uber_cadence_proto::shared::RecordMarkerDecisionAttributes {
                    marker_name: VERSION_MARKER_NAME.to_string(),
                    details: None,
                    header: None,
                }),
            )),
        };

        let result = match_replay_with_history(&[decision], &[], &context);
        assert!(result.is_ok());
    }

    #[test]
    fn test_mutable_side_effect_marker_skipped() {
        let context = create_context();

        // MutableSideEffect marker decision should be skipped
        let decision = Decision {
            decision_type: DecisionType::RecordMarker,
            attributes: Some(DecisionAttributes::RecordMarkerDecisionAttributes(
                Box::new(uber_cadence_proto::shared::RecordMarkerDecisionAttributes {
                    marker_name: MUTABLE_SIDE_EFFECT_MARKER_NAME.to_string(),
                    details: None,
                    header: None,
                }),
            )),
        };

        let result = match_replay_with_history(&[decision], &[], &context);
        assert!(result.is_ok());
    }

    #[test]
    fn test_timer_match() {
        let context = create_context();

        let decision = Decision {
            decision_type: DecisionType::StartTimer,
            attributes: Some(DecisionAttributes::StartTimerDecisionAttributes(Box::new(
                uber_cadence_proto::shared::StartTimerDecisionAttributes {
                    timer_id: "timer-1".to_string(),
                    start_to_fire_timeout_seconds: 60,
                },
            ))),
        };

        let event = HistoryEvent {
            event_id: 1,
            timestamp: 1000,
            event_type: EventType::TimerStarted,
            version: 0,
            task_id: 1,
            attributes: Some(EventAttributes::TimerStartedEventAttributes(Box::new(
                uber_cadence_proto::shared::TimerStartedEventAttributes {
                    timer_id: "timer-1".to_string(),
                    start_to_fire_timeout_seconds: 60,
                    decision_task_completed_event_id: 0,
                },
            ))),
        };

        let result = match_replay_with_history(&[decision], &[event], &context);
        assert!(result.is_ok());
    }

    #[test]
    fn test_timer_mismatch() {
        let context = create_context();

        let decision = Decision {
            decision_type: DecisionType::StartTimer,
            attributes: Some(DecisionAttributes::StartTimerDecisionAttributes(Box::new(
                uber_cadence_proto::shared::StartTimerDecisionAttributes {
                    timer_id: "timer-1".to_string(),
                    start_to_fire_timeout_seconds: 60,
                },
            ))),
        };

        let event = HistoryEvent {
            event_id: 1,
            timestamp: 1000,
            event_type: EventType::TimerStarted,
            version: 0,
            task_id: 1,
            attributes: Some(EventAttributes::TimerStartedEventAttributes(Box::new(
                uber_cadence_proto::shared::TimerStartedEventAttributes {
                    timer_id: "timer-2".to_string(),
                    start_to_fire_timeout_seconds: 60,
                    decision_task_completed_event_id: 0,
                },
            ))),
        };

        let result = match_replay_with_history(&[decision], &[event], &context);
        assert!(result.is_err());
    }

    #[test]
    fn test_complete_workflow_match() {
        let context = create_context();

        let decision = Decision {
            decision_type: DecisionType::CompleteWorkflowExecution,
            attributes: Some(
                DecisionAttributes::CompleteWorkflowExecutionDecisionAttributes(Box::new(
                    uber_cadence_proto::shared::CompleteWorkflowExecutionDecisionAttributes {
                        result: Some(vec![1, 2, 3]),
                    },
                )),
            ),
        };

        let event = HistoryEvent {
            event_id: 1,
            timestamp: 1000,
            event_type: EventType::WorkflowExecutionCompleted,
            version: 0,
            task_id: 1,
            attributes: Some(EventAttributes::WorkflowExecutionCompletedEventAttributes(
                Box::new(
                    uber_cadence_proto::shared::WorkflowExecutionCompletedEventAttributes {
                        result: Some(vec![1, 2, 3]),
                        decision_task_completed_event_id: 0,
                    },
                ),
            )),
        };

        let result = match_replay_with_history(&[decision], &[event], &context);
        assert!(result.is_ok());
    }

    #[test]
    fn test_fail_workflow_match() {
        let context = create_context();

        let decision = Decision {
            decision_type: DecisionType::FailWorkflowExecution,
            attributes: Some(DecisionAttributes::FailWorkflowExecutionDecisionAttributes(
                Box::new(
                    uber_cadence_proto::shared::FailWorkflowExecutionDecisionAttributes {
                        reason: Some("test failure".to_string()),
                        details: Some(vec![1, 2, 3]),
                    },
                ),
            )),
        };

        let event = HistoryEvent {
            event_id: 1,
            timestamp: 1000,
            event_type: EventType::WorkflowExecutionFailed,
            version: 0,
            task_id: 1,
            attributes: Some(EventAttributes::WorkflowExecutionFailedEventAttributes(
                Box::new(
                    uber_cadence_proto::shared::WorkflowExecutionFailedEventAttributes {
                        reason: Some("test failure".to_string()),
                        details: Some(vec![1, 2, 3]),
                        decision_task_completed_event_id: 0,
                    },
                ),
            )),
        };

        let result = match_replay_with_history(&[decision], &[event], &context);
        assert!(result.is_ok());
    }
}
