# Plan: Complete TestWorkflowEnvironment Implementation

## Overview

Complete the `TestWorkflowEnvironment` implementation in `cadence-testsuite` to support the 25 examples. The current implementation has placeholder methods with wrong signatures - it needs to be fully functional to allow unit testing workflows without a real Cadence server.

## Current State Analysis

### Problems Identified:
1. **Registration methods** - Take boxed closures, but examples expect async function pointers
2. **execute_workflow** - Takes closure, examples expect `(name, input) -> Result<Output, Error>`
3. **signal_workflow** - Missing on environment (exists on context, wrong place)
4. **Type mismatch** - Uses `TestWorkflowContext` instead of real `WorkflowContext`
5. **No serialization handling** - Examples pass typed inputs, but no conversion layer exists

## Implementation Plan

### Phase 1: Type Registry System

**File:** `cadence-testsuite/src/suite.rs`

Add type-erased registries for workflows and activities:

```rust
// Type aliases for registered functions
type WorkflowFn = Box<
    dyn Fn(&mut WorkflowContext, Vec<u8>) -> Pin<Box<dyn Future<Output = Result<Vec<u8>, WorkflowError>> + Send>> 
    + Send + Sync
>;

type ActivityFn = Box<
    dyn Fn(&ActivityContext, Vec<u8>) -> Pin<Box<dyn Future<Output = Result<Vec<u8>, ActivityError>> + Send>> 
    + Send + Sync
>;

pub struct TestWorkflowEnvironment {
    workflow_id: String,
    run_id: String,
    test_time: TestTime,
    registered_workflows: HashMap<String, WorkflowFn>,
    registered_activities: HashMap<String, ActivityFn>,
    pending_signals: HashMap<String, Vec<Vec<u8>>>,
    executed_activities: Vec<String>, // Track for assertions
}
```

**Tasks:**
- [ ] Add type aliases for boxed workflow and activity functions
- [ ] Add `registered_workflows: HashMap<String, WorkflowFn>` field
- [ ] Add `registered_activities: HashMap<String, ActivityFn>` field
- [ ] Add `pending_signals: HashMap<String, Vec<Vec<u8>>>` field
- [ ] Add `executed_activities: Vec<String>` for tracking (optional)

### Phase 2: Rewrite Registration Methods

**File:** `cadence-testsuite/src/suite.rs`

Change from accepting boxed closures to accepting typed async functions:

```rust
impl TestWorkflowEnvironment {
    /// Register a workflow by name
    pub fn register_workflow<F, Fut, I, O>(&mut self, name: &str, workflow: F)
    where
        F: Fn(&mut WorkflowContext, I) -> Fut + Send + Sync + 'static,
        Fut: Future<Output = Result<O, WorkflowError>> + Send,
        I: for<'de> Deserialize<'de> + Send + 'static,
        O: Serialize + Send + 'static,
    {
        let boxed = Box::new(move |ctx: &mut WorkflowContext, input_bytes: Vec<u8>| {
            let input: I = match serde_json::from_slice(&input_bytes) {
                Ok(i) => i,
                Err(e) => return Box::pin(async move {
                    Err(WorkflowError::Generic(format!("Input deserialization failed: {}", e)))
                }) as Pin<Box<dyn Future<Output = _> + Send>>,
            };
            
            let result = workflow(ctx, input);
            Box::pin(async move {
                let output = result.await?;
                serde_json::to_vec(&output)
                    .map_err(|e| WorkflowError::Generic(format!("Output serialization failed: {}", e)))
            }) as Pin<Box<dyn Future<Output = _> + Send>>
        });
        
        self.registered_workflows.insert(name.to_string(), boxed);
    }

    /// Register an activity by name
    pub fn register_activity<F, Fut, I, O>(&mut self, name: &str, activity: F)
    where
        F: Fn(&ActivityContext, I) -> Fut + Send + Sync + 'static,
        Fut: Future<Output = Result<O, ActivityError>> + Send,
        I: for<'de> Deserialize<'de> + Send + 'static,
        O: Serialize + Send + 'static,
    {
        let boxed = Box::new(move |ctx: &ActivityContext, input_bytes: Vec<u8>| {
            let input: I = match serde_json::from_slice(&input_bytes) {
                Ok(i) => i,
                Err(e) => return Box::pin(async move {
                    Err(ActivityError::Generic(format!("Input deserialization failed: {}", e)))
                }) as Pin<Box<dyn Future<Output = _> + Send>>,
            };
            
            let result = activity(ctx, input);
            Box::pin(async move {
                let output = result.await?;
                serde_json::to_vec(&output)
                    .map_err(|e| ActivityError::Generic(format!("Output serialization failed: {}", e)))
            }) as Pin<Box<dyn Future<Output = _> + Send>>
        });
        
        self.registered_activities.insert(name.to_string(), boxed);
    }
}
```

**Tasks:**
- [ ] Rewrite `register_workflow` with generic typed signature
- [ ] Rewrite `register_activity` with generic typed signature
- [ ] Remove old boxed closure signatures

### Phase 3: Rewrite execute_workflow Method

**File:** `cadence-testsuite/src/suite.rs`

Change from taking closure to taking name + input:

```rust
impl TestWorkflowEnvironment {
    /// Execute a registered workflow by name with typed input
    pub async fn execute_workflow<I, O>(&mut self, name: &str, input: I) -> Result<O, WorkflowError>
    where
        I: Serialize,
        O: for<'de> Deserialize<'de>,
    {
        // Serialize input
        let input_bytes = serde_json::to_vec(&input)
            .map_err(|e| WorkflowError::Generic(format!("Input serialization failed: {}", e)))?;
        
        // Look up workflow
        let workflow = self.registered_workflows.get(name)
            .ok_or_else(|| WorkflowError::Generic(format!("Workflow '{}' not registered", name)))?;
        
        // Create WorkflowInfo
        let workflow_info = WorkflowInfo {
            workflow_execution: WorkflowExecution::new(&self.workflow_id, &self.run_id),
            workflow_type: name.to_string(),
            task_list: "test-task-list".to_string(),
            // ... other fields with defaults
        };
        
        // Create WorkflowContext (real one from cadence-workflow)
        let mut ctx = WorkflowContext::new(workflow_info);
        
        // Inject pending signals into context (context needs to access them)
        // This requires modifying WorkflowContext or creating a test wrapper
        
        // Execute workflow
        let result_bytes = workflow(&mut ctx, input_bytes).await?;
        
        // Deserialize output
        serde_json::from_slice(&result_bytes)
            .map_err(|e| WorkflowError::Generic(format!("Output deserialization failed: {}", e)))
    }
}
```

**Challenge:** The `WorkflowContext` from `cadence-workflow` is not test-aware. Options:
1. Create a `TestWorkflowContext` that wraps or implements the same interface as `WorkflowContext`
2. Modify `WorkflowContext` to be testable (add test constructors)
3. Create a trait that both can implement

**Decision:** Create `TestWorkflowContext` that has the same API as `WorkflowContext` but is test-aware.

**Tasks:**
- [ ] Create `TestWorkflowContext` struct with same methods as `WorkflowContext`
- [ ] Implement `execute_activity` method that looks up in environment's registry
- [ ] Implement `get_signal_channel` that returns test signal channel
- [ ] Implement `sleep` that respects test time
- [ ] Implement `workflow_info()` method
- [ ] Change `execute_workflow` to create `TestWorkflowContext` instead of `WorkflowContext`

### Phase 4: Add signal_workflow to Environment

**File:** `cadence-testsuite/src/suite.rs`

```rust
impl TestWorkflowEnvironment {
    /// Queue a signal to be sent to the workflow when it starts
    pub fn signal_workflow(&mut self, signal_name: &str, data: Vec<u8>) {
        self.pending_signals
            .entry(signal_name.to_string())
            .or_insert_with(Vec::new)
            .push(data);
    }
}
```

**Tasks:**
- [ ] Add `signal_workflow` method to `TestWorkflowEnvironment`
- [ ] Remove `signal_workflow` from `TestWorkflowContext` (or keep for internal use)

### Phase 5: Create TestWorkflowContext Implementation

**File:** `cadence-testsuite/src/suite.rs`

Replace the stub `TestWorkflowContext` with a full implementation:

```rust
pub struct TestWorkflowContext {
    workflow_id: String,
    run_id: String,
    workflow_type: String,
    task_list: String,
    activities: HashMap<String, ActivityFn>, // Reference to environment's activities
    signals: HashMap<String, Vec<Vec<u8>>>,
    queries: HashMap<String, Box<dyn Fn(Vec<u8>) -> Vec<u8>>>,
    test_time: Arc<Mutex<TestTime>>,
    is_cancelled: bool,
}

impl TestWorkflowContext {
    pub fn workflow_info(&self) -> WorkflowInfo {
        WorkflowInfo {
            workflow_execution: WorkflowExecution::new(&self.workflow_id, &self.run_id),
            workflow_type: self.workflow_type.clone(),
            task_list: self.task_list.clone(),
            // ... other fields
        }
    }
    
    pub async fn execute_activity(
        &mut self,
        activity_type: &str,
        args: Option<Vec<u8>>,
        _options: ActivityOptions,
    ) -> Result<Vec<u8>, WorkflowError> {
        let activity = self.activities.get(activity_type)
            .ok_or_else(|| WorkflowError::ActivityFailed(
                format!("Activity '{}' not registered", activity_type)
            ))?;
        
        // Create ActivityInfo
        let activity_info = ActivityInfo {
            activity_id: format!("activity-{}", uuid::Uuid::new_v4()),
            activity_type: activity_type.to_string(),
            task_token: vec![],
            workflow_execution: WorkflowExecution::new(&self.workflow_id, &self.run_id),
            attempt: 1,
            scheduled_time: chrono::Utc::now(),
            started_time: chrono::Utc::now(),
            deadline: None,
            heartbeat_timeout: Duration::from_secs(0),
            heartbeat_details: None,
        };
        
        let ctx = ActivityContext::new(activity_info);
        let input = args.unwrap_or_default();
        
        activity(&ctx, input).await
            .map_err(|e| WorkflowError::ActivityFailed(format!("{:?}", e)))
    }
    
    pub fn get_signal_channel(&self, signal_name: &str) -> TestSignalChannel {
        let signals = self.signals.get(signal_name).cloned().unwrap_or_default();
        TestSignalChannel::new(signals)
    }
    
    pub async fn sleep(&self, duration: Duration) {
        // Advance test time instead of real sleep
        if let Ok(mut time) = self.test_time.lock() {
            time.advance(duration);
        }
    }
    
    pub fn now(&self) -> chrono::DateTime<chrono::Utc> {
        self.test_time.lock().map(|t| t.current_time).unwrap_or_else(|_| chrono::Utc::now())
    }
    
    pub fn is_cancelled(&self) -> bool {
        self.is_cancelled
    }
}
```

**Tasks:**
- [ ] Rewrite `TestWorkflowContext` with all required fields
- [ ] Implement `workflow_info()`
- [ ] Implement `execute_activity()` that looks up in environment registry
- [ ] Implement `get_signal_channel()` returning test channel
- [ ] Implement `sleep()` using test time
- [ ] Implement `now()` using test time
- [ ] Implement `is_cancelled()`
- [ ] Add other workflow context methods as needed

### Phase 6: Create TestSignalChannel

**File:** `cadence-testsuite/src/suite.rs`

```rust
pub struct TestSignalChannel {
    signals: Vec<Vec<u8>>,
    current_index: usize,
}

impl TestSignalChannel {
    fn new(signals: Vec<Vec<u8>>) -> Self {
        Self {
            signals,
            current_index: 0,
        }
    }
    
    pub async fn recv(&mut self) -> Option<Vec<u8>> {
        if self.current_index < self.signals.len() {
            let signal = self.signals[self.current_index].clone();
            self.current_index += 1;
            Some(signal)
        } else {
            // No more signals - would block in real implementation
            // For tests, return None immediately
            None
        }
    }
    
    pub fn try_recv(&mut self) -> Option<Vec<u8>> {
        self.recv().now_or_never().flatten()
    }
}
```

**Tasks:**
- [ ] Create `TestSignalChannel` struct
- [ ] Implement `recv()` method
- [ ] Implement `try_recv()` method

### Phase 7: Create TestActivityContext (Complete)

**File:** `cadence-testsuite/src/suite.rs`

The current `TestActivityContext` is a stub. Enhance it:

```rust
pub struct TestActivityContext {
    activity_info: ActivityInfo,
    recorded_heartbeats: Vec<Option<Vec<u8>>>,
}

impl TestActivityContext {
    pub fn record_heartbeat(&mut self, details: Option<&[u8]>) {
        self.recorded_heartbeats.push(details.map(|d| d.to_vec()));
    }
    
    pub fn has_heartbeat_details(&self) -> bool {
        self.activity_info.heartbeat_details.is_some()
    }
    
    pub fn get_heartbeat_details(&self) -> Option<&[u8]> {
        self.activity_info.heartbeat_details.as_deref()
    }
    
    pub fn get_info(&self) -> &ActivityInfo {
        &self.activity_info
    }
    
    pub fn is_cancelled(&self) -> bool {
        false // TODO: Check cancellation state
    }
    
    pub fn get_deadline(&self) -> Option<Instant> {
        self.activity_info.deadline
    }
}
```

**Tasks:**
- [ ] Add `activity_info` field to `TestActivityContext`
- [ ] Add `recorded_heartbeats` field for assertions
- [ ] Implement heartbeat recording
- [ ] Implement info getters

### Phase 8: Update execute_workflow to Wire Everything Together

**File:** `cadence-testsuite/src/suite.rs`

```rust
impl TestWorkflowEnvironment {
    pub async fn execute_workflow<I, O>(&mut self, name: &str, input: I) -> Result<O, WorkflowError>
    where
        I: Serialize,
        O: for<'de> Deserialize<'de>,
    {
        let input_bytes = serde_json::to_vec(&input)
            .map_err(|e| WorkflowError::Generic(format!("Input serialization: {}", e)))?;
        
        let workflow = self.registered_workflows.get(name)
            .ok_or_else(|| WorkflowError::Generic(format!("Workflow '{}' not registered", name)))?;
        
        // Create test context with environment's registries
        let mut ctx = TestWorkflowContext {
            workflow_id: self.workflow_id.clone(),
            run_id: self.run_id.clone(),
            workflow_type: name.to_string(),
            task_list: "test-task-list".to_string(),
            activities: self.registered_activities.clone(), // Share activity registry
            signals: self.pending_signals.clone(), // Copy pending signals
            queries: HashMap::new(),
            test_time: Arc::new(Mutex::new(self.test_time.clone())),
            is_cancelled: false,
        };
        
        // Clear pending signals after copying to context
        self.pending_signals.clear();
        
        // Execute workflow
        let result_bytes = workflow(&mut ctx, input_bytes).await?;
        
        // Deserialize result
        serde_json::from_slice(&result_bytes)
            .map_err(|e| WorkflowError::Generic(format!("Output deserialization: {}", e)))
    }
}
```

**Note:** This requires `TestWorkflowContext` to be passed to the workflow function, but workflows expect `WorkflowContext`. We need to either:
1. Make `TestWorkflowContext` compatible with `WorkflowContext` API
2. Use a trait that both implement
3. Update all examples to use `TestWorkflowContext`

**Decision:** Update registration to work with `TestWorkflowContext` and have examples use that.

### Phase 9: Execute Activity Method for Testing

**File:** `cadence-testsuite/src/suite.rs`

```rust
impl TestWorkflowEnvironment {
    /// Execute an activity directly for testing (without workflow)
    pub async fn execute_activity<I, O>(&self, name: &str, input: I) -> Result<O, ActivityError>
    where
        I: Serialize,
        O: for<'de> Deserialize<'de>,
    {
        let input_bytes = serde_json::to_vec(&input)
            .map_err(|e| ActivityError::Generic(format!("Input serialization: {}", e)))?;
        
        let activity = self.registered_activities.get(name)
            .ok_or_else(|| ActivityError::Generic(format!("Activity '{}' not registered", name)))?;
        
        // Create ActivityInfo
        let activity_info = ActivityInfo {
            activity_id: format!("test-activity-{}", uuid::Uuid::new_v4()),
            activity_type: name.to_string(),
            task_token: vec![],
            workflow_execution: WorkflowExecution::new(&self.workflow_id, &self.run_id),
            attempt: 1,
            scheduled_time: chrono::Utc::now(),
            started_time: chrono::Utc::now(),
            deadline: None,
            heartbeat_timeout: Duration::from_secs(0),
            heartbeat_details: None,
        };
        
        let ctx = ActivityContext::new(activity_info);
        
        let result_bytes = activity(&ctx, input_bytes).await?;
        
        serde_json::from_slice(&result_bytes)
            .map_err(|e| ActivityError::Generic(format!("Output deserialization: {}", e)))
    }
}
```

**Tasks:**
- [ ] Add `execute_activity` method to `TestWorkflowEnvironment`
- [ ] Allow direct activity execution for unit tests

### Phase 10: Add Test Assertion Helpers

**File:** `cadence-testsuite/src/suite.rs`

```rust
impl TestWorkflowEnvironment {
    /// Get list of executed activities (for assertions)
    pub fn get_executed_activities(&self) -> &[String] {
        &self.executed_activities
    }
    
    /// Check if an activity was executed
    pub fn was_activity_executed(&self, name: &str) -> bool {
        self.executed_activities.contains(&name.to_string())
    }
    
    /// Assert workflow completed successfully (helper)
    pub fn assert_workflow_completed<T>(result: &Result<T, WorkflowError>) {
        assert!(result.is_ok(), "Workflow should complete successfully: {:?}", result);
    }
}
```

**Tasks:**
- [ ] Add activity execution tracking
- [ ] Add assertion helper methods
- [ ] Add documentation

## Implementation Order

### Phase 1: Core Types and Registry (Files: suite.rs)
1. Add type aliases for WorkflowFn and ActivityFn
2. Add HashMap fields to TestWorkflowEnvironment
3. Update TestWorkflowEnvironment::new() to initialize fields

### Phase 2: Registration Methods (Files: suite.rs)
1. Rewrite register_workflow with generic signature
2. Rewrite register_activity with generic signature
3. Update all imports (serde, Pin, Box, etc.)

### Phase 3: TestWorkflowContext (Files: suite.rs)
1. Rewrite TestWorkflowContext struct
2. Implement workflow_info()
3. Implement execute_activity()
4. Implement get_signal_channel()
5. Implement sleep() and now()
6. Implement is_cancelled()

### Phase 4: TestSignalChannel (Files: suite.rs)
1. Create TestSignalChannel struct
2. Implement recv() and try_recv()

### Phase 5: execute_workflow Rewrite (Files: suite.rs)
1. Rewrite execute_workflow signature
2. Implement serialization/deserialization
3. Wire up TestWorkflowContext creation
4. Handle pending signals

### Phase 6: signal_workflow and execute_activity (Files: suite.rs)
1. Add signal_workflow to TestWorkflowEnvironment
2. Add execute_activity for direct activity testing

### Phase 7: TestActivityContext (Files: suite.rs)
1. Enhance TestActivityContext with ActivityInfo
2. Implement heartbeat tracking
3. Add getters for info

### Phase 8: Cleanup and Documentation (Files: suite.rs, lib.rs)
1. Remove old stub methods
2. Add comprehensive documentation
3. Add usage examples in doc comments
4. Update lib.rs exports

### Phase 9: Integration Testing (Files: all example main.rs files)
1. Fix example imports (use TestWorkflowContext instead of WorkflowContext in tests)
2. Update example workflow signatures if needed
3. Run cargo check on all examples

## Critical Files to Modify

1. `/home/carson/Documents/code/cadence-rust-client/cadence-testsuite/src/suite.rs` - Main implementation
2. `/home/carson/Documents/code/cadence-rust-client/cadence-testsuite/src/lib.rs` - Exports
3. `/home/carson/Documents/code/cadence-rust-client/cadence-testsuite/Cargo.toml` - Dependencies (add serde_json if missing)

## Examples That Need Updates After Implementation

After completing TestWorkflowEnvironment, these examples need their test sections updated:

- examples/01_hello_workflow/src/main.rs
- examples/02_activity_basics/src/main.rs
- examples/03_activity_advanced/src/main.rs
- examples/04_workflow_signals/src/main.rs
- examples/05_workflow_external/src/main.rs
- examples/06_child_workflows/src/main.rs
- ... (all 25 examples)

Each example's test section needs:
- Use `TestWorkflowContext` instead of `WorkflowContext` in workflow signatures for tests
- Or use the environment properly with registered workflows

## Verification Strategy

### Unit Tests for TestWorkflowEnvironment

Create tests in `cadence-testsuite/src/suite.rs`:

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_register_and_execute_workflow() {
        let mut env = TestWorkflowEnvironment::new();
        
        env.register_workflow("test_workflow", |ctx, input: String| async move {
            Ok(format!("Hello, {}!", input))
        });
        
        let result: Result<String, _> = env.execute_workflow("test_workflow", "World".to_string()).await;
        assert_eq!(result.unwrap(), "Hello, World!");
    }

    #[tokio::test]
    async fn test_register_and_execute_activity() {
        let mut env = TestWorkflowEnvironment::new();
        
        env.register_activity("test_activity", |ctx, input: i32| async move {
            Ok(input * 2)
        });
        
        let result: Result<i32, _> = env.execute_activity("test_activity", 21).await;
        assert_eq!(result.unwrap(), 42);
    }

    #[tokio::test]
    async fn test_signal_workflow() {
        let mut env = TestWorkflowEnvironment::new();
        
        env.register_workflow("signal_workflow", |ctx, _input: ()| async move {
            // Test signal reception
            Ok(())
        });
        
        env.signal_workflow("test_signal", vec![1, 2, 3]);
        let result: Result<(), _> = env.execute_workflow("signal_workflow", ()).await;
        assert!(result.is_ok());
    }
}
```

### Integration Tests

After implementation, verify with:

```bash
# Test the test suite itself
cargo test -p cadence-testsuite

# Check all examples compile
cargo check -p hello_workflow
cargo check -p activity_basics
# ... etc for all 25 examples

# Run example tests (may fail initially until examples are updated)
cargo test -p hello_workflow
cargo test -p activity_basics
```

## Design Decisions

### 1. Type Erasure via Box

**Decision:** Use `Box<dyn Fn(...) -> Pin<Box<dyn Future<...>>>>>` for registry storage.

**Rationale:** 
- Allows storing different workflow/activity types in same HashMap
- Acceptable performance overhead for testing
- Clean API for users (they just pass function references)

### 2. Serialization Layer

**Decision:** Automatically serialize/deserialize inputs/outputs using serde_json.

**Rationale:**
- Matches how real Cadence works (converts to bytes)
- Users can pass typed inputs, not just Vec<u8>
- Examples become cleaner

### 3. TestWorkflowContext vs WorkflowContext

**Decision:** Create `TestWorkflowContext` with same API as `WorkflowContext`.

**Rationale:**
- Real `WorkflowContext` is tied to production implementation
- Test version needs special behavior (test time, activity lookup, etc.)
- Easier to mock and control in tests

### 4. Signal Handling

**Decision:** Queue signals in environment, copy to context at workflow start.

**Rationale:**
- Allows pre-loading signals before workflow execution
- Signals persist for the workflow run
- Matches pattern in examples

## Success Criteria

1. ✅ `TestWorkflowEnvironment::register_workflow()` accepts async function with typed input/output
2. ✅ `TestWorkflowEnvironment::register_activity()` accepts async function with typed input/output
3. ✅ `TestWorkflowEnvironment::execute_workflow(name, input)` works with registered workflows
4. ✅ `TestWorkflowEnvironment::execute_activity(name, input)` works with registered activities
5. ✅ `TestWorkflowEnvironment::signal_workflow()` queues signals for workflow
6. ✅ `TestWorkflowContext::execute_activity()` looks up and executes registered activities
7. ✅ `TestWorkflowContext::get_signal_channel()` returns signals queued before execution
8. ✅ `TestWorkflowContext::sleep()` advances test time instead of real sleep
9. ✅ All 25 examples compile with the new API
10. ✅ Examples can register and execute workflows/activities in tests

## Estimated Effort

- **Phase 1-2 (Registry):** 2-3 hours
- **Phase 3 (TestWorkflowContext):** 4-6 hours
- **Phase 4-5 (Channels & Execution):** 3-4 hours
- **Phase 6-7 (Cleanup):** 2-3 hours
- **Phase 8 (Integration):** 3-4 hours
- **Total:** ~15-20 hours

## Risks and Mitigations

### Risk 1: Type complexity with Box<dyn>
**Mitigation:** Test thoroughly with different function signatures. Add compile-time tests.

### Risk 2: WorkflowContext API changes
**Mitigation:** Document which WorkflowContext methods are implemented. Add "unimplemented!()" for missing ones with clear messages.

### Risk 3: Example breakage
**Mitigation:** Update examples incrementally. Provide migration guide in documentation.

### Risk 4: Async lifetime issues
**Mitigation:** Use 'static bounds carefully. Test with complex async workflows.
