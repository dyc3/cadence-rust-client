// This file is @generated by prost-build.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HealthRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HealthResponse {
    #[prost(bool, tag = "1")]
    pub ok: bool,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod meta_api_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    #[derive(Debug, Clone)]
    pub struct MetaApiClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl MetaApiClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> MetaApiClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> MetaApiClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            MetaApiClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn health(
            &mut self,
            request: impl tonic::IntoRequest<super::HealthRequest>,
        ) -> std::result::Result<tonic::Response<super::HealthResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/uber.cadence.api.v1.MetaAPI/Health");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("uber.cadence.api.v1.MetaAPI", "Health"));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkflowExecution {
    #[prost(string, tag = "1")]
    pub workflow_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub run_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkflowType {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActivityType {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Payload {
    #[prost(bytes = "vec", tag = "1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Failure {
    #[prost(string, tag = "1")]
    pub reason: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub details: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Memo {
    #[prost(map = "string, message", tag = "1")]
    pub fields: ::std::collections::HashMap<::prost::alloc::string::String, Payload>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Header {
    #[prost(map = "string, message", tag = "1")]
    pub fields: ::std::collections::HashMap<::prost::alloc::string::String, Payload>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchAttributes {
    #[prost(map = "string, message", tag = "1")]
    pub indexed_fields: ::std::collections::HashMap<::prost::alloc::string::String, Payload>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataBlob {
    #[prost(enumeration = "EncodingType", tag = "1")]
    pub encoding_type: i32,
    #[prost(bytes = "vec", tag = "2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkerVersionInfo {
    #[prost(string, tag = "1")]
    pub r#impl: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub feature_version: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SupportedClientVersions {
    /// Indicates the highest Go SDK version server will accept requests from.
    #[prost(string, tag = "1")]
    pub go_sdk: ::prost::alloc::string::String,
    /// Indicates the highest Java SDK version server will accept requests from.
    #[prost(string, tag = "2")]
    pub java_sdk: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RetryPolicy {
    /// Interval of the first retry. If backoffCoefficient is 1.0 then it is used for all retries.
    #[prost(message, optional, tag = "1")]
    pub initial_interval: ::core::option::Option<::prost_types::Duration>,
    /// Coefficient used to calculate the next retry interval.
    /// The next retry interval is previous interval multiplied by the coefficient.
    /// Must be 1 or larger.
    #[prost(double, tag = "2")]
    pub backoff_coefficient: f64,
    /// Maximum interval between retries. Exponential backoff leads to interval increase.
    /// This value is the cap of the increase. Default is 100x of initial interval.
    #[prost(message, optional, tag = "3")]
    pub maximum_interval: ::core::option::Option<::prost_types::Duration>,
    /// Maximum number of attempts. When exceeded the retries stop even if not expired yet.
    /// Must be 1 or bigger. Default is unlimited.
    #[prost(int32, tag = "4")]
    pub maximum_attempts: i32,
    /// Non-Retryable errors. Will stop retrying if error type matches this list.
    #[prost(string, repeated, tag = "5")]
    pub non_retryable_error_reasons: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Expiration time for the whole retry process.
    #[prost(message, optional, tag = "6")]
    pub expiration_interval: ::core::option::Option<::prost_types::Duration>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IsolationGroupPartition {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "IsolationGroupState", tag = "2")]
    pub state: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IsolationGroupConfiguration {
    #[prost(message, repeated, tag = "1")]
    pub isolation_groups: ::prost::alloc::vec::Vec<IsolationGroupPartition>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AsyncWorkflowConfiguration {
    #[prost(bool, tag = "1")]
    pub enabled: bool,
    /// predefined_queue_name is the name of the predefined queue in cadence server config's asyncWorkflowQueues
    #[prost(string, tag = "2")]
    pub predefined_queue_name: ::prost::alloc::string::String,
    /// queue_type is the type of the queue if predefined_queue_name is not used
    #[prost(string, tag = "3")]
    pub queue_type: ::prost::alloc::string::String,
    /// queue_config is the configuration for the queue if predefined_queue_name is not used
    #[prost(message, optional, tag = "4")]
    pub queue_config: ::core::option::Option<DataBlob>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActiveClusterSelectionPolicy {
    /// todo (david.porter) to remove
    #[deprecated]
    #[prost(enumeration = "ActiveClusterSelectionStrategy", tag = "1")]
    pub strategy: i32,
    #[prost(message, optional, tag = "4")]
    pub cluster_attribute: ::core::option::Option<ClusterAttribute>,
    /// todo (david.porter) to remove
    #[prost(
        oneof = "active_cluster_selection_policy::StrategyConfig",
        tags = "2, 3"
    )]
    pub strategy_config: ::core::option::Option<active_cluster_selection_policy::StrategyConfig>,
}
/// Nested message and enum types in `ActiveClusterSelectionPolicy`.
pub mod active_cluster_selection_policy {
    /// todo (david.porter) to remove
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum StrategyConfig {
        /// Sticky region config is applicable if strategy is ACTIVE_CLUSTER_SELECTION_STRATEGY_REGION_STICKY
        /// This is the default strategy for active-active domains and region would be set to receiver cluster's region if not specified.
        #[prost(message, tag = "2")]
        ActiveClusterStickyRegionConfig(super::ActiveClusterStickyRegionConfig),
        /// External entity config is applicable if strategy is ACTIVE_CLUSTER_SELECTION_STRATEGY_EXTERNAL_ENTITY
        /// External entity type must be one of the supported types in active cluster manager. Custom ones can be added by implementing the corresponding interface.
        #[prost(message, tag = "3")]
        ActiveClusterExternalEntityConfig(super::ActiveClusterExternalEntityConfig),
    }
}
/// ClusterAttribute refers to a means of dividing the workflows in an active/active domain
/// for example, where they are started or some secondary attribute they're associated with
/// for example, in a start workflow request:
///
///    StartWorkflowRequest{
///      ActiveClusterSelectionPolicy: {
///        ClusterAttribute: {
///             Scope: "location",
///             Name: "Lisbon"
///         }
///      }
///    }
///
/// this means that this workflow will follow the failover pattern of Lisbon, as it's defined
/// in the domain.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClusterAttribute {
    #[prost(string, tag = "1")]
    pub scope: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
}
/// todo (david.porter) to remove as this is no longer used
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActiveClusterStickyRegionConfig {
    #[prost(string, tag = "1")]
    pub sticky_region: ::prost::alloc::string::String,
}
/// todo (david.porter) to remove as this is no longer used
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActiveClusterExternalEntityConfig {
    #[prost(string, tag = "1")]
    pub external_entity_type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub external_entity_key: ::prost::alloc::string::String,
}
/// PaginationOptions provides common options for paginated RPCs.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PaginationOptions {
    /// page_size configures the number of results to be returned as part of each page
    #[prost(int32, tag = "1")]
    pub page_size: i32,
    /// next_page_token should be provided from a previous response to fetch the next page.
    /// if empty, the first page will be returned.
    #[prost(bytes = "vec", tag = "2")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EncodingType {
    Invalid = 0,
    Thriftrw = 1,
    Json = 2,
    Proto3 = 3,
}
impl EncodingType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "ENCODING_TYPE_INVALID",
            Self::Thriftrw => "ENCODING_TYPE_THRIFTRW",
            Self::Json => "ENCODING_TYPE_JSON",
            Self::Proto3 => "ENCODING_TYPE_PROTO3",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ENCODING_TYPE_INVALID" => Some(Self::Invalid),
            "ENCODING_TYPE_THRIFTRW" => Some(Self::Thriftrw),
            "ENCODING_TYPE_JSON" => Some(Self::Json),
            "ENCODING_TYPE_PROTO3" => Some(Self::Proto3),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IsolationGroupState {
    Invalid = 0,
    Healthy = 1,
    Drained = 2,
}
impl IsolationGroupState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "ISOLATION_GROUP_STATE_INVALID",
            Self::Healthy => "ISOLATION_GROUP_STATE_HEALTHY",
            Self::Drained => "ISOLATION_GROUP_STATE_DRAINED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ISOLATION_GROUP_STATE_INVALID" => Some(Self::Invalid),
            "ISOLATION_GROUP_STATE_HEALTHY" => Some(Self::Healthy),
            "ISOLATION_GROUP_STATE_DRAINED" => Some(Self::Drained),
            _ => None,
        }
    }
}
/// todo (david.porter) to remove as this is no longer used
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ActiveClusterSelectionStrategy {
    Invalid = 0,
    RegionSticky = 1,
    ExternalEntity = 2,
}
impl ActiveClusterSelectionStrategy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "ACTIVE_CLUSTER_SELECTION_STRATEGY_INVALID",
            Self::RegionSticky => "ACTIVE_CLUSTER_SELECTION_STRATEGY_REGION_STICKY",
            Self::ExternalEntity => "ACTIVE_CLUSTER_SELECTION_STRATEGY_EXTERNAL_ENTITY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ACTIVE_CLUSTER_SELECTION_STRATEGY_INVALID" => Some(Self::Invalid),
            "ACTIVE_CLUSTER_SELECTION_STRATEGY_REGION_STICKY" => Some(Self::RegionSticky),
            "ACTIVE_CLUSTER_SELECTION_STRATEGY_EXTERNAL_ENTITY" => Some(Self::ExternalEntity),
            _ => None,
        }
    }
}
/// FailoverType describes how a failover operation will be performed.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FailoverType {
    Invalid = 0,
    Force = 1,
    Graceful = 2,
}
impl FailoverType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "FAILOVER_TYPE_INVALID",
            Self::Force => "FAILOVER_TYPE_FORCE",
            Self::Graceful => "FAILOVER_TYPE_GRACEFUL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FAILOVER_TYPE_INVALID" => Some(Self::Invalid),
            "FAILOVER_TYPE_FORCE" => Some(Self::Force),
            "FAILOVER_TYPE_GRACEFUL" => Some(Self::Graceful),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskList {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "TaskListKind", tag = "2")]
    pub kind: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TaskListMetadata {
    #[prost(message, optional, tag = "1")]
    pub max_tasks_per_second: ::core::option::Option<f64>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskListPartitionMetadata {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub owner_host_name: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IsolationGroupMetrics {
    /// The rate at which tasks with the given isolation group are being added to this partition
    #[prost(double, tag = "1")]
    pub new_tasks_per_second: f64,
    /// The number of "active" pollers with the given isolation group that the partition is aware of.
    /// Pollers typically will reach many partitions
    #[prost(int64, tag = "2")]
    pub poller_count: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskListStatus {
    #[prost(int64, tag = "1")]
    pub backlog_count_hint: i64,
    #[prost(int64, tag = "2")]
    pub read_level: i64,
    #[prost(int64, tag = "3")]
    pub ack_level: i64,
    /// The rate at which tasks may be dispatched according to poller configuration
    #[prost(double, tag = "4")]
    pub rate_per_second: f64,
    #[prost(message, optional, tag = "5")]
    pub task_id_block: ::core::option::Option<TaskIdBlock>,
    /// Mapping of isolation groups to metrics about that group within this partition
    #[prost(map = "string, message", tag = "6")]
    pub isolation_group_metrics:
        ::std::collections::HashMap<::prost::alloc::string::String, IsolationGroupMetrics>,
    /// The rate at which tasks are being added to this partition
    #[prost(double, tag = "7")]
    pub new_tasks_per_second: f64,
    /// Whether the TaskList has any remaining Tasks
    #[prost(bool, tag = "8")]
    pub empty: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TaskIdBlock {
    #[prost(int64, tag = "1")]
    pub start_id: i64,
    #[prost(int64, tag = "2")]
    pub end_id: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PollerInfo {
    #[prost(message, optional, tag = "1")]
    pub last_access_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "2")]
    pub identity: ::prost::alloc::string::String,
    #[prost(double, tag = "3")]
    pub rate_per_second: f64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StickyExecutionAttributes {
    #[prost(message, optional, tag = "1")]
    pub worker_task_list: ::core::option::Option<TaskList>,
    #[prost(message, optional, tag = "2")]
    pub schedule_to_start_timeout: ::core::option::Option<::prost_types::Duration>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskListPartition {
    /// The isolation groups that this partition is assigned.
    /// Null/empty indicates that the partition should accept all isolation groups.
    #[prost(string, repeated, tag = "1")]
    pub isolation_groups: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskListPartitionConfig {
    #[prost(int64, tag = "1")]
    pub version: i64,
    #[deprecated]
    #[prost(int32, tag = "2")]
    pub num_read_partitions: i32,
    #[deprecated]
    #[prost(int32, tag = "3")]
    pub num_write_partitions: i32,
    /// Mapping of TaskList PartitionIDs to metadata for reading tasks
    #[prost(map = "int32, message", tag = "4")]
    pub read_partitions: ::std::collections::HashMap<i32, TaskListPartition>,
    /// Mapping of TaskList PartitionIDs to metadata for writing tasks
    #[prost(map = "int32, message", tag = "5")]
    pub write_partitions: ::std::collections::HashMap<i32, TaskListPartition>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TaskListKind {
    Invalid = 0,
    Normal = 1,
    Sticky = 2,
    Ephemeral = 3,
}
impl TaskListKind {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "TASK_LIST_KIND_INVALID",
            Self::Normal => "TASK_LIST_KIND_NORMAL",
            Self::Sticky => "TASK_LIST_KIND_STICKY",
            Self::Ephemeral => "TASK_LIST_KIND_EPHEMERAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TASK_LIST_KIND_INVALID" => Some(Self::Invalid),
            "TASK_LIST_KIND_NORMAL" => Some(Self::Normal),
            "TASK_LIST_KIND_STICKY" => Some(Self::Sticky),
            "TASK_LIST_KIND_EPHEMERAL" => Some(Self::Ephemeral),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TaskListType {
    Invalid = 0,
    Decision = 1,
    Activity = 2,
}
impl TaskListType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "TASK_LIST_TYPE_INVALID",
            Self::Decision => "TASK_LIST_TYPE_DECISION",
            Self::Activity => "TASK_LIST_TYPE_ACTIVITY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TASK_LIST_TYPE_INVALID" => Some(Self::Invalid),
            "TASK_LIST_TYPE_DECISION" => Some(Self::Decision),
            "TASK_LIST_TYPE_ACTIVITY" => Some(Self::Activity),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkflowExecutionInfo {
    #[prost(message, optional, tag = "1")]
    pub workflow_execution: ::core::option::Option<WorkflowExecution>,
    #[prost(message, optional, tag = "2")]
    pub r#type: ::core::option::Option<WorkflowType>,
    #[prost(message, optional, tag = "3")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub close_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration = "WorkflowExecutionCloseStatus", tag = "5")]
    pub close_status: i32,
    #[prost(int64, tag = "6")]
    pub history_length: i64,
    #[prost(message, optional, tag = "7")]
    pub parent_execution_info: ::core::option::Option<ParentExecutionInfo>,
    #[prost(message, optional, tag = "8")]
    pub execution_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub memo: ::core::option::Option<Memo>,
    #[prost(message, optional, tag = "10")]
    pub search_attributes: ::core::option::Option<SearchAttributes>,
    #[prost(message, optional, tag = "11")]
    pub auto_reset_points: ::core::option::Option<ResetPoints>,
    #[prost(string, tag = "12")]
    pub task_list: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "17")]
    pub task_list_info: ::core::option::Option<TaskList>,
    #[prost(bool, tag = "13")]
    pub is_cron: bool,
    #[prost(message, optional, tag = "14")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "15")]
    pub partition_config:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    #[prost(enumeration = "CronOverlapPolicy", tag = "16")]
    pub cron_overlap_policy: i32,
    #[prost(message, optional, tag = "18")]
    pub active_cluster_selection_policy: ::core::option::Option<ActiveClusterSelectionPolicy>,
    #[prost(string, tag = "19")]
    pub cron_schedule: ::prost::alloc::string::String,
    #[prost(enumeration = "WorkflowExecutionStatus", tag = "20")]
    pub execution_status: i32,
    #[prost(message, optional, tag = "21")]
    pub scheduled_execution_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkflowExecutionConfiguration {
    #[prost(message, optional, tag = "1")]
    pub task_list: ::core::option::Option<TaskList>,
    #[prost(message, optional, tag = "2")]
    pub execution_start_to_close_timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "3")]
    pub task_start_to_close_timeout: ::core::option::Option<::prost_types::Duration>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParentExecutionInfo {
    #[prost(string, tag = "1")]
    pub domain_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub domain_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub workflow_execution: ::core::option::Option<WorkflowExecution>,
    #[prost(int64, tag = "4")]
    pub initiated_id: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExternalExecutionInfo {
    #[prost(message, optional, tag = "1")]
    pub workflow_execution: ::core::option::Option<WorkflowExecution>,
    #[prost(int64, tag = "2")]
    pub initiated_id: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PendingActivityInfo {
    #[prost(string, tag = "1")]
    pub activity_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub activity_type: ::core::option::Option<ActivityType>,
    #[prost(enumeration = "PendingActivityState", tag = "3")]
    pub state: i32,
    #[prost(message, optional, tag = "4")]
    pub heartbeat_details: ::core::option::Option<Payload>,
    #[prost(message, optional, tag = "5")]
    pub last_heartbeat_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub last_started_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(int32, tag = "7")]
    pub attempt: i32,
    #[prost(int32, tag = "8")]
    pub maximum_attempts: i32,
    #[prost(message, optional, tag = "9")]
    pub scheduled_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "10")]
    pub expiration_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "11")]
    pub last_failure: ::core::option::Option<Failure>,
    #[prost(string, tag = "12")]
    pub last_worker_identity: ::prost::alloc::string::String,
    #[prost(string, tag = "13")]
    pub started_worker_identity: ::prost::alloc::string::String,
    #[prost(int64, tag = "14")]
    pub schedule_id: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PendingChildExecutionInfo {
    #[prost(message, optional, tag = "1")]
    pub workflow_execution: ::core::option::Option<WorkflowExecution>,
    #[prost(string, tag = "2")]
    pub workflow_type_name: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub initiated_id: i64,
    #[prost(enumeration = "ParentClosePolicy", tag = "4")]
    pub parent_close_policy: i32,
    #[prost(string, tag = "5")]
    pub domain: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PendingDecisionInfo {
    #[prost(enumeration = "PendingDecisionState", tag = "1")]
    pub state: i32,
    #[prost(message, optional, tag = "2")]
    pub scheduled_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub started_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(int32, tag = "4")]
    pub attempt: i32,
    #[prost(message, optional, tag = "5")]
    pub original_scheduled_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(int64, tag = "6")]
    pub schedule_id: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActivityLocalDispatchInfo {
    #[prost(string, tag = "1")]
    pub activity_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub scheduled_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub started_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub scheduled_time_of_this_attempt: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(bytes = "vec", tag = "5")]
    pub task_token: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResetPoints {
    #[prost(message, repeated, tag = "1")]
    pub points: ::prost::alloc::vec::Vec<ResetPointInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResetPointInfo {
    #[prost(string, tag = "1")]
    pub binary_checksum: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub run_id: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub first_decision_completed_id: i64,
    #[prost(message, optional, tag = "4")]
    pub created_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "5")]
    pub expiring_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(bool, tag = "6")]
    pub resettable: bool,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PendingActivityState {
    Invalid = 0,
    Scheduled = 1,
    Started = 2,
    CancelRequested = 3,
}
impl PendingActivityState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "PENDING_ACTIVITY_STATE_INVALID",
            Self::Scheduled => "PENDING_ACTIVITY_STATE_SCHEDULED",
            Self::Started => "PENDING_ACTIVITY_STATE_STARTED",
            Self::CancelRequested => "PENDING_ACTIVITY_STATE_CANCEL_REQUESTED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PENDING_ACTIVITY_STATE_INVALID" => Some(Self::Invalid),
            "PENDING_ACTIVITY_STATE_SCHEDULED" => Some(Self::Scheduled),
            "PENDING_ACTIVITY_STATE_STARTED" => Some(Self::Started),
            "PENDING_ACTIVITY_STATE_CANCEL_REQUESTED" => Some(Self::CancelRequested),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PendingDecisionState {
    Invalid = 0,
    Scheduled = 1,
    Started = 2,
}
impl PendingDecisionState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "PENDING_DECISION_STATE_INVALID",
            Self::Scheduled => "PENDING_DECISION_STATE_SCHEDULED",
            Self::Started => "PENDING_DECISION_STATE_STARTED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PENDING_DECISION_STATE_INVALID" => Some(Self::Invalid),
            "PENDING_DECISION_STATE_SCHEDULED" => Some(Self::Scheduled),
            "PENDING_DECISION_STATE_STARTED" => Some(Self::Started),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WorkflowIdReusePolicy {
    Invalid = 0,
    /// Allow start a workflow execution using the same workflow ID,
    /// when workflow not running, and the last execution close state is in \[terminated, cancelled, timeouted, failed\].
    AllowDuplicateFailedOnly = 1,
    /// Allow start a workflow execution using the same workflow ID, when workflow not running.
    AllowDuplicate = 2,
    /// Do not allow start a workflow execution using the same workflow ID at all.
    RejectDuplicate = 3,
    /// If a workflow is running using the same workflow ID, terminate it and start a new one.
    TerminateIfRunning = 4,
}
impl WorkflowIdReusePolicy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "WORKFLOW_ID_REUSE_POLICY_INVALID",
            Self::AllowDuplicateFailedOnly => {
                "WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY"
            }
            Self::AllowDuplicate => "WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE",
            Self::RejectDuplicate => "WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE",
            Self::TerminateIfRunning => "WORKFLOW_ID_REUSE_POLICY_TERMINATE_IF_RUNNING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "WORKFLOW_ID_REUSE_POLICY_INVALID" => Some(Self::Invalid),
            "WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY" => {
                Some(Self::AllowDuplicateFailedOnly)
            }
            "WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE" => Some(Self::AllowDuplicate),
            "WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE" => Some(Self::RejectDuplicate),
            "WORKFLOW_ID_REUSE_POLICY_TERMINATE_IF_RUNNING" => Some(Self::TerminateIfRunning),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CronOverlapPolicy {
    Invalid = 0,
    Skipped = 1,
    BufferOne = 2,
}
impl CronOverlapPolicy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "CRON_OVERLAP_POLICY_INVALID",
            Self::Skipped => "CRON_OVERLAP_POLICY_SKIPPED",
            Self::BufferOne => "CRON_OVERLAP_POLICY_BUFFER_ONE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CRON_OVERLAP_POLICY_INVALID" => Some(Self::Invalid),
            "CRON_OVERLAP_POLICY_SKIPPED" => Some(Self::Skipped),
            "CRON_OVERLAP_POLICY_BUFFER_ONE" => Some(Self::BufferOne),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ParentClosePolicy {
    Invalid = 0,
    /// Abandon means not doing anything on the child workflow.
    Abandon = 1,
    /// Cancel means requesting cancellation on the child workflow.
    RequestCancel = 2,
    /// Terminate means terminating the child workflow.
    Terminate = 3,
}
impl ParentClosePolicy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "PARENT_CLOSE_POLICY_INVALID",
            Self::Abandon => "PARENT_CLOSE_POLICY_ABANDON",
            Self::RequestCancel => "PARENT_CLOSE_POLICY_REQUEST_CANCEL",
            Self::Terminate => "PARENT_CLOSE_POLICY_TERMINATE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PARENT_CLOSE_POLICY_INVALID" => Some(Self::Invalid),
            "PARENT_CLOSE_POLICY_ABANDON" => Some(Self::Abandon),
            "PARENT_CLOSE_POLICY_REQUEST_CANCEL" => Some(Self::RequestCancel),
            "PARENT_CLOSE_POLICY_TERMINATE" => Some(Self::Terminate),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WorkflowExecutionCloseStatus {
    Invalid = 0,
    Completed = 1,
    Failed = 2,
    Canceled = 3,
    Terminated = 4,
    ContinuedAsNew = 5,
    TimedOut = 6,
}
impl WorkflowExecutionCloseStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "WORKFLOW_EXECUTION_CLOSE_STATUS_INVALID",
            Self::Completed => "WORKFLOW_EXECUTION_CLOSE_STATUS_COMPLETED",
            Self::Failed => "WORKFLOW_EXECUTION_CLOSE_STATUS_FAILED",
            Self::Canceled => "WORKFLOW_EXECUTION_CLOSE_STATUS_CANCELED",
            Self::Terminated => "WORKFLOW_EXECUTION_CLOSE_STATUS_TERMINATED",
            Self::ContinuedAsNew => "WORKFLOW_EXECUTION_CLOSE_STATUS_CONTINUED_AS_NEW",
            Self::TimedOut => "WORKFLOW_EXECUTION_CLOSE_STATUS_TIMED_OUT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "WORKFLOW_EXECUTION_CLOSE_STATUS_INVALID" => Some(Self::Invalid),
            "WORKFLOW_EXECUTION_CLOSE_STATUS_COMPLETED" => Some(Self::Completed),
            "WORKFLOW_EXECUTION_CLOSE_STATUS_FAILED" => Some(Self::Failed),
            "WORKFLOW_EXECUTION_CLOSE_STATUS_CANCELED" => Some(Self::Canceled),
            "WORKFLOW_EXECUTION_CLOSE_STATUS_TERMINATED" => Some(Self::Terminated),
            "WORKFLOW_EXECUTION_CLOSE_STATUS_CONTINUED_AS_NEW" => Some(Self::ContinuedAsNew),
            "WORKFLOW_EXECUTION_CLOSE_STATUS_TIMED_OUT" => Some(Self::TimedOut),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WorkflowExecutionStatus {
    Invalid = 0,
    Pending = 1,
    Started = 2,
    Completed = 3,
    Failed = 4,
    Canceled = 5,
    Terminated = 6,
    ContinuedAsNew = 7,
    TimedOut = 8,
}
impl WorkflowExecutionStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "WORKFLOW_EXECUTION_STATUS_INVALID",
            Self::Pending => "WORKFLOW_EXECUTION_STATUS_PENDING",
            Self::Started => "WORKFLOW_EXECUTION_STATUS_STARTED",
            Self::Completed => "WORKFLOW_EXECUTION_STATUS_COMPLETED",
            Self::Failed => "WORKFLOW_EXECUTION_STATUS_FAILED",
            Self::Canceled => "WORKFLOW_EXECUTION_STATUS_CANCELED",
            Self::Terminated => "WORKFLOW_EXECUTION_STATUS_TERMINATED",
            Self::ContinuedAsNew => "WORKFLOW_EXECUTION_STATUS_CONTINUED_AS_NEW",
            Self::TimedOut => "WORKFLOW_EXECUTION_STATUS_TIMED_OUT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "WORKFLOW_EXECUTION_STATUS_INVALID" => Some(Self::Invalid),
            "WORKFLOW_EXECUTION_STATUS_PENDING" => Some(Self::Pending),
            "WORKFLOW_EXECUTION_STATUS_STARTED" => Some(Self::Started),
            "WORKFLOW_EXECUTION_STATUS_COMPLETED" => Some(Self::Completed),
            "WORKFLOW_EXECUTION_STATUS_FAILED" => Some(Self::Failed),
            "WORKFLOW_EXECUTION_STATUS_CANCELED" => Some(Self::Canceled),
            "WORKFLOW_EXECUTION_STATUS_TERMINATED" => Some(Self::Terminated),
            "WORKFLOW_EXECUTION_STATUS_CONTINUED_AS_NEW" => Some(Self::ContinuedAsNew),
            "WORKFLOW_EXECUTION_STATUS_TIMED_OUT" => Some(Self::TimedOut),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ContinueAsNewInitiator {
    Invalid = 0,
    Decider = 1,
    RetryPolicy = 2,
    CronSchedule = 3,
}
impl ContinueAsNewInitiator {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "CONTINUE_AS_NEW_INITIATOR_INVALID",
            Self::Decider => "CONTINUE_AS_NEW_INITIATOR_DECIDER",
            Self::RetryPolicy => "CONTINUE_AS_NEW_INITIATOR_RETRY_POLICY",
            Self::CronSchedule => "CONTINUE_AS_NEW_INITIATOR_CRON_SCHEDULE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CONTINUE_AS_NEW_INITIATOR_INVALID" => Some(Self::Invalid),
            "CONTINUE_AS_NEW_INITIATOR_DECIDER" => Some(Self::Decider),
            "CONTINUE_AS_NEW_INITIATOR_RETRY_POLICY" => Some(Self::RetryPolicy),
            "CONTINUE_AS_NEW_INITIATOR_CRON_SCHEDULE" => Some(Self::CronSchedule),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TimeoutType {
    Invalid = 0,
    StartToClose = 1,
    ScheduleToStart = 2,
    ScheduleToClose = 3,
    Heartbeat = 4,
}
impl TimeoutType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "TIMEOUT_TYPE_INVALID",
            Self::StartToClose => "TIMEOUT_TYPE_START_TO_CLOSE",
            Self::ScheduleToStart => "TIMEOUT_TYPE_SCHEDULE_TO_START",
            Self::ScheduleToClose => "TIMEOUT_TYPE_SCHEDULE_TO_CLOSE",
            Self::Heartbeat => "TIMEOUT_TYPE_HEARTBEAT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TIMEOUT_TYPE_INVALID" => Some(Self::Invalid),
            "TIMEOUT_TYPE_START_TO_CLOSE" => Some(Self::StartToClose),
            "TIMEOUT_TYPE_SCHEDULE_TO_START" => Some(Self::ScheduleToStart),
            "TIMEOUT_TYPE_SCHEDULE_TO_CLOSE" => Some(Self::ScheduleToClose),
            "TIMEOUT_TYPE_HEARTBEAT" => Some(Self::Heartbeat),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DecisionTaskTimedOutCause {
    Invalid = 0,
    Timeout = 1,
    Reset = 2,
}
impl DecisionTaskTimedOutCause {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "DECISION_TASK_TIMED_OUT_CAUSE_INVALID",
            Self::Timeout => "DECISION_TASK_TIMED_OUT_CAUSE_TIMEOUT",
            Self::Reset => "DECISION_TASK_TIMED_OUT_CAUSE_RESET",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DECISION_TASK_TIMED_OUT_CAUSE_INVALID" => Some(Self::Invalid),
            "DECISION_TASK_TIMED_OUT_CAUSE_TIMEOUT" => Some(Self::Timeout),
            "DECISION_TASK_TIMED_OUT_CAUSE_RESET" => Some(Self::Reset),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DecisionTaskFailedCause {
    Invalid = 0,
    UnhandledDecision = 1,
    BadScheduleActivityAttributes = 2,
    BadRequestCancelActivityAttributes = 3,
    BadStartTimerAttributes = 4,
    BadCancelTimerAttributes = 5,
    BadRecordMarkerAttributes = 6,
    BadCompleteWorkflowExecutionAttributes = 7,
    BadFailWorkflowExecutionAttributes = 8,
    BadCancelWorkflowExecutionAttributes = 9,
    BadRequestCancelExternalWorkflowExecutionAttributes = 10,
    BadContinueAsNewAttributes = 11,
    StartTimerDuplicateId = 12,
    ResetStickyTaskList = 13,
    WorkflowWorkerUnhandledFailure = 14,
    BadSignalWorkflowExecutionAttributes = 15,
    BadStartChildExecutionAttributes = 16,
    ForceCloseDecision = 17,
    FailoverCloseDecision = 18,
    BadSignalInputSize = 19,
    ResetWorkflow = 20,
    BadBinary = 21,
    ScheduleActivityDuplicateId = 22,
    BadSearchAttributes = 23,
}
impl DecisionTaskFailedCause {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "DECISION_TASK_FAILED_CAUSE_INVALID",
            Self::UnhandledDecision => "DECISION_TASK_FAILED_CAUSE_UNHANDLED_DECISION",
            Self::BadScheduleActivityAttributes => {
                "DECISION_TASK_FAILED_CAUSE_BAD_SCHEDULE_ACTIVITY_ATTRIBUTES"
            }
            Self::BadRequestCancelActivityAttributes => {
                "DECISION_TASK_FAILED_CAUSE_BAD_REQUEST_CANCEL_ACTIVITY_ATTRIBUTES"
            }
            Self::BadStartTimerAttributes => {
                "DECISION_TASK_FAILED_CAUSE_BAD_START_TIMER_ATTRIBUTES"
            }
            Self::BadCancelTimerAttributes => {
                "DECISION_TASK_FAILED_CAUSE_BAD_CANCEL_TIMER_ATTRIBUTES"
            }
            Self::BadRecordMarkerAttributes => {
                "DECISION_TASK_FAILED_CAUSE_BAD_RECORD_MARKER_ATTRIBUTES"
            }
            Self::BadCompleteWorkflowExecutionAttributes => {
                "DECISION_TASK_FAILED_CAUSE_BAD_COMPLETE_WORKFLOW_EXECUTION_ATTRIBUTES"
            }
            Self::BadFailWorkflowExecutionAttributes => {
                "DECISION_TASK_FAILED_CAUSE_BAD_FAIL_WORKFLOW_EXECUTION_ATTRIBUTES"
            }
            Self::BadCancelWorkflowExecutionAttributes => {
                "DECISION_TASK_FAILED_CAUSE_BAD_CANCEL_WORKFLOW_EXECUTION_ATTRIBUTES"
            }
            Self::BadRequestCancelExternalWorkflowExecutionAttributes => {
                "DECISION_TASK_FAILED_CAUSE_BAD_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_ATTRIBUTES"
            }
            Self::BadContinueAsNewAttributes => {
                "DECISION_TASK_FAILED_CAUSE_BAD_CONTINUE_AS_NEW_ATTRIBUTES"
            }
            Self::StartTimerDuplicateId => {
                "DECISION_TASK_FAILED_CAUSE_START_TIMER_DUPLICATE_ID"
            }
            Self::ResetStickyTaskList => {
                "DECISION_TASK_FAILED_CAUSE_RESET_STICKY_TASK_LIST"
            }
            Self::WorkflowWorkerUnhandledFailure => {
                "DECISION_TASK_FAILED_CAUSE_WORKFLOW_WORKER_UNHANDLED_FAILURE"
            }
            Self::BadSignalWorkflowExecutionAttributes => {
                "DECISION_TASK_FAILED_CAUSE_BAD_SIGNAL_WORKFLOW_EXECUTION_ATTRIBUTES"
            }
            Self::BadStartChildExecutionAttributes => {
                "DECISION_TASK_FAILED_CAUSE_BAD_START_CHILD_EXECUTION_ATTRIBUTES"
            }
            Self::ForceCloseDecision => "DECISION_TASK_FAILED_CAUSE_FORCE_CLOSE_DECISION",
            Self::FailoverCloseDecision => {
                "DECISION_TASK_FAILED_CAUSE_FAILOVER_CLOSE_DECISION"
            }
            Self::BadSignalInputSize => {
                "DECISION_TASK_FAILED_CAUSE_BAD_SIGNAL_INPUT_SIZE"
            }
            Self::ResetWorkflow => "DECISION_TASK_FAILED_CAUSE_RESET_WORKFLOW",
            Self::BadBinary => "DECISION_TASK_FAILED_CAUSE_BAD_BINARY",
            Self::ScheduleActivityDuplicateId => {
                "DECISION_TASK_FAILED_CAUSE_SCHEDULE_ACTIVITY_DUPLICATE_ID"
            }
            Self::BadSearchAttributes => {
                "DECISION_TASK_FAILED_CAUSE_BAD_SEARCH_ATTRIBUTES"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DECISION_TASK_FAILED_CAUSE_INVALID" => Some(Self::Invalid),
            "DECISION_TASK_FAILED_CAUSE_UNHANDLED_DECISION" => {
                Some(Self::UnhandledDecision)
            }
            "DECISION_TASK_FAILED_CAUSE_BAD_SCHEDULE_ACTIVITY_ATTRIBUTES" => {
                Some(Self::BadScheduleActivityAttributes)
            }
            "DECISION_TASK_FAILED_CAUSE_BAD_REQUEST_CANCEL_ACTIVITY_ATTRIBUTES" => {
                Some(Self::BadRequestCancelActivityAttributes)
            }
            "DECISION_TASK_FAILED_CAUSE_BAD_START_TIMER_ATTRIBUTES" => {
                Some(Self::BadStartTimerAttributes)
            }
            "DECISION_TASK_FAILED_CAUSE_BAD_CANCEL_TIMER_ATTRIBUTES" => {
                Some(Self::BadCancelTimerAttributes)
            }
            "DECISION_TASK_FAILED_CAUSE_BAD_RECORD_MARKER_ATTRIBUTES" => {
                Some(Self::BadRecordMarkerAttributes)
            }
            "DECISION_TASK_FAILED_CAUSE_BAD_COMPLETE_WORKFLOW_EXECUTION_ATTRIBUTES" => {
                Some(Self::BadCompleteWorkflowExecutionAttributes)
            }
            "DECISION_TASK_FAILED_CAUSE_BAD_FAIL_WORKFLOW_EXECUTION_ATTRIBUTES" => {
                Some(Self::BadFailWorkflowExecutionAttributes)
            }
            "DECISION_TASK_FAILED_CAUSE_BAD_CANCEL_WORKFLOW_EXECUTION_ATTRIBUTES" => {
                Some(Self::BadCancelWorkflowExecutionAttributes)
            }
            "DECISION_TASK_FAILED_CAUSE_BAD_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_ATTRIBUTES" => {
                Some(Self::BadRequestCancelExternalWorkflowExecutionAttributes)
            }
            "DECISION_TASK_FAILED_CAUSE_BAD_CONTINUE_AS_NEW_ATTRIBUTES" => {
                Some(Self::BadContinueAsNewAttributes)
            }
            "DECISION_TASK_FAILED_CAUSE_START_TIMER_DUPLICATE_ID" => {
                Some(Self::StartTimerDuplicateId)
            }
            "DECISION_TASK_FAILED_CAUSE_RESET_STICKY_TASK_LIST" => {
                Some(Self::ResetStickyTaskList)
            }
            "DECISION_TASK_FAILED_CAUSE_WORKFLOW_WORKER_UNHANDLED_FAILURE" => {
                Some(Self::WorkflowWorkerUnhandledFailure)
            }
            "DECISION_TASK_FAILED_CAUSE_BAD_SIGNAL_WORKFLOW_EXECUTION_ATTRIBUTES" => {
                Some(Self::BadSignalWorkflowExecutionAttributes)
            }
            "DECISION_TASK_FAILED_CAUSE_BAD_START_CHILD_EXECUTION_ATTRIBUTES" => {
                Some(Self::BadStartChildExecutionAttributes)
            }
            "DECISION_TASK_FAILED_CAUSE_FORCE_CLOSE_DECISION" => {
                Some(Self::ForceCloseDecision)
            }
            "DECISION_TASK_FAILED_CAUSE_FAILOVER_CLOSE_DECISION" => {
                Some(Self::FailoverCloseDecision)
            }
            "DECISION_TASK_FAILED_CAUSE_BAD_SIGNAL_INPUT_SIZE" => {
                Some(Self::BadSignalInputSize)
            }
            "DECISION_TASK_FAILED_CAUSE_RESET_WORKFLOW" => Some(Self::ResetWorkflow),
            "DECISION_TASK_FAILED_CAUSE_BAD_BINARY" => Some(Self::BadBinary),
            "DECISION_TASK_FAILED_CAUSE_SCHEDULE_ACTIVITY_DUPLICATE_ID" => {
                Some(Self::ScheduleActivityDuplicateId)
            }
            "DECISION_TASK_FAILED_CAUSE_BAD_SEARCH_ATTRIBUTES" => {
                Some(Self::BadSearchAttributes)
            }
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ChildWorkflowExecutionFailedCause {
    Invalid = 0,
    WorkflowAlreadyRunning = 1,
}
impl ChildWorkflowExecutionFailedCause {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_INVALID",
            Self::WorkflowAlreadyRunning => {
                "CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_WORKFLOW_ALREADY_RUNNING"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_INVALID" => Some(Self::Invalid),
            "CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_WORKFLOW_ALREADY_RUNNING" => {
                Some(Self::WorkflowAlreadyRunning)
            }
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CancelExternalWorkflowExecutionFailedCause {
    Invalid = 0,
    UnknownExternalWorkflowExecution = 1,
    WorkflowAlreadyCompleted = 2,
}
impl CancelExternalWorkflowExecutionFailedCause {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_INVALID",
            Self::UnknownExternalWorkflowExecution => {
                "CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_UNKNOWN_EXTERNAL_WORKFLOW_EXECUTION"
            }
            Self::WorkflowAlreadyCompleted => {
                "CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_WORKFLOW_ALREADY_COMPLETED"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_INVALID" => {
                Some(Self::Invalid)
            }
            "CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_UNKNOWN_EXTERNAL_WORKFLOW_EXECUTION" => {
                Some(Self::UnknownExternalWorkflowExecution)
            }
            "CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_WORKFLOW_ALREADY_COMPLETED" => {
                Some(Self::WorkflowAlreadyCompleted)
            }
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SignalExternalWorkflowExecutionFailedCause {
    Invalid = 0,
    UnknownExternalWorkflowExecution = 1,
    WorkflowAlreadyCompleted = 2,
}
impl SignalExternalWorkflowExecutionFailedCause {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_INVALID",
            Self::UnknownExternalWorkflowExecution => {
                "SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_UNKNOWN_EXTERNAL_WORKFLOW_EXECUTION"
            }
            Self::WorkflowAlreadyCompleted => {
                "SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_WORKFLOW_ALREADY_COMPLETED"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_INVALID" => {
                Some(Self::Invalid)
            }
            "SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_UNKNOWN_EXTERNAL_WORKFLOW_EXECUTION" => {
                Some(Self::UnknownExternalWorkflowExecution)
            }
            "SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_WORKFLOW_ALREADY_COMPLETED" => {
                Some(Self::WorkflowAlreadyCompleted)
            }
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Decision {
    #[prost(
        oneof = "decision::Attributes",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13"
    )]
    pub attributes: ::core::option::Option<decision::Attributes>,
}
/// Nested message and enum types in `Decision`.
pub mod decision {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Attributes {
        #[prost(message, tag = "1")]
        ScheduleActivityTaskDecisionAttributes(super::ScheduleActivityTaskDecisionAttributes),
        #[prost(message, tag = "2")]
        StartTimerDecisionAttributes(super::StartTimerDecisionAttributes),
        #[prost(message, tag = "3")]
        CompleteWorkflowExecutionDecisionAttributes(
            super::CompleteWorkflowExecutionDecisionAttributes,
        ),
        #[prost(message, tag = "4")]
        FailWorkflowExecutionDecisionAttributes(super::FailWorkflowExecutionDecisionAttributes),
        #[prost(message, tag = "5")]
        RequestCancelActivityTaskDecisionAttributes(
            super::RequestCancelActivityTaskDecisionAttributes,
        ),
        #[prost(message, tag = "6")]
        CancelTimerDecisionAttributes(super::CancelTimerDecisionAttributes),
        #[prost(message, tag = "7")]
        CancelWorkflowExecutionDecisionAttributes(super::CancelWorkflowExecutionDecisionAttributes),
        #[prost(message, tag = "8")]
        RequestCancelExternalWorkflowExecutionDecisionAttributes(
            super::RequestCancelExternalWorkflowExecutionDecisionAttributes,
        ),
        #[prost(message, tag = "9")]
        RecordMarkerDecisionAttributes(super::RecordMarkerDecisionAttributes),
        #[prost(message, tag = "10")]
        ContinueAsNewWorkflowExecutionDecisionAttributes(
            super::ContinueAsNewWorkflowExecutionDecisionAttributes,
        ),
        #[prost(message, tag = "11")]
        StartChildWorkflowExecutionDecisionAttributes(
            super::StartChildWorkflowExecutionDecisionAttributes,
        ),
        #[prost(message, tag = "12")]
        SignalExternalWorkflowExecutionDecisionAttributes(
            super::SignalExternalWorkflowExecutionDecisionAttributes,
        ),
        #[prost(message, tag = "13")]
        UpsertWorkflowSearchAttributesDecisionAttributes(
            super::UpsertWorkflowSearchAttributesDecisionAttributes,
        ),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScheduleActivityTaskDecisionAttributes {
    #[prost(string, tag = "1")]
    pub activity_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub activity_type: ::core::option::Option<ActivityType>,
    #[prost(string, tag = "3")]
    pub domain: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub task_list: ::core::option::Option<TaskList>,
    #[prost(message, optional, tag = "5")]
    pub input: ::core::option::Option<Payload>,
    #[prost(message, optional, tag = "6")]
    pub schedule_to_close_timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "7")]
    pub schedule_to_start_timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "8")]
    pub start_to_close_timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "9")]
    pub heartbeat_timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "11")]
    pub retry_policy: ::core::option::Option<RetryPolicy>,
    #[prost(message, optional, tag = "12")]
    pub header: ::core::option::Option<Header>,
    #[prost(bool, tag = "13")]
    pub request_local_dispatch: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartTimerDecisionAttributes {
    #[prost(string, tag = "1")]
    pub timer_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub start_to_fire_timeout: ::core::option::Option<::prost_types::Duration>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompleteWorkflowExecutionDecisionAttributes {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<Payload>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FailWorkflowExecutionDecisionAttributes {
    #[prost(message, optional, tag = "1")]
    pub failure: ::core::option::Option<Failure>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestCancelActivityTaskDecisionAttributes {
    #[prost(string, tag = "1")]
    pub activity_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelTimerDecisionAttributes {
    #[prost(string, tag = "1")]
    pub timer_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelWorkflowExecutionDecisionAttributes {
    #[prost(message, optional, tag = "1")]
    pub details: ::core::option::Option<Payload>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestCancelExternalWorkflowExecutionDecisionAttributes {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub workflow_execution: ::core::option::Option<WorkflowExecution>,
    #[prost(bytes = "vec", tag = "3")]
    pub control: ::prost::alloc::vec::Vec<u8>,
    #[prost(bool, tag = "4")]
    pub child_workflow_only: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecordMarkerDecisionAttributes {
    #[prost(string, tag = "1")]
    pub marker_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub details: ::core::option::Option<Payload>,
    #[prost(message, optional, tag = "3")]
    pub header: ::core::option::Option<Header>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContinueAsNewWorkflowExecutionDecisionAttributes {
    #[prost(message, optional, tag = "1")]
    pub workflow_type: ::core::option::Option<WorkflowType>,
    #[prost(message, optional, tag = "2")]
    pub task_list: ::core::option::Option<TaskList>,
    #[prost(message, optional, tag = "3")]
    pub input: ::core::option::Option<Payload>,
    #[prost(message, optional, tag = "4")]
    pub execution_start_to_close_timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "5")]
    pub task_start_to_close_timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "6")]
    pub backoff_start_interval: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "7")]
    pub retry_policy: ::core::option::Option<RetryPolicy>,
    #[prost(enumeration = "ContinueAsNewInitiator", tag = "8")]
    pub initiator: i32,
    #[prost(message, optional, tag = "9")]
    pub failure: ::core::option::Option<Failure>,
    #[prost(message, optional, tag = "10")]
    pub last_completion_result: ::core::option::Option<Payload>,
    #[prost(string, tag = "11")]
    pub cron_schedule: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "12")]
    pub header: ::core::option::Option<Header>,
    #[prost(message, optional, tag = "13")]
    pub memo: ::core::option::Option<Memo>,
    #[prost(message, optional, tag = "14")]
    pub search_attributes: ::core::option::Option<SearchAttributes>,
    #[prost(message, optional, tag = "15")]
    pub jitter_start: ::core::option::Option<::prost_types::Duration>,
    #[prost(enumeration = "CronOverlapPolicy", tag = "16")]
    pub cron_overlap_policy: i32,
    #[prost(message, optional, tag = "17")]
    pub active_cluster_selection_policy: ::core::option::Option<ActiveClusterSelectionPolicy>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartChildWorkflowExecutionDecisionAttributes {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub workflow_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub workflow_type: ::core::option::Option<WorkflowType>,
    #[prost(message, optional, tag = "4")]
    pub task_list: ::core::option::Option<TaskList>,
    #[prost(message, optional, tag = "5")]
    pub input: ::core::option::Option<Payload>,
    #[prost(message, optional, tag = "6")]
    pub execution_start_to_close_timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "7")]
    pub task_start_to_close_timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(enumeration = "ParentClosePolicy", tag = "8")]
    pub parent_close_policy: i32,
    #[prost(bytes = "vec", tag = "9")]
    pub control: ::prost::alloc::vec::Vec<u8>,
    #[prost(enumeration = "WorkflowIdReusePolicy", tag = "10")]
    pub workflow_id_reuse_policy: i32,
    #[prost(message, optional, tag = "11")]
    pub retry_policy: ::core::option::Option<RetryPolicy>,
    #[prost(string, tag = "12")]
    pub cron_schedule: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "13")]
    pub header: ::core::option::Option<Header>,
    #[prost(message, optional, tag = "14")]
    pub memo: ::core::option::Option<Memo>,
    #[prost(message, optional, tag = "15")]
    pub search_attributes: ::core::option::Option<SearchAttributes>,
    #[prost(enumeration = "CronOverlapPolicy", tag = "16")]
    pub cron_overlap_policy: i32,
    #[prost(message, optional, tag = "17")]
    pub active_cluster_selection_policy: ::core::option::Option<ActiveClusterSelectionPolicy>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignalExternalWorkflowExecutionDecisionAttributes {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub workflow_execution: ::core::option::Option<WorkflowExecution>,
    #[prost(string, tag = "3")]
    pub signal_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub input: ::core::option::Option<Payload>,
    #[prost(bytes = "vec", tag = "5")]
    pub control: ::prost::alloc::vec::Vec<u8>,
    #[prost(bool, tag = "6")]
    pub child_workflow_only: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpsertWorkflowSearchAttributesDecisionAttributes {
    #[prost(message, optional, tag = "1")]
    pub search_attributes: ::core::option::Option<SearchAttributes>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct History {
    #[prost(message, repeated, tag = "1")]
    pub events: ::prost::alloc::vec::Vec<HistoryEvent>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HistoryEvent {
    #[prost(int64, tag = "1")]
    pub event_id: i64,
    #[prost(message, optional, tag = "2")]
    pub event_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(int64, tag = "3")]
    pub version: i64,
    #[prost(int64, tag = "4")]
    pub task_id: i64,
    #[prost(
        oneof = "history_event::Attributes",
        tags = "5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46"
    )]
    pub attributes: ::core::option::Option<history_event::Attributes>,
}
/// Nested message and enum types in `HistoryEvent`.
pub mod history_event {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Attributes {
        #[prost(message, tag = "5")]
        WorkflowExecutionStartedEventAttributes(super::WorkflowExecutionStartedEventAttributes),
        #[prost(message, tag = "6")]
        WorkflowExecutionCompletedEventAttributes(super::WorkflowExecutionCompletedEventAttributes),
        #[prost(message, tag = "7")]
        WorkflowExecutionFailedEventAttributes(super::WorkflowExecutionFailedEventAttributes),
        #[prost(message, tag = "8")]
        WorkflowExecutionTimedOutEventAttributes(super::WorkflowExecutionTimedOutEventAttributes),
        #[prost(message, tag = "9")]
        DecisionTaskScheduledEventAttributes(super::DecisionTaskScheduledEventAttributes),
        #[prost(message, tag = "10")]
        DecisionTaskStartedEventAttributes(super::DecisionTaskStartedEventAttributes),
        #[prost(message, tag = "11")]
        DecisionTaskCompletedEventAttributes(super::DecisionTaskCompletedEventAttributes),
        #[prost(message, tag = "12")]
        DecisionTaskTimedOutEventAttributes(super::DecisionTaskTimedOutEventAttributes),
        #[prost(message, tag = "13")]
        DecisionTaskFailedEventAttributes(super::DecisionTaskFailedEventAttributes),
        #[prost(message, tag = "14")]
        ActivityTaskScheduledEventAttributes(super::ActivityTaskScheduledEventAttributes),
        #[prost(message, tag = "15")]
        ActivityTaskStartedEventAttributes(super::ActivityTaskStartedEventAttributes),
        #[prost(message, tag = "16")]
        ActivityTaskCompletedEventAttributes(super::ActivityTaskCompletedEventAttributes),
        #[prost(message, tag = "17")]
        ActivityTaskFailedEventAttributes(super::ActivityTaskFailedEventAttributes),
        #[prost(message, tag = "18")]
        ActivityTaskTimedOutEventAttributes(super::ActivityTaskTimedOutEventAttributes),
        #[prost(message, tag = "19")]
        TimerStartedEventAttributes(super::TimerStartedEventAttributes),
        #[prost(message, tag = "20")]
        TimerFiredEventAttributes(super::TimerFiredEventAttributes),
        #[prost(message, tag = "21")]
        ActivityTaskCancelRequestedEventAttributes(
            super::ActivityTaskCancelRequestedEventAttributes,
        ),
        #[prost(message, tag = "22")]
        RequestCancelActivityTaskFailedEventAttributes(
            super::RequestCancelActivityTaskFailedEventAttributes,
        ),
        #[prost(message, tag = "23")]
        ActivityTaskCanceledEventAttributes(super::ActivityTaskCanceledEventAttributes),
        #[prost(message, tag = "24")]
        TimerCanceledEventAttributes(super::TimerCanceledEventAttributes),
        #[prost(message, tag = "25")]
        CancelTimerFailedEventAttributes(super::CancelTimerFailedEventAttributes),
        #[prost(message, tag = "26")]
        MarkerRecordedEventAttributes(super::MarkerRecordedEventAttributes),
        #[prost(message, tag = "27")]
        WorkflowExecutionSignaledEventAttributes(super::WorkflowExecutionSignaledEventAttributes),
        #[prost(message, tag = "28")]
        WorkflowExecutionTerminatedEventAttributes(
            super::WorkflowExecutionTerminatedEventAttributes,
        ),
        #[prost(message, tag = "29")]
        WorkflowExecutionCancelRequestedEventAttributes(
            super::WorkflowExecutionCancelRequestedEventAttributes,
        ),
        #[prost(message, tag = "30")]
        WorkflowExecutionCanceledEventAttributes(super::WorkflowExecutionCanceledEventAttributes),
        #[prost(message, tag = "31")]
        RequestCancelExternalWorkflowExecutionInitiatedEventAttributes(
            super::RequestCancelExternalWorkflowExecutionInitiatedEventAttributes,
        ),
        #[prost(message, tag = "32")]
        RequestCancelExternalWorkflowExecutionFailedEventAttributes(
            super::RequestCancelExternalWorkflowExecutionFailedEventAttributes,
        ),
        #[prost(message, tag = "33")]
        ExternalWorkflowExecutionCancelRequestedEventAttributes(
            super::ExternalWorkflowExecutionCancelRequestedEventAttributes,
        ),
        #[prost(message, tag = "34")]
        WorkflowExecutionContinuedAsNewEventAttributes(
            super::WorkflowExecutionContinuedAsNewEventAttributes,
        ),
        #[prost(message, tag = "35")]
        StartChildWorkflowExecutionInitiatedEventAttributes(
            super::StartChildWorkflowExecutionInitiatedEventAttributes,
        ),
        #[prost(message, tag = "36")]
        StartChildWorkflowExecutionFailedEventAttributes(
            super::StartChildWorkflowExecutionFailedEventAttributes,
        ),
        #[prost(message, tag = "37")]
        ChildWorkflowExecutionStartedEventAttributes(
            super::ChildWorkflowExecutionStartedEventAttributes,
        ),
        #[prost(message, tag = "38")]
        ChildWorkflowExecutionCompletedEventAttributes(
            super::ChildWorkflowExecutionCompletedEventAttributes,
        ),
        #[prost(message, tag = "39")]
        ChildWorkflowExecutionFailedEventAttributes(
            super::ChildWorkflowExecutionFailedEventAttributes,
        ),
        #[prost(message, tag = "40")]
        ChildWorkflowExecutionCanceledEventAttributes(
            super::ChildWorkflowExecutionCanceledEventAttributes,
        ),
        #[prost(message, tag = "41")]
        ChildWorkflowExecutionTimedOutEventAttributes(
            super::ChildWorkflowExecutionTimedOutEventAttributes,
        ),
        #[prost(message, tag = "42")]
        ChildWorkflowExecutionTerminatedEventAttributes(
            super::ChildWorkflowExecutionTerminatedEventAttributes,
        ),
        #[prost(message, tag = "43")]
        SignalExternalWorkflowExecutionInitiatedEventAttributes(
            super::SignalExternalWorkflowExecutionInitiatedEventAttributes,
        ),
        #[prost(message, tag = "44")]
        SignalExternalWorkflowExecutionFailedEventAttributes(
            super::SignalExternalWorkflowExecutionFailedEventAttributes,
        ),
        #[prost(message, tag = "45")]
        ExternalWorkflowExecutionSignaledEventAttributes(
            super::ExternalWorkflowExecutionSignaledEventAttributes,
        ),
        #[prost(message, tag = "46")]
        UpsertWorkflowSearchAttributesEventAttributes(
            super::UpsertWorkflowSearchAttributesEventAttributes,
        ),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkflowExecutionStartedEventAttributes {
    #[prost(message, optional, tag = "1")]
    pub workflow_type: ::core::option::Option<WorkflowType>,
    #[prost(message, optional, tag = "2")]
    pub parent_execution_info: ::core::option::Option<ParentExecutionInfo>,
    #[prost(message, optional, tag = "3")]
    pub task_list: ::core::option::Option<TaskList>,
    #[prost(message, optional, tag = "4")]
    pub input: ::core::option::Option<Payload>,
    #[prost(message, optional, tag = "5")]
    pub execution_start_to_close_timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "6")]
    pub task_start_to_close_timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(string, tag = "7")]
    pub continued_execution_run_id: ::prost::alloc::string::String,
    #[prost(enumeration = "ContinueAsNewInitiator", tag = "8")]
    pub initiator: i32,
    #[prost(message, optional, tag = "9")]
    pub continued_failure: ::core::option::Option<Failure>,
    #[prost(message, optional, tag = "10")]
    pub last_completion_result: ::core::option::Option<Payload>,
    /// This is the previous runID of ContinueAsNew.
    #[prost(string, tag = "11")]
    pub original_execution_run_id: ::prost::alloc::string::String,
    #[prost(string, tag = "12")]
    pub identity: ::prost::alloc::string::String,
    /// This is the very first runID along the chain of ContinueAsNew and Reset.
    #[prost(string, tag = "13")]
    pub first_execution_run_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "14")]
    pub retry_policy: ::core::option::Option<RetryPolicy>,
    #[prost(int32, tag = "15")]
    pub attempt: i32,
    #[prost(message, optional, tag = "16")]
    pub expiration_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "17")]
    pub cron_schedule: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "18")]
    pub first_decision_task_backoff: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "19")]
    pub memo: ::core::option::Option<Memo>,
    #[prost(message, optional, tag = "20")]
    pub search_attributes: ::core::option::Option<SearchAttributes>,
    #[prost(message, optional, tag = "21")]
    pub prev_auto_reset_points: ::core::option::Option<ResetPoints>,
    #[prost(message, optional, tag = "22")]
    pub header: ::core::option::Option<Header>,
    #[prost(message, optional, tag = "23")]
    pub first_scheduled_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, string", tag = "24")]
    pub partition_config:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    #[prost(string, tag = "25")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(enumeration = "CronOverlapPolicy", tag = "26")]
    pub cron_overlap_policy: i32,
    #[prost(message, optional, tag = "27")]
    pub active_cluster_selection_policy: ::core::option::Option<ActiveClusterSelectionPolicy>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkflowExecutionCompletedEventAttributes {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<Payload>,
    #[prost(int64, tag = "2")]
    pub decision_task_completed_event_id: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkflowExecutionFailedEventAttributes {
    #[prost(message, optional, tag = "1")]
    pub failure: ::core::option::Option<Failure>,
    #[prost(int64, tag = "2")]
    pub decision_task_completed_event_id: i64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WorkflowExecutionTimedOutEventAttributes {
    #[prost(enumeration = "TimeoutType", tag = "1")]
    pub timeout_type: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DecisionTaskScheduledEventAttributes {
    #[prost(message, optional, tag = "1")]
    pub task_list: ::core::option::Option<TaskList>,
    #[prost(message, optional, tag = "2")]
    pub start_to_close_timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(int32, tag = "3")]
    pub attempt: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DecisionTaskStartedEventAttributes {
    #[prost(int64, tag = "1")]
    pub scheduled_event_id: i64,
    #[prost(string, tag = "2")]
    pub identity: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DecisionTaskCompletedEventAttributes {
    #[prost(int64, tag = "1")]
    pub scheduled_event_id: i64,
    #[prost(int64, tag = "2")]
    pub started_event_id: i64,
    #[prost(string, tag = "3")]
    pub identity: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub binary_checksum: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "5")]
    pub execution_context: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DecisionTaskTimedOutEventAttributes {
    #[prost(int64, tag = "1")]
    pub scheduled_event_id: i64,
    #[prost(int64, tag = "2")]
    pub started_event_id: i64,
    #[prost(enumeration = "TimeoutType", tag = "3")]
    pub timeout_type: i32,
    /// For reset workflow.
    #[prost(string, tag = "4")]
    pub base_run_id: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub new_run_id: ::prost::alloc::string::String,
    #[prost(int64, tag = "6")]
    pub fork_event_version: i64,
    #[prost(string, tag = "7")]
    pub reason: ::prost::alloc::string::String,
    #[prost(enumeration = "DecisionTaskTimedOutCause", tag = "8")]
    pub cause: i32,
    #[prost(string, tag = "9")]
    pub request_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DecisionTaskFailedEventAttributes {
    #[prost(int64, tag = "1")]
    pub scheduled_event_id: i64,
    #[prost(int64, tag = "2")]
    pub started_event_id: i64,
    #[prost(enumeration = "DecisionTaskFailedCause", tag = "3")]
    pub cause: i32,
    #[prost(message, optional, tag = "4")]
    pub failure: ::core::option::Option<Failure>,
    #[prost(string, tag = "5")]
    pub identity: ::prost::alloc::string::String,
    /// For reset workflow.
    #[prost(string, tag = "6")]
    pub base_run_id: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub new_run_id: ::prost::alloc::string::String,
    #[prost(int64, tag = "8")]
    pub fork_event_version: i64,
    #[prost(string, tag = "9")]
    pub binary_checksum: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub request_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActivityTaskScheduledEventAttributes {
    #[prost(string, tag = "1")]
    pub activity_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub activity_type: ::core::option::Option<ActivityType>,
    #[prost(string, tag = "3")]
    pub domain: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub task_list: ::core::option::Option<TaskList>,
    #[prost(message, optional, tag = "6")]
    pub input: ::core::option::Option<Payload>,
    #[prost(message, optional, tag = "7")]
    pub schedule_to_close_timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "8")]
    pub schedule_to_start_timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "9")]
    pub start_to_close_timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "10")]
    pub heartbeat_timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(int64, tag = "11")]
    pub decision_task_completed_event_id: i64,
    #[prost(message, optional, tag = "12")]
    pub retry_policy: ::core::option::Option<RetryPolicy>,
    #[prost(message, optional, tag = "13")]
    pub header: ::core::option::Option<Header>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActivityTaskStartedEventAttributes {
    #[prost(int64, tag = "1")]
    pub scheduled_event_id: i64,
    #[prost(string, tag = "2")]
    pub identity: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub attempt: i32,
    #[prost(message, optional, tag = "5")]
    pub last_failure: ::core::option::Option<Failure>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActivityTaskCompletedEventAttributes {
    #[prost(message, optional, tag = "1")]
    pub result: ::core::option::Option<Payload>,
    #[prost(int64, tag = "2")]
    pub scheduled_event_id: i64,
    #[prost(int64, tag = "3")]
    pub started_event_id: i64,
    #[prost(string, tag = "4")]
    pub identity: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActivityTaskFailedEventAttributes {
    #[prost(message, optional, tag = "1")]
    pub failure: ::core::option::Option<Failure>,
    #[prost(int64, tag = "2")]
    pub scheduled_event_id: i64,
    #[prost(int64, tag = "3")]
    pub started_event_id: i64,
    #[prost(string, tag = "4")]
    pub identity: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActivityTaskTimedOutEventAttributes {
    #[prost(message, optional, tag = "1")]
    pub details: ::core::option::Option<Payload>,
    #[prost(int64, tag = "2")]
    pub scheduled_event_id: i64,
    #[prost(int64, tag = "3")]
    pub started_event_id: i64,
    #[prost(enumeration = "TimeoutType", tag = "4")]
    pub timeout_type: i32,
    /// For retry activity, it may have a failure before timeout. It's important to keep those information for debug.
    /// Client can also provide the info for making next decision
    #[prost(message, optional, tag = "5")]
    pub last_failure: ::core::option::Option<Failure>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActivityTaskCancelRequestedEventAttributes {
    #[prost(string, tag = "1")]
    pub activity_id: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub decision_task_completed_event_id: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestCancelActivityTaskFailedEventAttributes {
    #[prost(string, tag = "1")]
    pub activity_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub cause: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub decision_task_completed_event_id: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActivityTaskCanceledEventAttributes {
    #[prost(message, optional, tag = "1")]
    pub details: ::core::option::Option<Payload>,
    #[prost(int64, tag = "2")]
    pub latest_cancel_requested_event_id: i64,
    #[prost(int64, tag = "3")]
    pub scheduled_event_id: i64,
    #[prost(int64, tag = "4")]
    pub started_event_id: i64,
    #[prost(string, tag = "5")]
    pub identity: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimerStartedEventAttributes {
    #[prost(string, tag = "1")]
    pub timer_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub start_to_fire_timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(int64, tag = "3")]
    pub decision_task_completed_event_id: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimerFiredEventAttributes {
    #[prost(string, tag = "1")]
    pub timer_id: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub started_event_id: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimerCanceledEventAttributes {
    #[prost(string, tag = "1")]
    pub timer_id: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub started_event_id: i64,
    #[prost(int64, tag = "3")]
    pub decision_task_completed_event_id: i64,
    #[prost(string, tag = "4")]
    pub identity: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelTimerFailedEventAttributes {
    #[prost(string, tag = "1")]
    pub timer_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub cause: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub decision_task_completed_event_id: i64,
    #[prost(string, tag = "4")]
    pub identity: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkflowExecutionContinuedAsNewEventAttributes {
    #[prost(string, tag = "1")]
    pub new_execution_run_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub workflow_type: ::core::option::Option<WorkflowType>,
    #[prost(message, optional, tag = "3")]
    pub task_list: ::core::option::Option<TaskList>,
    #[prost(message, optional, tag = "4")]
    pub input: ::core::option::Option<Payload>,
    #[prost(message, optional, tag = "5")]
    pub execution_start_to_close_timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "6")]
    pub task_start_to_close_timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(int64, tag = "7")]
    pub decision_task_completed_event_id: i64,
    #[prost(message, optional, tag = "8")]
    pub backoff_start_interval: ::core::option::Option<::prost_types::Duration>,
    #[prost(enumeration = "ContinueAsNewInitiator", tag = "9")]
    pub initiator: i32,
    #[prost(message, optional, tag = "10")]
    pub failure: ::core::option::Option<Failure>,
    #[prost(message, optional, tag = "11")]
    pub last_completion_result: ::core::option::Option<Payload>,
    #[prost(message, optional, tag = "12")]
    pub header: ::core::option::Option<Header>,
    #[prost(message, optional, tag = "13")]
    pub memo: ::core::option::Option<Memo>,
    #[prost(message, optional, tag = "14")]
    pub search_attributes: ::core::option::Option<SearchAttributes>,
    #[prost(enumeration = "CronOverlapPolicy", tag = "15")]
    pub cron_overlap_policy: i32,
    #[prost(message, optional, tag = "16")]
    pub active_cluster_selection_policy: ::core::option::Option<ActiveClusterSelectionPolicy>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkflowExecutionCancelRequestedEventAttributes {
    #[prost(string, tag = "1")]
    pub cause: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub identity: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub external_execution_info: ::core::option::Option<ExternalExecutionInfo>,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkflowExecutionCanceledEventAttributes {
    #[prost(int64, tag = "1")]
    pub decision_task_completed_event_id: i64,
    #[prost(message, optional, tag = "2")]
    pub details: ::core::option::Option<Payload>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MarkerRecordedEventAttributes {
    #[prost(string, tag = "1")]
    pub marker_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub details: ::core::option::Option<Payload>,
    #[prost(int64, tag = "3")]
    pub decision_task_completed_event_id: i64,
    #[prost(message, optional, tag = "4")]
    pub header: ::core::option::Option<Header>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkflowExecutionSignaledEventAttributes {
    #[prost(string, tag = "1")]
    pub signal_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub input: ::core::option::Option<Payload>,
    #[prost(string, tag = "3")]
    pub identity: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkflowExecutionTerminatedEventAttributes {
    #[prost(string, tag = "1")]
    pub reason: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub details: ::core::option::Option<Payload>,
    #[prost(string, tag = "3")]
    pub identity: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestCancelExternalWorkflowExecutionInitiatedEventAttributes {
    #[prost(int64, tag = "1")]
    pub decision_task_completed_event_id: i64,
    #[prost(string, tag = "2")]
    pub domain: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub workflow_execution: ::core::option::Option<WorkflowExecution>,
    #[prost(bytes = "vec", tag = "4")]
    pub control: ::prost::alloc::vec::Vec<u8>,
    #[prost(bool, tag = "5")]
    pub child_workflow_only: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestCancelExternalWorkflowExecutionFailedEventAttributes {
    #[prost(enumeration = "CancelExternalWorkflowExecutionFailedCause", tag = "1")]
    pub cause: i32,
    #[prost(int64, tag = "2")]
    pub decision_task_completed_event_id: i64,
    #[prost(string, tag = "3")]
    pub domain: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub workflow_execution: ::core::option::Option<WorkflowExecution>,
    #[prost(int64, tag = "5")]
    pub initiated_event_id: i64,
    #[prost(bytes = "vec", tag = "6")]
    pub control: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExternalWorkflowExecutionCancelRequestedEventAttributes {
    #[prost(int64, tag = "1")]
    pub initiated_event_id: i64,
    #[prost(string, tag = "2")]
    pub domain: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub workflow_execution: ::core::option::Option<WorkflowExecution>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignalExternalWorkflowExecutionInitiatedEventAttributes {
    #[prost(int64, tag = "1")]
    pub decision_task_completed_event_id: i64,
    #[prost(string, tag = "2")]
    pub domain: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub workflow_execution: ::core::option::Option<WorkflowExecution>,
    #[prost(string, tag = "4")]
    pub signal_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub input: ::core::option::Option<Payload>,
    #[prost(bytes = "vec", tag = "6")]
    pub control: ::prost::alloc::vec::Vec<u8>,
    #[prost(bool, tag = "7")]
    pub child_workflow_only: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignalExternalWorkflowExecutionFailedEventAttributes {
    #[prost(enumeration = "SignalExternalWorkflowExecutionFailedCause", tag = "1")]
    pub cause: i32,
    #[prost(int64, tag = "2")]
    pub decision_task_completed_event_id: i64,
    #[prost(string, tag = "3")]
    pub domain: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub workflow_execution: ::core::option::Option<WorkflowExecution>,
    #[prost(int64, tag = "5")]
    pub initiated_event_id: i64,
    #[prost(bytes = "vec", tag = "6")]
    pub control: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExternalWorkflowExecutionSignaledEventAttributes {
    #[prost(int64, tag = "1")]
    pub initiated_event_id: i64,
    #[prost(string, tag = "2")]
    pub domain: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub workflow_execution: ::core::option::Option<WorkflowExecution>,
    #[prost(bytes = "vec", tag = "4")]
    pub control: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpsertWorkflowSearchAttributesEventAttributes {
    #[prost(int64, tag = "1")]
    pub decision_task_completed_event_id: i64,
    #[prost(message, optional, tag = "2")]
    pub search_attributes: ::core::option::Option<SearchAttributes>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartChildWorkflowExecutionInitiatedEventAttributes {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub workflow_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub workflow_type: ::core::option::Option<WorkflowType>,
    #[prost(message, optional, tag = "4")]
    pub task_list: ::core::option::Option<TaskList>,
    #[prost(message, optional, tag = "5")]
    pub input: ::core::option::Option<Payload>,
    #[prost(message, optional, tag = "6")]
    pub execution_start_to_close_timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "7")]
    pub task_start_to_close_timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(enumeration = "ParentClosePolicy", tag = "8")]
    pub parent_close_policy: i32,
    #[prost(bytes = "vec", tag = "9")]
    pub control: ::prost::alloc::vec::Vec<u8>,
    #[prost(int64, tag = "10")]
    pub decision_task_completed_event_id: i64,
    #[prost(enumeration = "WorkflowIdReusePolicy", tag = "11")]
    pub workflow_id_reuse_policy: i32,
    #[prost(message, optional, tag = "13")]
    pub retry_policy: ::core::option::Option<RetryPolicy>,
    #[prost(string, tag = "14")]
    pub cron_schedule: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "15")]
    pub header: ::core::option::Option<Header>,
    #[prost(message, optional, tag = "16")]
    pub memo: ::core::option::Option<Memo>,
    #[prost(message, optional, tag = "17")]
    pub search_attributes: ::core::option::Option<SearchAttributes>,
    #[prost(message, optional, tag = "18")]
    pub delay_start: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "19")]
    pub jitter_start: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "20")]
    pub first_run_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration = "CronOverlapPolicy", tag = "21")]
    pub cron_overlap_policy: i32,
    #[prost(message, optional, tag = "22")]
    pub active_cluster_selection_policy: ::core::option::Option<ActiveClusterSelectionPolicy>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartChildWorkflowExecutionFailedEventAttributes {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub workflow_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub workflow_type: ::core::option::Option<WorkflowType>,
    #[prost(enumeration = "ChildWorkflowExecutionFailedCause", tag = "4")]
    pub cause: i32,
    #[prost(bytes = "vec", tag = "5")]
    pub control: ::prost::alloc::vec::Vec<u8>,
    #[prost(int64, tag = "6")]
    pub initiated_event_id: i64,
    #[prost(int64, tag = "7")]
    pub decision_task_completed_event_id: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChildWorkflowExecutionStartedEventAttributes {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub workflow_execution: ::core::option::Option<WorkflowExecution>,
    #[prost(message, optional, tag = "3")]
    pub workflow_type: ::core::option::Option<WorkflowType>,
    #[prost(int64, tag = "4")]
    pub initiated_event_id: i64,
    #[prost(message, optional, tag = "5")]
    pub header: ::core::option::Option<Header>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChildWorkflowExecutionCompletedEventAttributes {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub workflow_execution: ::core::option::Option<WorkflowExecution>,
    #[prost(message, optional, tag = "3")]
    pub workflow_type: ::core::option::Option<WorkflowType>,
    #[prost(int64, tag = "4")]
    pub initiated_event_id: i64,
    #[prost(int64, tag = "5")]
    pub started_event_id: i64,
    #[prost(message, optional, tag = "6")]
    pub result: ::core::option::Option<Payload>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChildWorkflowExecutionFailedEventAttributes {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub workflow_execution: ::core::option::Option<WorkflowExecution>,
    #[prost(message, optional, tag = "3")]
    pub workflow_type: ::core::option::Option<WorkflowType>,
    #[prost(int64, tag = "4")]
    pub initiated_event_id: i64,
    #[prost(int64, tag = "5")]
    pub started_event_id: i64,
    #[prost(message, optional, tag = "6")]
    pub failure: ::core::option::Option<Failure>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChildWorkflowExecutionCanceledEventAttributes {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub workflow_execution: ::core::option::Option<WorkflowExecution>,
    #[prost(message, optional, tag = "3")]
    pub workflow_type: ::core::option::Option<WorkflowType>,
    #[prost(int64, tag = "4")]
    pub initiated_event_id: i64,
    #[prost(int64, tag = "5")]
    pub started_event_id: i64,
    #[prost(message, optional, tag = "6")]
    pub details: ::core::option::Option<Payload>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChildWorkflowExecutionTimedOutEventAttributes {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub workflow_execution: ::core::option::Option<WorkflowExecution>,
    #[prost(message, optional, tag = "3")]
    pub workflow_type: ::core::option::Option<WorkflowType>,
    #[prost(int64, tag = "4")]
    pub initiated_event_id: i64,
    #[prost(int64, tag = "5")]
    pub started_event_id: i64,
    #[prost(enumeration = "TimeoutType", tag = "6")]
    pub timeout_type: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChildWorkflowExecutionTerminatedEventAttributes {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub workflow_execution: ::core::option::Option<WorkflowExecution>,
    #[prost(message, optional, tag = "3")]
    pub workflow_type: ::core::option::Option<WorkflowType>,
    #[prost(int64, tag = "4")]
    pub initiated_event_id: i64,
    #[prost(int64, tag = "5")]
    pub started_event_id: i64,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EventFilterType {
    Invalid = 0,
    AllEvent = 1,
    CloseEvent = 2,
}
impl EventFilterType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "EVENT_FILTER_TYPE_INVALID",
            Self::AllEvent => "EVENT_FILTER_TYPE_ALL_EVENT",
            Self::CloseEvent => "EVENT_FILTER_TYPE_CLOSE_EVENT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EVENT_FILTER_TYPE_INVALID" => Some(Self::Invalid),
            "EVENT_FILTER_TYPE_ALL_EVENT" => Some(Self::AllEvent),
            "EVENT_FILTER_TYPE_CLOSE_EVENT" => Some(Self::CloseEvent),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkflowQuery {
    #[prost(string, tag = "1")]
    pub query_type: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub query_args: ::core::option::Option<Payload>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkflowQueryResult {
    #[prost(enumeration = "QueryResultType", tag = "1")]
    pub result_type: i32,
    #[prost(message, optional, tag = "2")]
    pub answer: ::core::option::Option<Payload>,
    #[prost(string, tag = "3")]
    pub error_message: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryRejected {
    #[prost(enumeration = "WorkflowExecutionCloseStatus", tag = "1")]
    pub close_status: i32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum QueryResultType {
    Invalid = 0,
    Answered = 1,
    Failed = 2,
}
impl QueryResultType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "QUERY_RESULT_TYPE_INVALID",
            Self::Answered => "QUERY_RESULT_TYPE_ANSWERED",
            Self::Failed => "QUERY_RESULT_TYPE_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "QUERY_RESULT_TYPE_INVALID" => Some(Self::Invalid),
            "QUERY_RESULT_TYPE_ANSWERED" => Some(Self::Answered),
            "QUERY_RESULT_TYPE_FAILED" => Some(Self::Failed),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum QueryRejectCondition {
    Invalid = 0,
    /// QUERY_REJECT_CONDITION_NOT_OPEN indicates that query should be rejected if workflow is not open.
    NotOpen = 1,
    /// QUERY_REJECT_CONDITION_NOT_COMPLETED_CLEANLY indicates that query should be rejected if workflow did not complete cleanly.
    NotCompletedCleanly = 2,
}
impl QueryRejectCondition {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "QUERY_REJECT_CONDITION_INVALID",
            Self::NotOpen => "QUERY_REJECT_CONDITION_NOT_OPEN",
            Self::NotCompletedCleanly => "QUERY_REJECT_CONDITION_NOT_COMPLETED_CLEANLY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "QUERY_REJECT_CONDITION_INVALID" => Some(Self::Invalid),
            "QUERY_REJECT_CONDITION_NOT_OPEN" => Some(Self::NotOpen),
            "QUERY_REJECT_CONDITION_NOT_COMPLETED_CLEANLY" => Some(Self::NotCompletedCleanly),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum QueryConsistencyLevel {
    Invalid = 0,
    /// EVENTUAL indicates that query should be eventually consistent.
    Eventual = 1,
    /// STRONG indicates that any events that came before query should be reflected in workflow state before running query.
    Strong = 2,
}
impl QueryConsistencyLevel {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "QUERY_CONSISTENCY_LEVEL_INVALID",
            Self::Eventual => "QUERY_CONSISTENCY_LEVEL_EVENTUAL",
            Self::Strong => "QUERY_CONSISTENCY_LEVEL_STRONG",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "QUERY_CONSISTENCY_LEVEL_INVALID" => Some(Self::Invalid),
            "QUERY_CONSISTENCY_LEVEL_EVENTUAL" => Some(Self::Eventual),
            "QUERY_CONSISTENCY_LEVEL_STRONG" => Some(Self::Strong),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PollForDecisionTaskRequest {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub task_list: ::core::option::Option<TaskList>,
    #[prost(string, tag = "3")]
    pub identity: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub binary_checksum: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PollForDecisionTaskResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub task_token: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "2")]
    pub workflow_execution: ::core::option::Option<WorkflowExecution>,
    #[prost(message, optional, tag = "3")]
    pub workflow_type: ::core::option::Option<WorkflowType>,
    #[prost(message, optional, tag = "4")]
    pub previous_started_event_id: ::core::option::Option<i64>,
    #[prost(int64, tag = "5")]
    pub started_event_id: i64,
    #[prost(int64, tag = "6")]
    pub attempt: i64,
    #[prost(int64, tag = "7")]
    pub backlog_count_hint: i64,
    #[prost(message, optional, tag = "8")]
    pub history: ::core::option::Option<History>,
    #[prost(bytes = "vec", tag = "9")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "10")]
    pub query: ::core::option::Option<WorkflowQuery>,
    #[prost(message, optional, tag = "11")]
    pub workflow_execution_task_list: ::core::option::Option<TaskList>,
    #[prost(message, optional, tag = "12")]
    pub scheduled_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "13")]
    pub started_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(map = "string, message", tag = "14")]
    pub queries: ::std::collections::HashMap<::prost::alloc::string::String, WorkflowQuery>,
    #[prost(int64, tag = "15")]
    pub next_event_id: i64,
    #[prost(int64, tag = "16")]
    pub total_history_bytes: i64,
    #[prost(message, optional, tag = "17")]
    pub auto_config_hint: ::core::option::Option<AutoConfigHint>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RespondDecisionTaskCompletedRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub task_token: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, repeated, tag = "2")]
    pub decisions: ::prost::alloc::vec::Vec<Decision>,
    #[prost(bytes = "vec", tag = "3")]
    pub execution_context: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "4")]
    pub identity: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub sticky_attributes: ::core::option::Option<StickyExecutionAttributes>,
    #[prost(bool, tag = "6")]
    pub return_new_decision_task: bool,
    #[prost(bool, tag = "7")]
    pub force_create_new_decision_task: bool,
    #[prost(string, tag = "8")]
    pub binary_checksum: ::prost::alloc::string::String,
    #[prost(map = "string, message", tag = "9")]
    pub query_results:
        ::std::collections::HashMap<::prost::alloc::string::String, WorkflowQueryResult>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RespondDecisionTaskCompletedResponse {
    #[prost(message, optional, tag = "1")]
    pub decision_task: ::core::option::Option<PollForDecisionTaskResponse>,
    #[prost(map = "string, message", tag = "2")]
    pub activities_to_dispatch_locally:
        ::std::collections::HashMap<::prost::alloc::string::String, ActivityLocalDispatchInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RespondDecisionTaskFailedRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub task_token: ::prost::alloc::vec::Vec<u8>,
    #[prost(enumeration = "DecisionTaskFailedCause", tag = "2")]
    pub cause: i32,
    #[prost(message, optional, tag = "3")]
    pub details: ::core::option::Option<Payload>,
    #[prost(string, tag = "4")]
    pub identity: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub binary_checksum: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RespondDecisionTaskFailedResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PollForActivityTaskRequest {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub task_list: ::core::option::Option<TaskList>,
    #[prost(string, tag = "3")]
    pub identity: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub task_list_metadata: ::core::option::Option<TaskListMetadata>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PollForActivityTaskResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub task_token: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "2")]
    pub workflow_execution: ::core::option::Option<WorkflowExecution>,
    #[prost(string, tag = "3")]
    pub activity_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub activity_type: ::core::option::Option<ActivityType>,
    #[prost(message, optional, tag = "5")]
    pub input: ::core::option::Option<Payload>,
    #[prost(message, optional, tag = "6")]
    pub scheduled_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub started_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub schedule_to_close_timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "9")]
    pub start_to_close_timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "10")]
    pub heartbeat_timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(int32, tag = "11")]
    pub attempt: i32,
    #[prost(message, optional, tag = "12")]
    pub scheduled_time_of_this_attempt: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "13")]
    pub heartbeat_details: ::core::option::Option<Payload>,
    #[prost(message, optional, tag = "14")]
    pub workflow_type: ::core::option::Option<WorkflowType>,
    #[prost(string, tag = "15")]
    pub workflow_domain: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "16")]
    pub header: ::core::option::Option<Header>,
    #[prost(message, optional, tag = "17")]
    pub auto_config_hint: ::core::option::Option<AutoConfigHint>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RespondActivityTaskCompletedRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub task_token: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "2")]
    pub result: ::core::option::Option<Payload>,
    #[prost(string, tag = "3")]
    pub identity: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RespondActivityTaskCompletedResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RespondActivityTaskCompletedByIdRequest {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub workflow_execution: ::core::option::Option<WorkflowExecution>,
    #[prost(string, tag = "3")]
    pub activity_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub result: ::core::option::Option<Payload>,
    #[prost(string, tag = "5")]
    pub identity: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RespondActivityTaskCompletedByIdResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RespondActivityTaskFailedRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub task_token: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "2")]
    pub failure: ::core::option::Option<Failure>,
    #[prost(string, tag = "3")]
    pub identity: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RespondActivityTaskFailedResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RespondActivityTaskFailedByIdRequest {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub workflow_execution: ::core::option::Option<WorkflowExecution>,
    #[prost(string, tag = "3")]
    pub activity_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub failure: ::core::option::Option<Failure>,
    #[prost(string, tag = "5")]
    pub identity: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RespondActivityTaskFailedByIdResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RespondActivityTaskCanceledRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub task_token: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "2")]
    pub details: ::core::option::Option<Payload>,
    #[prost(string, tag = "3")]
    pub identity: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RespondActivityTaskCanceledResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RespondActivityTaskCanceledByIdRequest {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub workflow_execution: ::core::option::Option<WorkflowExecution>,
    #[prost(string, tag = "3")]
    pub activity_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub details: ::core::option::Option<Payload>,
    #[prost(string, tag = "5")]
    pub identity: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RespondActivityTaskCanceledByIdResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecordActivityTaskHeartbeatRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub task_token: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "2")]
    pub details: ::core::option::Option<Payload>,
    #[prost(string, tag = "3")]
    pub identity: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RecordActivityTaskHeartbeatResponse {
    #[prost(bool, tag = "1")]
    pub cancel_requested: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecordActivityTaskHeartbeatByIdRequest {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub workflow_execution: ::core::option::Option<WorkflowExecution>,
    #[prost(string, tag = "3")]
    pub activity_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub details: ::core::option::Option<Payload>,
    #[prost(string, tag = "5")]
    pub identity: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RecordActivityTaskHeartbeatByIdResponse {
    #[prost(bool, tag = "1")]
    pub cancel_requested: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RespondQueryTaskCompletedRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub task_token: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "2")]
    pub result: ::core::option::Option<WorkflowQueryResult>,
    #[prost(message, optional, tag = "3")]
    pub worker_version_info: ::core::option::Option<WorkerVersionInfo>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RespondQueryTaskCompletedResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResetStickyTaskListRequest {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub workflow_execution: ::core::option::Option<WorkflowExecution>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResetStickyTaskListResponse {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AutoConfigHint {
    #[prost(bool, tag = "1")]
    pub enable_auto_config: bool,
    #[prost(int64, tag = "2")]
    pub poller_wait_time_in_ms: i64,
}
/// Generated client implementations.
pub mod worker_api_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// WorkerAPI is exposed to provide support for long running applications.  Such applications are
    /// expected to have a worker which regularly polls for DecisionTask and ActivityTask from the WorkflowService.  For each
    /// DecisionTask, application is expected to process the history of events for that session and respond back with next
    /// decisions.  For each ActivityTask, application is expected to execute the actual logic for that task and respond back
    /// with completion or failure.  Worker is expected to regularly heartbeat while activity task is running.
    #[derive(Debug, Clone)]
    pub struct WorkerApiClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl WorkerApiClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> WorkerApiClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> WorkerApiClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            WorkerApiClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// PollForDecisionTask is called by application worker to process DecisionTask from a specific taskList.
        /// A DecisionTask is dispatched to callers for active workflow executions, with pending decisions.
        /// Application is then expected to call 'RespondDecisionTaskCompleted' API when it is done processing the DecisionTask.
        /// It will also create a 'DecisionTaskStarted' event in the history for that session before handing off DecisionTask to
        /// application worker.
        pub async fn poll_for_decision_task(
            &mut self,
            request: impl tonic::IntoRequest<super::PollForDecisionTaskRequest>,
        ) -> std::result::Result<tonic::Response<super::PollForDecisionTaskResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/uber.cadence.api.v1.WorkerAPI/PollForDecisionTask",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.WorkerAPI",
                "PollForDecisionTask",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// RespondDecisionTaskCompleted is called by application worker to complete a DecisionTask handed as a result of
        /// 'PollForDecisionTask' API call.  Completing a DecisionTask will result in new events for the workflow execution and
        /// potentially new ActivityTask being created for corresponding decisions.  It will also create a DecisionTaskCompleted
        /// event in the history for that session.  Use the 'taskToken' provided as response of PollForDecisionTask API call
        /// for completing the DecisionTask.
        /// The response could contain a new decision task if there is one or if the request asking for one.
        pub async fn respond_decision_task_completed(
            &mut self,
            request: impl tonic::IntoRequest<super::RespondDecisionTaskCompletedRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RespondDecisionTaskCompletedResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/uber.cadence.api.v1.WorkerAPI/RespondDecisionTaskCompleted",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.WorkerAPI",
                "RespondDecisionTaskCompleted",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// RespondDecisionTaskFailed is called by application worker to indicate failure.  This results in
        /// DecisionTaskFailedEvent written to the history and a new DecisionTask created.  This API can be used by client to
        /// either clear sticky tasklist or report any panics during DecisionTask processing.  Cadence will only append first
        /// DecisionTaskFailed event to the history of workflow execution for consecutive failures.
        pub async fn respond_decision_task_failed(
            &mut self,
            request: impl tonic::IntoRequest<super::RespondDecisionTaskFailedRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RespondDecisionTaskFailedResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/uber.cadence.api.v1.WorkerAPI/RespondDecisionTaskFailed",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.WorkerAPI",
                "RespondDecisionTaskFailed",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// PollForActivityTask is called by application worker to process ActivityTask from a specific taskList.  ActivityTask
        /// is dispatched to callers whenever a ScheduleTask decision is made for a workflow execution.
        /// Application is expected to call 'RespondActivityTaskCompleted' or 'RespondActivityTaskFailed' once it is done
        /// processing the task.
        /// Application also needs to call 'RecordActivityTaskHeartbeat' API within 'heartbeatTimeoutSeconds' interval to
        /// prevent the task from getting timed out.  An event 'ActivityTaskStarted' event is also written to workflow execution
        /// history before the ActivityTask is dispatched to application worker.
        pub async fn poll_for_activity_task(
            &mut self,
            request: impl tonic::IntoRequest<super::PollForActivityTaskRequest>,
        ) -> std::result::Result<tonic::Response<super::PollForActivityTaskResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/uber.cadence.api.v1.WorkerAPI/PollForActivityTask",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.WorkerAPI",
                "PollForActivityTask",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// RespondActivityTaskCompleted is called by application worker when it is done processing an ActivityTask.  It will
        /// result in a new 'ActivityTaskCompleted' event being written to the workflow history and a new DecisionTask
        /// created for the workflow so new decisions could be made.  Use the 'taskToken' provided as response of
        /// PollForActivityTask API call for completion. It fails with 'EntityNotExistsError' if the taskToken is not valid
        /// anymore due to activity timeout.
        pub async fn respond_activity_task_completed(
            &mut self,
            request: impl tonic::IntoRequest<super::RespondActivityTaskCompletedRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RespondActivityTaskCompletedResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/uber.cadence.api.v1.WorkerAPI/RespondActivityTaskCompleted",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.WorkerAPI",
                "RespondActivityTaskCompleted",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// RespondActivityTaskCompletedByID is called by application worker when it is done processing an ActivityTask.
        /// It will result in a new 'ActivityTaskCompleted' event being written to the workflow history and a new DecisionTask
        /// created for the workflow so new decisions could be made.  Similar to RespondActivityTaskCompleted but use Domain,
        /// WorkflowID and ActivityID instead of 'taskToken' for completion. It fails with 'EntityNotExistsError'
        /// if the these IDs are not valid anymore due to activity timeout.
        pub async fn respond_activity_task_completed_by_id(
            &mut self,
            request: impl tonic::IntoRequest<super::RespondActivityTaskCompletedByIdRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RespondActivityTaskCompletedByIdResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/uber.cadence.api.v1.WorkerAPI/RespondActivityTaskCompletedByID",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.WorkerAPI",
                "RespondActivityTaskCompletedByID",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// RespondActivityTaskFailed is called by application worker when it is done processing an ActivityTask.  It will
        /// result in a new 'ActivityTaskFailed' event being written to the workflow history and a new DecisionTask
        /// created for the workflow instance so new decisions could be made.  Use the 'taskToken' provided as response of
        /// PollForActivityTask API call for completion. It fails with 'EntityNotExistsError' if the taskToken is not valid
        /// anymore due to activity timeout.
        pub async fn respond_activity_task_failed(
            &mut self,
            request: impl tonic::IntoRequest<super::RespondActivityTaskFailedRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RespondActivityTaskFailedResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/uber.cadence.api.v1.WorkerAPI/RespondActivityTaskFailed",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.WorkerAPI",
                "RespondActivityTaskFailed",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// RespondActivityTaskFailedByID is called by application worker when it is done processing an ActivityTask.
        /// It will result in a new 'ActivityTaskFailed' event being written to the workflow history and a new DecisionTask
        /// created for the workflow instance so new decisions could be made.  Similar to RespondActivityTaskFailed but use
        /// Domain, WorkflowID and ActivityID instead of 'taskToken' for completion. It fails with 'EntityNotExistsError'
        /// if the these IDs are not valid anymore due to activity timeout.
        pub async fn respond_activity_task_failed_by_id(
            &mut self,
            request: impl tonic::IntoRequest<super::RespondActivityTaskFailedByIdRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RespondActivityTaskFailedByIdResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/uber.cadence.api.v1.WorkerAPI/RespondActivityTaskFailedByID",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.WorkerAPI",
                "RespondActivityTaskFailedByID",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// RespondActivityTaskCanceled is called by application worker when it is successfully canceled an ActivityTask.
        /// It will result in a new 'ActivityTaskCanceled' event being written to the workflow history and a new DecisionTask
        /// created for the workflow instance so new decisions could be made.  Use the 'taskToken' provided as response of
        /// PollForActivityTask API call for completion. It fails with 'EntityNotExistsError' if the taskToken is not valid
        /// anymore due to activity timeout.
        pub async fn respond_activity_task_canceled(
            &mut self,
            request: impl tonic::IntoRequest<super::RespondActivityTaskCanceledRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RespondActivityTaskCanceledResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/uber.cadence.api.v1.WorkerAPI/RespondActivityTaskCanceled",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.WorkerAPI",
                "RespondActivityTaskCanceled",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// RespondActivityTaskCanceledByID is called by application worker when it is successfully canceled an ActivityTask.
        /// It will result in a new 'ActivityTaskCanceled' event being written to the workflow history and a new DecisionTask
        /// created for the workflow instance so new decisions could be made.  Similar to RespondActivityTaskCanceled but use
        /// Domain, WorkflowID and ActivityID instead of 'taskToken' for completion. It fails with 'EntityNotExistsError'
        /// if the these IDs are not valid anymore due to activity timeout.
        pub async fn respond_activity_task_canceled_by_id(
            &mut self,
            request: impl tonic::IntoRequest<super::RespondActivityTaskCanceledByIdRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RespondActivityTaskCanceledByIdResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/uber.cadence.api.v1.WorkerAPI/RespondActivityTaskCanceledByID",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.WorkerAPI",
                "RespondActivityTaskCanceledByID",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// RecordActivityTaskHeartbeat is called by application worker while it is processing an ActivityTask.  If worker fails
        /// to heartbeat within 'heartbeatTimeoutSeconds' interval for the ActivityTask, then it will be marked as timedout and
        /// 'ActivityTaskTimedOut' event will be written to the workflow history.  Calling 'RecordActivityTaskHeartbeat' will
        /// fail with 'EntityNotExistsError' in such situations.  Use the 'taskToken' provided as response of
        /// PollForActivityTask API call for heartbeating.
        pub async fn record_activity_task_heartbeat(
            &mut self,
            request: impl tonic::IntoRequest<super::RecordActivityTaskHeartbeatRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RecordActivityTaskHeartbeatResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/uber.cadence.api.v1.WorkerAPI/RecordActivityTaskHeartbeat",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.WorkerAPI",
                "RecordActivityTaskHeartbeat",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// RecordActivityTaskHeartbeatByID is called by application worker while it is processing an ActivityTask.  If worker
        /// fails to heartbeat within 'heartbeatTimeoutSeconds' interval for the ActivityTask, then it will be marked as
        /// timed out and 'ActivityTaskTimedOut' event will be written to the workflow history.
        /// Calling 'RecordActivityTaskHeartbeatByID' will fail with 'EntityNotExistsError' in such situations.  Instead of
        /// using 'taskToken' like in RecordActivityTaskHeartbeat, use Domain, WorkflowID and ActivityID.
        pub async fn record_activity_task_heartbeat_by_id(
            &mut self,
            request: impl tonic::IntoRequest<super::RecordActivityTaskHeartbeatByIdRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RecordActivityTaskHeartbeatByIdResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/uber.cadence.api.v1.WorkerAPI/RecordActivityTaskHeartbeatByID",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.WorkerAPI",
                "RecordActivityTaskHeartbeatByID",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// RespondQueryTaskCompleted is called by application worker to complete a QueryTask (which is a DecisionTask for query)
        /// as a result of 'PollForDecisionTask' API call. Completing a QueryTask will unblock the client call to 'QueryWorkflow'
        /// API and return the query result to client as a response to 'QueryWorkflow' API call.
        pub async fn respond_query_task_completed(
            &mut self,
            request: impl tonic::IntoRequest<super::RespondQueryTaskCompletedRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RespondQueryTaskCompletedResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/uber.cadence.api.v1.WorkerAPI/RespondQueryTaskCompleted",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.WorkerAPI",
                "RespondQueryTaskCompleted",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Reset the sticky tasklist related information in mutable state of a given workflow.
        /// Things cleared are:
        /// 1. StickyTaskList
        /// 2. StickyScheduleToStartTimeout
        /// 3. ClientLibraryVersion
        /// 4. ClientFeatureVersion
        /// 5. ClientImpl
        pub async fn reset_sticky_task_list(
            &mut self,
            request: impl tonic::IntoRequest<super::ResetStickyTaskListRequest>,
        ) -> std::result::Result<tonic::Response<super::ResetStickyTaskListResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/uber.cadence.api.v1.WorkerAPI/ResetStickyTaskList",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.WorkerAPI",
                "ResetStickyTaskList",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Domain {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "DomainStatus", tag = "3")]
    pub status: i32,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub owner_email: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "6")]
    pub data:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    #[prost(message, optional, tag = "7")]
    pub workflow_execution_retention_period: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "8")]
    pub bad_binaries: ::core::option::Option<BadBinaries>,
    #[prost(enumeration = "ArchivalStatus", tag = "9")]
    pub history_archival_status: i32,
    #[prost(string, tag = "10")]
    pub history_archival_uri: ::prost::alloc::string::String,
    #[prost(enumeration = "ArchivalStatus", tag = "11")]
    pub visibility_archival_status: i32,
    #[prost(string, tag = "12")]
    pub visibility_archival_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "13")]
    pub active_cluster_name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "14")]
    pub clusters: ::prost::alloc::vec::Vec<ClusterReplicationConfiguration>,
    #[prost(int64, tag = "15")]
    pub failover_version: i64,
    #[prost(bool, tag = "16")]
    pub is_global_domain: bool,
    #[prost(message, optional, tag = "17")]
    pub failover_info: ::core::option::Option<FailoverInfo>,
    #[prost(message, optional, tag = "18")]
    pub isolation_groups: ::core::option::Option<IsolationGroupConfiguration>,
    #[prost(message, optional, tag = "19")]
    pub async_workflow_config: ::core::option::Option<AsyncWorkflowConfiguration>,
    #[prost(message, optional, tag = "20")]
    pub active_clusters: ::core::option::Option<ActiveClusters>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClusterReplicationConfiguration {
    #[prost(string, tag = "1")]
    pub cluster_name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BadBinaries {
    #[prost(map = "string, message", tag = "1")]
    pub binaries: ::std::collections::HashMap<::prost::alloc::string::String, BadBinaryInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BadBinaryInfo {
    #[prost(string, tag = "1")]
    pub reason: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub operator: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub created_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FailoverInfo {
    #[prost(int64, tag = "1")]
    pub failover_version: i64,
    #[prost(message, optional, tag = "2")]
    pub failover_start_timestamp: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub failover_expire_timestamp: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(int32, tag = "4")]
    pub completed_shard_count: i32,
    #[prost(int32, repeated, tag = "5")]
    pub pending_shards: ::prost::alloc::vec::Vec<i32>,
}
/// ActiveClusters contains the configuration of active-active domain's active clusters/regions
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActiveClusters {
    /// todo (david.porter) to remove as this is no longer used
    #[prost(map = "string, message", tag = "1")]
    pub region_to_cluster:
        ::std::collections::HashMap<::prost::alloc::string::String, ActiveClusterInfo>,
    #[prost(map = "string, message", tag = "2")]
    pub active_clusters_by_cluster_attribute:
        ::std::collections::HashMap<::prost::alloc::string::String, ClusterAttributeScope>,
}
/// ClusterAttributeScope refers to the domain's record of what cluster attributes
/// are allocated to which clusters, indexed by the cluster attribute key (for example region, city)
/// and given a failover identifier to keep track of the most recent updates
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClusterAttributeScope {
    #[prost(map = "string, message", tag = "1")]
    pub cluster_attributes:
        ::std::collections::HashMap<::prost::alloc::string::String, ActiveClusterInfo>,
}
/// ActiveClusterInfo contains information about the cluster that's active for
/// the given cluster-attribute and the failover version, indicating how recent
/// the change was for this attribute
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActiveClusterInfo {
    #[prost(string, tag = "1")]
    pub active_cluster_name: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub failover_version: i64,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DomainStatus {
    Invalid = 0,
    Registered = 1,
    Deprecated = 2,
    Deleted = 3,
}
impl DomainStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "DOMAIN_STATUS_INVALID",
            Self::Registered => "DOMAIN_STATUS_REGISTERED",
            Self::Deprecated => "DOMAIN_STATUS_DEPRECATED",
            Self::Deleted => "DOMAIN_STATUS_DELETED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DOMAIN_STATUS_INVALID" => Some(Self::Invalid),
            "DOMAIN_STATUS_REGISTERED" => Some(Self::Registered),
            "DOMAIN_STATUS_DEPRECATED" => Some(Self::Deprecated),
            "DOMAIN_STATUS_DELETED" => Some(Self::Deleted),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ArchivalStatus {
    Invalid = 0,
    Disabled = 1,
    Enabled = 2,
}
impl ArchivalStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "ARCHIVAL_STATUS_INVALID",
            Self::Disabled => "ARCHIVAL_STATUS_DISABLED",
            Self::Enabled => "ARCHIVAL_STATUS_ENABLED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ARCHIVAL_STATUS_INVALID" => Some(Self::Invalid),
            "ARCHIVAL_STATUS_DISABLED" => Some(Self::Disabled),
            "ARCHIVAL_STATUS_ENABLED" => Some(Self::Enabled),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkflowExecutionFilter {
    #[prost(string, tag = "1")]
    pub workflow_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub run_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkflowTypeFilter {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StartTimeFilter {
    #[prost(message, optional, tag = "1")]
    pub earliest_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub latest_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StatusFilter {
    #[prost(enumeration = "WorkflowExecutionCloseStatus", tag = "1")]
    pub status: i32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IndexedValueType {
    Invalid = 0,
    String = 1,
    Keyword = 2,
    Int = 3,
    Double = 4,
    Bool = 5,
    Datetime = 6,
}
impl IndexedValueType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "INDEXED_VALUE_TYPE_INVALID",
            Self::String => "INDEXED_VALUE_TYPE_STRING",
            Self::Keyword => "INDEXED_VALUE_TYPE_KEYWORD",
            Self::Int => "INDEXED_VALUE_TYPE_INT",
            Self::Double => "INDEXED_VALUE_TYPE_DOUBLE",
            Self::Bool => "INDEXED_VALUE_TYPE_BOOL",
            Self::Datetime => "INDEXED_VALUE_TYPE_DATETIME",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INDEXED_VALUE_TYPE_INVALID" => Some(Self::Invalid),
            "INDEXED_VALUE_TYPE_STRING" => Some(Self::String),
            "INDEXED_VALUE_TYPE_KEYWORD" => Some(Self::Keyword),
            "INDEXED_VALUE_TYPE_INT" => Some(Self::Int),
            "INDEXED_VALUE_TYPE_DOUBLE" => Some(Self::Double),
            "INDEXED_VALUE_TYPE_BOOL" => Some(Self::Bool),
            "INDEXED_VALUE_TYPE_DATETIME" => Some(Self::Datetime),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestartWorkflowExecutionRequest {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub workflow_execution: ::core::option::Option<WorkflowExecution>,
    #[prost(string, tag = "3")]
    pub identity: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub reason: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiagnoseWorkflowExecutionRequest {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub workflow_execution: ::core::option::Option<WorkflowExecution>,
    #[prost(string, tag = "3")]
    pub identity: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiagnoseWorkflowExecutionResponse {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub diagnostic_workflow_execution: ::core::option::Option<WorkflowExecution>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartWorkflowExecutionRequest {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub workflow_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub workflow_type: ::core::option::Option<WorkflowType>,
    #[prost(message, optional, tag = "4")]
    pub task_list: ::core::option::Option<TaskList>,
    #[prost(message, optional, tag = "5")]
    pub input: ::core::option::Option<Payload>,
    #[prost(message, optional, tag = "6")]
    pub execution_start_to_close_timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "7")]
    pub task_start_to_close_timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(string, tag = "8")]
    pub identity: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(enumeration = "WorkflowIdReusePolicy", tag = "10")]
    pub workflow_id_reuse_policy: i32,
    #[prost(message, optional, tag = "11")]
    pub retry_policy: ::core::option::Option<RetryPolicy>,
    #[prost(string, tag = "12")]
    pub cron_schedule: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "13")]
    pub memo: ::core::option::Option<Memo>,
    #[prost(message, optional, tag = "14")]
    pub search_attributes: ::core::option::Option<SearchAttributes>,
    #[prost(message, optional, tag = "15")]
    pub header: ::core::option::Option<Header>,
    #[prost(message, optional, tag = "16")]
    pub delay_start: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "17")]
    pub jitter_start: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "18")]
    pub first_run_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration = "CronOverlapPolicy", tag = "19")]
    pub cron_overlap_policy: i32,
    #[prost(message, optional, tag = "20")]
    pub active_cluster_selection_policy: ::core::option::Option<ActiveClusterSelectionPolicy>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartWorkflowExecutionResponse {
    #[prost(string, tag = "1")]
    pub run_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartWorkflowExecutionAsyncRequest {
    #[prost(message, optional, tag = "1")]
    pub request: ::core::option::Option<StartWorkflowExecutionRequest>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StartWorkflowExecutionAsyncResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestartWorkflowExecutionResponse {
    #[prost(string, tag = "1")]
    pub run_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignalWorkflowExecutionRequest {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub workflow_execution: ::core::option::Option<WorkflowExecution>,
    #[prost(string, tag = "3")]
    pub identity: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub signal_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub signal_input: ::core::option::Option<Payload>,
    #[prost(bytes = "vec", tag = "7")]
    pub control: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SignalWorkflowExecutionResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignalWithStartWorkflowExecutionRequest {
    #[prost(message, optional, tag = "1")]
    pub start_request: ::core::option::Option<StartWorkflowExecutionRequest>,
    #[prost(string, tag = "2")]
    pub signal_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub signal_input: ::core::option::Option<Payload>,
    #[prost(bytes = "vec", tag = "4")]
    pub control: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignalWithStartWorkflowExecutionResponse {
    #[prost(string, tag = "1")]
    pub run_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignalWithStartWorkflowExecutionAsyncRequest {
    #[prost(message, optional, tag = "1")]
    pub request: ::core::option::Option<SignalWithStartWorkflowExecutionRequest>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SignalWithStartWorkflowExecutionAsyncResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResetWorkflowExecutionRequest {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub workflow_execution: ::core::option::Option<WorkflowExecution>,
    #[prost(string, tag = "3")]
    pub reason: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub decision_finish_event_id: i64,
    #[prost(string, tag = "5")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "6")]
    pub skip_signal_reapply: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResetWorkflowExecutionResponse {
    #[prost(string, tag = "1")]
    pub run_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestCancelWorkflowExecutionRequest {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub workflow_execution: ::core::option::Option<WorkflowExecution>,
    #[prost(string, tag = "3")]
    pub identity: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub cause: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub first_execution_run_id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RequestCancelWorkflowExecutionResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TerminateWorkflowExecutionRequest {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub workflow_execution: ::core::option::Option<WorkflowExecution>,
    #[prost(string, tag = "3")]
    pub reason: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub details: ::core::option::Option<Payload>,
    #[prost(string, tag = "5")]
    pub identity: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub first_execution_run_id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TerminateWorkflowExecutionResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescribeWorkflowExecutionRequest {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub workflow_execution: ::core::option::Option<WorkflowExecution>,
    /// QueryConsistencyLevel is used to override the default cluster configured read-pattern for this query.
    #[prost(enumeration = "QueryConsistencyLevel", tag = "3")]
    pub query_consistency_level: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescribeWorkflowExecutionResponse {
    #[prost(message, optional, tag = "1")]
    pub execution_configuration: ::core::option::Option<WorkflowExecutionConfiguration>,
    #[prost(message, optional, tag = "2")]
    pub workflow_execution_info: ::core::option::Option<WorkflowExecutionInfo>,
    #[prost(message, repeated, tag = "3")]
    pub pending_activities: ::prost::alloc::vec::Vec<PendingActivityInfo>,
    #[prost(message, repeated, tag = "4")]
    pub pending_children: ::prost::alloc::vec::Vec<PendingChildExecutionInfo>,
    #[prost(message, optional, tag = "5")]
    pub pending_decision: ::core::option::Option<PendingDecisionInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryWorkflowRequest {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub workflow_execution: ::core::option::Option<WorkflowExecution>,
    #[prost(message, optional, tag = "3")]
    pub query: ::core::option::Option<WorkflowQuery>,
    #[prost(enumeration = "QueryRejectCondition", tag = "4")]
    pub query_reject_condition: i32,
    /// QueryConsistencyLevel is used to override the default cluster configured read-pattern for this query.
    #[prost(enumeration = "QueryConsistencyLevel", tag = "5")]
    pub query_consistency_level: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryWorkflowResponse {
    #[prost(message, optional, tag = "1")]
    pub query_result: ::core::option::Option<Payload>,
    #[prost(message, optional, tag = "2")]
    pub query_rejected: ::core::option::Option<QueryRejected>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescribeTaskListRequest {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub task_list: ::core::option::Option<TaskList>,
    #[prost(enumeration = "TaskListType", tag = "3")]
    pub task_list_type: i32,
    #[prost(bool, tag = "4")]
    pub include_task_list_status: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescribeTaskListResponse {
    #[prost(message, repeated, tag = "1")]
    pub pollers: ::prost::alloc::vec::Vec<PollerInfo>,
    #[prost(message, optional, tag = "2")]
    pub task_list_status: ::core::option::Option<TaskListStatus>,
    #[prost(message, optional, tag = "3")]
    pub partition_config: ::core::option::Option<TaskListPartitionConfig>,
    /// The TaskList being described
    #[prost(message, optional, tag = "4")]
    pub task_list: ::core::option::Option<TaskList>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTaskListsByDomainRequest {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTaskListsByDomainResponse {
    #[prost(map = "string, message", tag = "1")]
    pub decision_task_list_map:
        ::std::collections::HashMap<::prost::alloc::string::String, DescribeTaskListResponse>,
    #[prost(map = "string, message", tag = "2")]
    pub activity_task_list_map:
        ::std::collections::HashMap<::prost::alloc::string::String, DescribeTaskListResponse>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTaskListPartitionsRequest {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub task_list: ::core::option::Option<TaskList>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTaskListPartitionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub activity_task_list_partitions: ::prost::alloc::vec::Vec<TaskListPartitionMetadata>,
    #[prost(message, repeated, tag = "2")]
    pub decision_task_list_partitions: ::prost::alloc::vec::Vec<TaskListPartitionMetadata>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetClusterInfoRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetClusterInfoResponse {
    #[prost(message, optional, tag = "1")]
    pub supported_client_versions: ::core::option::Option<SupportedClientVersions>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetWorkflowExecutionHistoryRequest {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub workflow_execution: ::core::option::Option<WorkflowExecution>,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(bytes = "vec", tag = "4")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
    #[prost(bool, tag = "5")]
    pub wait_for_new_event: bool,
    #[prost(enumeration = "EventFilterType", tag = "6")]
    pub history_event_filter_type: i32,
    #[prost(bool, tag = "7")]
    pub skip_archival: bool,
    /// QueryConsistencyLevel is used to override the default cluster configured read-pattern for this query.
    #[prost(enumeration = "QueryConsistencyLevel", tag = "8")]
    pub query_consistency_level: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetWorkflowExecutionHistoryResponse {
    #[prost(message, optional, tag = "1")]
    pub history: ::core::option::Option<History>,
    #[prost(message, repeated, tag = "2")]
    pub raw_history: ::prost::alloc::vec::Vec<DataBlob>,
    #[prost(bytes = "vec", tag = "3")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
    #[prost(bool, tag = "4")]
    pub archived: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeatureFlags {
    #[prost(bool, tag = "1")]
    pub workflow_execution_already_completed_error_enabled: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RefreshWorkflowTasksRequest {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub workflow_execution: ::core::option::Option<WorkflowExecution>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RefreshWorkflowTasksResponse {}
/// Generated client implementations.
pub mod workflow_api_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    #[derive(Debug, Clone)]
    pub struct WorkflowApiClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl WorkflowApiClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> WorkflowApiClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> WorkflowApiClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            WorkflowApiClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// RestartWorkflowExecution restarts a previous workflow
        /// If the workflow is currently running it will terminate and restart
        pub async fn restart_workflow_execution(
            &mut self,
            request: impl tonic::IntoRequest<super::RestartWorkflowExecutionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RestartWorkflowExecutionResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/uber.cadence.api.v1.WorkflowAPI/RestartWorkflowExecution",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.WorkflowAPI",
                "RestartWorkflowExecution",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// StartWorkflowExecution starts a new long running workflow instance.  It will create the instance with
        /// 'WorkflowExecutionStarted' event in history and also schedule the first DecisionTask for the worker to make the
        /// first decision for this instance.  It will return 'WorkflowExecutionAlreadyStartedError', if an instance already
        /// exists with same workflowId.
        pub async fn start_workflow_execution(
            &mut self,
            request: impl tonic::IntoRequest<super::StartWorkflowExecutionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::StartWorkflowExecutionResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/uber.cadence.api.v1.WorkflowAPI/StartWorkflowExecution",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.WorkflowAPI",
                "StartWorkflowExecution",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// StartWorkflowExecutionAsync starts a new long running workflow instance asynchronously. It will push a StartWorkflowExecutionRequest to a queue
        /// and immediately return a response. The request will be processed by a separate consumer eventually.
        pub async fn start_workflow_execution_async(
            &mut self,
            request: impl tonic::IntoRequest<super::StartWorkflowExecutionAsyncRequest>,
        ) -> std::result::Result<
            tonic::Response<super::StartWorkflowExecutionAsyncResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/uber.cadence.api.v1.WorkflowAPI/StartWorkflowExecutionAsync",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.WorkflowAPI",
                "StartWorkflowExecutionAsync",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// SignalWorkflowExecution is used to send a signal event to running workflow execution.  This results in
        /// WorkflowExecutionSignaled event recorded in the history and a decision task being created for the execution.
        pub async fn signal_workflow_execution(
            &mut self,
            request: impl tonic::IntoRequest<super::SignalWorkflowExecutionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SignalWorkflowExecutionResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/uber.cadence.api.v1.WorkflowAPI/SignalWorkflowExecution",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.WorkflowAPI",
                "SignalWorkflowExecution",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// SignalWithStartWorkflowExecution is used to ensure sending signal to a workflow.  If the workflow is running,
        /// this results in WorkflowExecutionSignaled event being recorded in the history and a decision task being created for
        /// the execution.  If the workflow is not running or not found, this results in WorkflowExecutionStarted and
        /// WorkflowExecutionSignaled events being recorded in history, and a decision task being created for the execution.
        pub async fn signal_with_start_workflow_execution(
            &mut self,
            request: impl tonic::IntoRequest<super::SignalWithStartWorkflowExecutionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SignalWithStartWorkflowExecutionResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/uber.cadence.api.v1.WorkflowAPI/SignalWithStartWorkflowExecution",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.WorkflowAPI",
                "SignalWithStartWorkflowExecution",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// SignalWithStartWorkflowExecutionAsync is used to ensure sending signal to a workflow asynchronously.  It will push a SignalWithStartWorkflowExecutionRequest to a queue
        /// and immediately return a response. The request will be processed by a separate consumer eventually.
        pub async fn signal_with_start_workflow_execution_async(
            &mut self,
            request: impl tonic::IntoRequest<super::SignalWithStartWorkflowExecutionAsyncRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SignalWithStartWorkflowExecutionAsyncResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/uber.cadence.api.v1.WorkflowAPI/SignalWithStartWorkflowExecutionAsync",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.WorkflowAPI",
                "SignalWithStartWorkflowExecutionAsync",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// ResetWorkflowExecution reset an existing workflow execution to DecisionTaskCompleted event(exclusive).
        /// And it will immediately terminating the current execution instance.
        pub async fn reset_workflow_execution(
            &mut self,
            request: impl tonic::IntoRequest<super::ResetWorkflowExecutionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ResetWorkflowExecutionResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/uber.cadence.api.v1.WorkflowAPI/ResetWorkflowExecution",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.WorkflowAPI",
                "ResetWorkflowExecution",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// RequestCancelWorkflowExecution requests cancellation of a workflow instance.
        /// It allows workflow to properly clean up and gracefully close.
        pub async fn request_cancel_workflow_execution(
            &mut self,
            request: impl tonic::IntoRequest<super::RequestCancelWorkflowExecutionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RequestCancelWorkflowExecutionResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/uber.cadence.api.v1.WorkflowAPI/RequestCancelWorkflowExecution",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.WorkflowAPI",
                "RequestCancelWorkflowExecution",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// TerminateWorkflowExecution terminates an existing workflow execution by recording WorkflowExecutionTerminated event
        /// in the history and immediately terminating the execution instance.
        pub async fn terminate_workflow_execution(
            &mut self,
            request: impl tonic::IntoRequest<super::TerminateWorkflowExecutionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TerminateWorkflowExecutionResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/uber.cadence.api.v1.WorkflowAPI/TerminateWorkflowExecution",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.WorkflowAPI",
                "TerminateWorkflowExecution",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// DescribeWorkflowExecution returns information about the specified workflow execution.
        pub async fn describe_workflow_execution(
            &mut self,
            request: impl tonic::IntoRequest<super::DescribeWorkflowExecutionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DescribeWorkflowExecutionResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/uber.cadence.api.v1.WorkflowAPI/DescribeWorkflowExecution",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.WorkflowAPI",
                "DescribeWorkflowExecution",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// QueryWorkflow returns query result for a specified workflow execution.
        pub async fn query_workflow(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryWorkflowRequest>,
        ) -> std::result::Result<tonic::Response<super::QueryWorkflowResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/uber.cadence.api.v1.WorkflowAPI/QueryWorkflow",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.WorkflowAPI",
                "QueryWorkflow",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// DescribeTaskList returns information about the target tasklist, right now this API returns the
        /// pollers which polled this tasklist in last few minutes.
        pub async fn describe_task_list(
            &mut self,
            request: impl tonic::IntoRequest<super::DescribeTaskListRequest>,
        ) -> std::result::Result<tonic::Response<super::DescribeTaskListResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/uber.cadence.api.v1.WorkflowAPI/DescribeTaskList",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.WorkflowAPI",
                "DescribeTaskList",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// GetTaskListsByDomain returns all task lists for a given domain
        pub async fn get_task_lists_by_domain(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTaskListsByDomainRequest>,
        ) -> std::result::Result<tonic::Response<super::GetTaskListsByDomainResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/uber.cadence.api.v1.WorkflowAPI/GetTaskListsByDomain",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.WorkflowAPI",
                "GetTaskListsByDomain",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// ListTaskListPartitions returns information about task list partitions.
        pub async fn list_task_list_partitions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListTaskListPartitionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListTaskListPartitionsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/uber.cadence.api.v1.WorkflowAPI/ListTaskListPartitions",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.WorkflowAPI",
                "ListTaskListPartitions",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// GetClusterInfo returns information about cadence cluster.
        pub async fn get_cluster_info(
            &mut self,
            request: impl tonic::IntoRequest<super::GetClusterInfoRequest>,
        ) -> std::result::Result<tonic::Response<super::GetClusterInfoResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/uber.cadence.api.v1.WorkflowAPI/GetClusterInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.WorkflowAPI",
                "GetClusterInfo",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the history of specified workflow execution.  It fails with 'EntityNotExistError' if specified workflow
        /// execution in unknown to the service.
        pub async fn get_workflow_execution_history(
            &mut self,
            request: impl tonic::IntoRequest<super::GetWorkflowExecutionHistoryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetWorkflowExecutionHistoryResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/uber.cadence.api.v1.WorkflowAPI/GetWorkflowExecutionHistory",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.WorkflowAPI",
                "GetWorkflowExecutionHistory",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// RefreshWorkflowTasks refreshes all tasks of a workflow.
        pub async fn refresh_workflow_tasks(
            &mut self,
            request: impl tonic::IntoRequest<super::RefreshWorkflowTasksRequest>,
        ) -> std::result::Result<tonic::Response<super::RefreshWorkflowTasksResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/uber.cadence.api.v1.WorkflowAPI/RefreshWorkflowTasks",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.WorkflowAPI",
                "RefreshWorkflowTasks",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Diagnoses a workflow execution and provides a report as response
        pub async fn diagnose_workflow_execution(
            &mut self,
            request: impl tonic::IntoRequest<super::DiagnoseWorkflowExecutionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DiagnoseWorkflowExecutionResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/uber.cadence.api.v1.WorkflowAPI/DiagnoseWorkflowExecution",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.WorkflowAPI",
                "DiagnoseWorkflowExecution",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkflowExecutionAlreadyStartedError {
    #[prost(string, tag = "1")]
    pub start_request_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub run_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EntityNotExistsError {
    #[prost(string, tag = "1")]
    pub current_cluster: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub active_cluster: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub active_clusters: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WorkflowExecutionAlreadyCompletedError {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DomainNotActiveError {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub current_cluster: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub active_cluster: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "4")]
    pub active_clusters: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClientVersionNotSupportedError {
    #[prost(string, tag = "1")]
    pub feature_version: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub client_impl: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub supported_versions: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeatureNotEnabledError {
    #[prost(string, tag = "1")]
    pub feature_flag: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CancellationAlreadyRequestedError {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DomainAlreadyExistsError {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LimitExceededError {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryFailedError {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceBusyError {
    #[prost(string, tag = "1")]
    pub reason: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StickyWorkerUnavailableError {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReadOnlyPartitionError {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListWorkflowExecutionsRequest {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(bytes = "vec", tag = "3")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "4")]
    pub query: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListWorkflowExecutionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub executions: ::prost::alloc::vec::Vec<WorkflowExecutionInfo>,
    #[prost(bytes = "vec", tag = "2")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListOpenWorkflowExecutionsRequest {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(bytes = "vec", tag = "3")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "4")]
    pub start_time_filter: ::core::option::Option<StartTimeFilter>,
    #[prost(
        oneof = "list_open_workflow_executions_request::Filters",
        tags = "5, 6"
    )]
    pub filters: ::core::option::Option<list_open_workflow_executions_request::Filters>,
}
/// Nested message and enum types in `ListOpenWorkflowExecutionsRequest`.
pub mod list_open_workflow_executions_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Filters {
        #[prost(message, tag = "5")]
        ExecutionFilter(super::WorkflowExecutionFilter),
        #[prost(message, tag = "6")]
        TypeFilter(super::WorkflowTypeFilter),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListOpenWorkflowExecutionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub executions: ::prost::alloc::vec::Vec<WorkflowExecutionInfo>,
    #[prost(bytes = "vec", tag = "2")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListClosedWorkflowExecutionsRequest {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(bytes = "vec", tag = "3")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "4")]
    pub start_time_filter: ::core::option::Option<StartTimeFilter>,
    #[prost(
        oneof = "list_closed_workflow_executions_request::Filters",
        tags = "5, 6, 7"
    )]
    pub filters: ::core::option::Option<list_closed_workflow_executions_request::Filters>,
}
/// Nested message and enum types in `ListClosedWorkflowExecutionsRequest`.
pub mod list_closed_workflow_executions_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Filters {
        #[prost(message, tag = "5")]
        ExecutionFilter(super::WorkflowExecutionFilter),
        #[prost(message, tag = "6")]
        TypeFilter(super::WorkflowTypeFilter),
        #[prost(message, tag = "7")]
        StatusFilter(super::StatusFilter),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListClosedWorkflowExecutionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub executions: ::prost::alloc::vec::Vec<WorkflowExecutionInfo>,
    #[prost(bytes = "vec", tag = "2")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListArchivedWorkflowExecutionsRequest {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(bytes = "vec", tag = "3")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "4")]
    pub query: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListArchivedWorkflowExecutionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub executions: ::prost::alloc::vec::Vec<WorkflowExecutionInfo>,
    #[prost(bytes = "vec", tag = "2")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScanWorkflowExecutionsRequest {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(bytes = "vec", tag = "3")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "4")]
    pub query: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScanWorkflowExecutionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub executions: ::prost::alloc::vec::Vec<WorkflowExecutionInfo>,
    #[prost(bytes = "vec", tag = "2")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CountWorkflowExecutionsRequest {
    #[prost(string, tag = "1")]
    pub domain: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub query: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CountWorkflowExecutionsResponse {
    #[prost(int64, tag = "1")]
    pub count: i64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetSearchAttributesRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSearchAttributesResponse {
    #[prost(map = "string, enumeration(IndexedValueType)", tag = "1")]
    pub keys: ::std::collections::HashMap<::prost::alloc::string::String, i32>,
}
/// Generated client implementations.
pub mod visibility_api_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    #[derive(Debug, Clone)]
    pub struct VisibilityApiClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl VisibilityApiClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> VisibilityApiClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> VisibilityApiClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            VisibilityApiClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// ListWorkflowExecutions is a visibility API to list workflow executions in a specific domain.
        pub async fn list_workflow_executions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListWorkflowExecutionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListWorkflowExecutionsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/uber.cadence.api.v1.VisibilityAPI/ListWorkflowExecutions",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.VisibilityAPI",
                "ListWorkflowExecutions",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// ListOpenWorkflowExecutions is a visibility API to list the open executions in a specific domain.
        pub async fn list_open_workflow_executions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListOpenWorkflowExecutionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListOpenWorkflowExecutionsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/uber.cadence.api.v1.VisibilityAPI/ListOpenWorkflowExecutions",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.VisibilityAPI",
                "ListOpenWorkflowExecutions",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// ListClosedWorkflowExecutions is a visibility API to list the closed executions in a specific domain.
        pub async fn list_closed_workflow_executions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListClosedWorkflowExecutionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListClosedWorkflowExecutionsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/uber.cadence.api.v1.VisibilityAPI/ListClosedWorkflowExecutions",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.VisibilityAPI",
                "ListClosedWorkflowExecutions",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// ListArchivedWorkflowExecutions is a visibility API to list archived workflow executions in a specific domain.
        pub async fn list_archived_workflow_executions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListArchivedWorkflowExecutionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListArchivedWorkflowExecutionsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/uber.cadence.api.v1.VisibilityAPI/ListArchivedWorkflowExecutions",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.VisibilityAPI",
                "ListArchivedWorkflowExecutions",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// ScanWorkflowExecutions is a visibility API to list large amount of workflow executions in a specific domain without order.
        pub async fn scan_workflow_executions(
            &mut self,
            request: impl tonic::IntoRequest<super::ScanWorkflowExecutionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ScanWorkflowExecutionsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/uber.cadence.api.v1.VisibilityAPI/ScanWorkflowExecutions",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.VisibilityAPI",
                "ScanWorkflowExecutions",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// CountWorkflowExecutions is a visibility API to count of workflow executions in a specific domain.
        pub async fn count_workflow_executions(
            &mut self,
            request: impl tonic::IntoRequest<super::CountWorkflowExecutionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CountWorkflowExecutionsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/uber.cadence.api.v1.VisibilityAPI/CountWorkflowExecutions",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.VisibilityAPI",
                "CountWorkflowExecutions",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// GetSearchAttributes is a visibility API to get all legal keys that could be used in list APIs.
        pub async fn get_search_attributes(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSearchAttributesRequest>,
        ) -> std::result::Result<tonic::Response<super::GetSearchAttributesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/uber.cadence.api.v1.VisibilityAPI/GetSearchAttributes",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.VisibilityAPI",
                "GetSearchAttributes",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterDomainRequest {
    #[prost(string, tag = "1")]
    pub security_token: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub owner_email: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub workflow_execution_retention_period: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, repeated, tag = "6")]
    pub clusters: ::prost::alloc::vec::Vec<ClusterReplicationConfiguration>,
    #[prost(string, tag = "7")]
    pub active_cluster_name: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "8")]
    pub data:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    #[prost(bool, tag = "9")]
    pub is_global_domain: bool,
    #[prost(enumeration = "ArchivalStatus", tag = "10")]
    pub history_archival_status: i32,
    #[prost(string, tag = "11")]
    pub history_archival_uri: ::prost::alloc::string::String,
    #[prost(enumeration = "ArchivalStatus", tag = "12")]
    pub visibility_archival_status: i32,
    #[prost(string, tag = "13")]
    pub visibility_archival_uri: ::prost::alloc::string::String,
    /// todo (david.porter) to remove as this is no longer used
    #[prost(map = "string, string", tag = "14")]
    pub active_clusters_by_region:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    #[prost(message, optional, tag = "15")]
    pub active_clusters: ::core::option::Option<ActiveClusters>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RegisterDomainResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDomainRequest {
    #[prost(string, tag = "1")]
    pub security_token: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Below are the fields that can be updated if specified by update_mask.
    #[prost(message, optional, tag = "10")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(string, tag = "11")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "12")]
    pub owner_email: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "13")]
    pub data:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    #[prost(message, optional, tag = "14")]
    pub workflow_execution_retention_period: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "15")]
    pub bad_binaries: ::core::option::Option<BadBinaries>,
    #[prost(enumeration = "ArchivalStatus", tag = "16")]
    pub history_archival_status: i32,
    #[prost(string, tag = "17")]
    pub history_archival_uri: ::prost::alloc::string::String,
    #[prost(enumeration = "ArchivalStatus", tag = "18")]
    pub visibility_archival_status: i32,
    #[prost(string, tag = "19")]
    pub visibility_archival_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "20")]
    pub active_cluster_name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "21")]
    pub clusters: ::prost::alloc::vec::Vec<ClusterReplicationConfiguration>,
    #[prost(string, tag = "22")]
    pub delete_bad_binary: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "23")]
    pub failover_timeout: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "24")]
    pub active_clusters: ::core::option::Option<ActiveClusters>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDomainResponse {
    #[prost(message, optional, tag = "1")]
    pub domain: ::core::option::Option<Domain>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FailoverDomainRequest {
    #[prost(string, tag = "1")]
    pub domain_name: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub domain_active_cluster_name: ::prost::alloc::string::String,
    /// only applicable for active-active use-cases where the failover is occurring
    /// at the cluster-attribute level only
    #[prost(message, optional, tag = "30")]
    pub active_clusters: ::core::option::Option<ActiveClusters>,
    /// user-requested addition "reason" variable created to increase transparency around failovers
    #[prost(string, tag = "40")]
    pub reason: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FailoverDomainResponse {
    #[prost(message, optional, tag = "1")]
    pub domain: ::core::option::Option<Domain>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeprecateDomainRequest {
    #[prost(string, tag = "1")]
    pub security_token: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeprecateDomainResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDomainRequest {
    #[prost(string, tag = "1")]
    pub security_token: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteDomainResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescribeDomainRequest {
    #[prost(oneof = "describe_domain_request::DescribeBy", tags = "1, 2")]
    pub describe_by: ::core::option::Option<describe_domain_request::DescribeBy>,
}
/// Nested message and enum types in `DescribeDomainRequest`.
pub mod describe_domain_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum DescribeBy {
        #[prost(string, tag = "1")]
        Id(::prost::alloc::string::String),
        #[prost(string, tag = "2")]
        Name(::prost::alloc::string::String),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescribeDomainResponse {
    #[prost(message, optional, tag = "1")]
    pub domain: ::core::option::Option<Domain>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDomainsRequest {
    #[prost(int32, tag = "1")]
    pub page_size: i32,
    #[prost(bytes = "vec", tag = "2")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDomainsResponse {
    #[prost(message, repeated, tag = "1")]
    pub domains: ::prost::alloc::vec::Vec<Domain>,
    #[prost(bytes = "vec", tag = "2")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFailoverHistoryRequest {
    /// ListFailoverHistoryRequestFilters specifies the filters to apply to the request.
    /// If not provided all failover events will be returned.
    #[prost(message, optional, tag = "1")]
    pub filters: ::core::option::Option<ListFailoverHistoryRequestFilters>,
    /// PaginationOptions will be used to paginate the results.
    /// If not provided the first 5 events will be returned.
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<PaginationOptions>,
}
/// ListFailoverHistoryRequestFilters is used to filter the failover history.
/// It will be extended with additional filters (e.g ClusterAttributes) as the active-active feature is developed.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFailoverHistoryRequestFilters {
    /// domain_id is the id of the domain to list failover history for.
    /// domain_id is required.
    #[prost(string, tag = "1")]
    pub domain_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFailoverHistoryResponse {
    #[prost(message, repeated, tag = "1")]
    pub failover_events: ::prost::alloc::vec::Vec<FailoverEvent>,
    /// next_page_token can be passed in a subsequent request to fetch the next set of events.
    #[prost(bytes = "vec", tag = "2")]
    pub next_page_token: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FailoverEvent {
    /// id of the failover event
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// created_time is the time the failover event was created.
    #[prost(message, optional, tag = "2")]
    pub created_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration = "FailoverType", tag = "3")]
    pub failover_type: i32,
    /// cluster_failovers lists all failovers for this event.
    #[prost(message, repeated, tag = "4")]
    pub cluster_failovers: ::prost::alloc::vec::Vec<ClusterFailover>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClusterFailover {
    #[prost(message, optional, tag = "1")]
    pub from_cluster: ::core::option::Option<ActiveClusterInfo>,
    #[prost(message, optional, tag = "2")]
    pub to_cluster: ::core::option::Option<ActiveClusterInfo>,
    /// cluster_attribute is the scope and name for the attribute that was failed over.
    /// If the cluster_attribute is not defined this failover can be assumed to be the default ActiveCluster.
    #[prost(message, optional, tag = "3")]
    pub cluster_attribute: ::core::option::Option<ClusterAttribute>,
}
/// Generated client implementations.
pub mod domain_api_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    #[derive(Debug, Clone)]
    pub struct DomainApiClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl DomainApiClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> DomainApiClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DomainApiClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            DomainApiClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// RegisterDomain creates a new domain which can be used as a container for all resources.  Domain is a top level
        /// entity within Cadence, used as a container for all resources like workflow executions, task lists, etc.  Domain
        /// acts as a sandbox and provides isolation for all resources within the domain.  All resources belongs to exactly one
        /// domain.
        pub async fn register_domain(
            &mut self,
            request: impl tonic::IntoRequest<super::RegisterDomainRequest>,
        ) -> std::result::Result<tonic::Response<super::RegisterDomainResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/uber.cadence.api.v1.DomainAPI/RegisterDomain",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.DomainAPI",
                "RegisterDomain",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// DescribeDomain returns the information and configuration for a registered domain.
        pub async fn describe_domain(
            &mut self,
            request: impl tonic::IntoRequest<super::DescribeDomainRequest>,
        ) -> std::result::Result<tonic::Response<super::DescribeDomainResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/uber.cadence.api.v1.DomainAPI/DescribeDomain",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.DomainAPI",
                "DescribeDomain",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// ListDomains returns the information and configuration for all domains.
        pub async fn list_domains(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDomainsRequest>,
        ) -> std::result::Result<tonic::Response<super::ListDomainsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/uber.cadence.api.v1.DomainAPI/ListDomains");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.DomainAPI",
                "ListDomains",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// UpdateDomain is used to update the information and configuration for a registered domain.
        pub async fn update_domain(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateDomainRequest>,
        ) -> std::result::Result<tonic::Response<super::UpdateDomainResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/uber.cadence.api.v1.DomainAPI/UpdateDomain");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.DomainAPI",
                "UpdateDomain",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// FailoverDomain is used to failover a registered domain to a different cluster
        pub async fn failover_domain(
            &mut self,
            request: impl tonic::IntoRequest<super::FailoverDomainRequest>,
        ) -> std::result::Result<tonic::Response<super::FailoverDomainResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/uber.cadence.api.v1.DomainAPI/FailoverDomain",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.DomainAPI",
                "FailoverDomain",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// DeprecateDomain us used to update status of a registered domain to DEPRECATED.  Once the domain is deprecated
        /// it cannot be used to start new workflow executions.  Existing workflow executions will continue to run on
        /// deprecated domains.
        pub async fn deprecate_domain(
            &mut self,
            request: impl tonic::IntoRequest<super::DeprecateDomainRequest>,
        ) -> std::result::Result<tonic::Response<super::DeprecateDomainResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/uber.cadence.api.v1.DomainAPI/DeprecateDomain",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.DomainAPI",
                "DeprecateDomain",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// DeleteDomain permanently removes a domain record. This operation:
        /// - Requires domain to be in DEPRECATED status
        /// - Cannot be performed on domains with running workflows
        /// - Is irreversible and removes all domain data
        /// - Requires proper permissions and security token
        pub async fn delete_domain(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteDomainRequest>,
        ) -> std::result::Result<tonic::Response<super::DeleteDomainResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/uber.cadence.api.v1.DomainAPI/DeleteDomain");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.DomainAPI",
                "DeleteDomain",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// ListFailoverHistory returns the history of failover events for a domain.
        pub async fn list_failover_history(
            &mut self,
            request: impl tonic::IntoRequest<super::ListFailoverHistoryRequest>,
        ) -> std::result::Result<tonic::Response<super::ListFailoverHistoryResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/uber.cadence.api.v1.DomainAPI/ListFailoverHistory",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "uber.cadence.api.v1.DomainAPI",
                "ListFailoverHistory",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
