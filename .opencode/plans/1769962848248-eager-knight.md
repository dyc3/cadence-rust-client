# Cadence Go Client to Rust Porting Plan

## Overview

This plan outlines the approach for porting the Cadence workflow orchestration Go client to Rust. The goal is to create a fully-featured, idiomatic Rust client that maintains compatibility with the Cadence server.

## Phase 1: Project Setup and Infrastructure

### 1.1 Initialize Rust Project
- Create `Cargo.toml` with workspace structure
- Set up core crate structure:
  - `cadence-client` - Main client library
  - `cadence-worker` - Worker implementation
  - `cadence-workflow` - Workflow SDK
  - `cadence-activity` - Activity SDK
  - `cadence-proto` - Generated protocol code
  - `cadence-testsuite` - Testing utilities

### 1.2 Protocol Layer (Highest Priority)
**Goal**: Generate Rust code from Cadence IDLs for server communication

**Tasks**:
1. Add `cadence-idl` as a git submodule or fetch Thrift/Protobuf definitions
2. Set up code generation pipeline:
   - Use `thrift` crate for Thrift protocol (primary)
   - Use `prost` for Protobuf (if needed)
3. Generate service client interfaces:
   - `WorkflowService` client interface
   - All request/response types
   - Shared types (WorkflowExecution, HistoryEvent, etc.)
4. Implement transport layer:
   - TChannel support (using custom implementation or thrift transport)
   - gRPC support (optional, for future compatibility)

**Key Files**:
- `cadence-proto/build.rs` - Build script for code generation
- `cadence-proto/src/` - Generated and hand-written protocol code

**Dependencies**:
- `thrift` - Thrift protocol support
- `tonic` (optional) - gRPC support
- `prost` - Protobuf support

### 1.3 Core Types and Error Handling
**Goal**: Port fundamental types and error system

**Tasks**:
1. Define core types:
   - `WorkflowExecution`, `WorkflowID`, `RunID`
   - `TaskList`, `TaskListType`
   - `HistoryEvent`, `HistoryEventIterator`
   - `EncodedValue` for serialization
2. Implement error types:
   - `CustomError` - Workflow-defined errors
   - `CanceledError` - Cancellation errors
   - `TimeoutError` - Timeout errors
   - `TerminatedError` - Termination errors
   - `GenericError` - Generic workflow errors
   - `PanicError` - Panic recovery errors
   - `ContinueAsNewError` - Continue-as-new signal
   - `UnknownExternalWorkflowExecutionError`
3. Create serialization framework:
   - Trait-based encoding/decoding
   - JSON support (default)
   - Custom serializers support

**Key Files**:
- `cadence-client/src/types.rs`
- `cadence-client/src/error.rs`
- `cadence-client/src/encoded.rs`

## Phase 2: Client Implementation

### 2.1 Workflow Client
**Goal**: Port the main client interface for workflow operations

**Tasks**:
1. Define `Client` trait:
   - `start_workflow()` - Start workflow execution
   - `execute_workflow()` - Start and wait for result
   - `get_workflow()` - Get existing workflow handle
   - `signal_workflow()` - Send signals
   - `signal_with_start_workflow()` - Signal or start
   - `cancel_workflow()` - Cancel execution
   - `terminate_workflow()` - Terminate execution
   - `query_workflow()` - Query workflow state
   - `complete_activity()` - Complete async activities
   - `record_activity_heartbeat()` - Send heartbeats
   - List operations: `list_closed_workflow()`, `list_open_workflow()`, `list_workflow()`, `scan_workflow()`, `count_workflow()`
   - `get_workflow_history()` - Retrieve history
   - `describe_workflow_execution()` - Get execution info
   - `describe_task_list()` - Get task list info
   - `reset_workflow()` - Reset execution
   - `refresh_workflow_tasks()` - Refresh tasks

2. Implement `ClientOptions`:
   - Identity, metrics scope, logger
   - Feature flags
   - Data converters/serializers
   - Authorization providers (JWT, OAuth)

3. Create client factory:
   - `Client::new()` constructor
   - Builder pattern for configuration

**Key Files**:
- `cadence-client/src/client.rs`
- `cadence-client/src/client_impl.rs`

### 2.2 Domain Client
**Goal**: Port domain management operations

**Tasks**:
1. Define `DomainClient` trait:
   - `register()` - Register domain
   - `describe()` - Get domain info
   - `update()` - Update domain config
   - `failover()` - Failover to different cluster

2. Implement domain types:
   - `DomainInfo`, `DomainConfiguration`
   - `ReplicationConfiguration`
   - `ClusterAttribute`, `ActiveClusterSelectionPolicy`

**Key Files**:
- `cadence-client/src/domain_client.rs`

### 2.3 Worker Implementation
**Goal**: Port the worker for hosting workflows and activities

**Tasks**:
1. Define `Worker` trait:
   - `start()` - Non-blocking start
   - `run()` - Blocking start with graceful shutdown
   - `stop()` - Clean shutdown

2. Implement `Registry` trait:
   - `register_workflow()` - Register workflow functions
   - `register_workflow_with_options()` - With custom options
   - `get_registered_workflows()` - List registered
   - `register_activity()` - Register activity functions
   - `register_activity_with_options()` - With custom options
   - `get_registered_activities()` - List registered

3. Create worker options:
   - Task list configuration
   - Concurrency settings (max concurrent tasks)
   - Rate limiting
   - Session options
   - Auto-scaler configuration
   - Sticky execution cache size
   - Deadlock detection timeout
   - Non-deterministic workflow policy
   - Interceptors

4. Implement core worker logic:
   - Task pollers (decision and activity)
   - Task handlers
   - Workflow state machine
   - Activity execution
   - Heartbeat management

**Key Files**:
- `cadence-worker/src/worker.rs`
- `cadence-worker/src/registry.rs`
- `cadence-worker/src/task_pollers.rs`
- `cadence-worker/src/task_handlers.rs`
- `cadence-worker/src/workflow_state_machine.rs`

## Phase 3: Workflow SDK

### 3.1 Workflow Context and Core Functions
**Goal**: Port the workflow authoring API

**Tasks**:
1. Define `WorkflowContext`:
   - Context propagation (parent/child)
   - Cancellation support
   - Workflow info (ID, run ID, start time, etc.)
   - Search attributes

2. Implement workflow functions:
   - `execute_activity()` - Schedule activity
   - `execute_local_activity()` - Execute short activity in workflow thread
   - `execute_child_workflow()` - Start child workflow
   - `get_signal_channel()` - Receive signals
   - `signal_external_workflow()` - Signal other workflows
   - `request_cancel_external_workflow()` - Cancel external workflow
   - `side_effect()` - Non-deterministic operation wrapper
   - `mutable_side_effect()` - Cached side effect
   - `get_version()` - Versioning for backwards compatibility
   - `set_query_handler()` - Handle queries
   - `upsert_search_attributes()` - Update search attrs
   - `sleep()` - Workflow-aware sleep
   - `now()` - Workflow deterministic time
   - `new_timer()` - Create timer future
   - `get_logger()` - Get contextual logger
   - `get_metrics_scope()` - Get metrics

3. Create workflow types:
   - `ChildWorkflowFuture` - Future for child workflow
   - `ActivityFuture` - Future for activity
   - `TimerFuture` - Timer future
   - `Selector` - For waiting on multiple futures
   - `Channel` - Workflow-aware channels

4. Implement workflow errors:
   - `ContinueAsNewError` - Continue workflow with new run
   - `TimeoutError` - Activity/workflow timeout
   - `TerminatedError` - Workflow terminated
   - `PanicError` - Workflow panic recovery
   - `UnknownExternalWorkflowExecutionError`

**Key Files**:
- `cadence-workflow/src/context.rs`
- `cadence-workflow/src/lib.rs`
- `cadence-workflow/src/futures.rs`
- `cadence-workflow/src/channel.rs`
- `cadence-workflow/src/selector.rs`

### 3.2 Deterministic Execution
**Goal**: Ensure workflow code is deterministic

**Tasks**:
1. Implement deterministic runtime:
   - Coroutine/workflow state management
   - Event sourcing from history
   - Replay-based execution
   - Deterministic time and random

2. Create workflow state machine:
   - Decision state machine
   - Event handlers
   - History replay logic

**Key Files**:
- `cadence-workflow/src/state_machine.rs`
- `cadence-workflow/src/event_handlers.rs`
- `cadence-workflow/src/replay.rs`

## Phase 4: Activity SDK

### 4.1 Activity Context and Functions
**Goal**: Port activity authoring API

**Tasks**:
1. Define `ActivityContext`:
   - Activity info (task token, activity ID, etc.)
   - Deadline/timeout info
   - Heartbeat details

2. Implement activity functions:
   - `get_info()` - Get activity metadata
   - `record_heartbeat()` - Send heartbeat
   - `has_heartbeat_details()` - Check for details
   - `get_heartbeat_details()` - Retrieve details
   - `get_logger()` - Get contextual logger
   - `get_metrics_scope()` - Get metrics
   - `get_worker_stop_channel()` - Watch for worker shutdown

3. Create activity types:
   - `ActivityOptions` - Retry policy, timeouts, task list
   - `LocalActivityOptions` - Options for local activities
   - `RegisterOptions` - Activity registration options
   - `ErrResultPending` - For async completion

**Key Files**:
- `cadence-activity/src/lib.rs`
- `cadence-activity/src/context.rs`

## Phase 5: Testing Framework

### 5.1 Test Suite Implementation
**Goal**: Port the testing framework for unit testing workflows

**Tasks**:
1. Create `TestWorkflowEnvironment`:
   - Mock Cadence service
   - In-memory workflow execution
   - Time control (mock clock)
   - Event inspection

2. Create `TestActivityEnvironment`:
   - Activity testing utilities
   - Mock activity contexts

3. Implement test helpers:
   - `WorkflowTestSuite` - Main test harness
   - History generation from workflows
   - Assertions for workflow state

**Key Files**:
- `cadence-testsuite/src/lib.rs`
- `cadence-testsuite/src/workflow_env.rs`
- `cadence-testsuite/src/activity_env.rs`

### 5.2 Workflow Replayer
**Goal**: Port workflow replayer for backwards compatibility testing

**Tasks**:
1. Implement `WorkflowReplayer`:
   - `replay_workflow_history()` - Replay from history
   - `replay_workflow_history_from_json()` - Replay from JSON
   - `replay_partial_workflow_history()` - Replay subset
   - `replay_workflow_execution()` - Replay from service

2. Create `WorkflowShadower`:
   - Detect non-deterministic changes
   - Run in continuous mode

**Key Files**:
- `cadence-testsuite/src/replayer.rs`
- `cadence-testsuite/src/shadower.rs`

## Phase 6: Advanced Features

### 6.1 Sessions
**Goal**: Port session management for resource grouping

**Tasks**:
1. Implement session API:
   - `create_session()` - Create new session
   - `complete_session()` - Complete session
   - Session options (concurrency, timeout)

**Key Files**:
- `cadence-worker/src/session.rs`

### 6.2 Interceptors
**Goal**: Port workflow interceptor chain

**Tasks**:
1. Define interceptor traits:
   - `WorkflowInterceptor` - Intercept workflow execution
   - `ActivityInterceptor` - Intercept activity execution
   - Chain management

**Key Files**:
- `cadence-worker/src/interceptors.rs`

### 6.3 Authentication
**Goal**: Port authentication providers

**Tasks**:
1. Implement auth providers:
   - `JwtAuthorizationProvider` - JWT-based auth
   - `OAuthAuthorizationProvider` - OAuth flow

**Key Files**:
- `cadence-client/src/auth.rs`

### 6.4 Isolation Groups
**Goal**: Port isolation group utilities

**Tasks**:
1. Implement isolation group API:
   - Group assignment
   - Group-aware routing

**Key Files**:
- `cadence-worker/src/isolation.rs`

## Phase 7: Integration and End-to-End Testing

### 7.1 Integration Tests
**Goal**: Port integration test suite

**Tasks**:
1. Create test scenarios:
   - Basic workflow execution
   - Activity execution
   - Child workflows
   - Signals and queries
   - Cancellation and termination
   - Error handling
   - Timeouts and retries
   - Search attributes

2. Set up test infrastructure:
   - Docker-based Cadence server
   - Test fixtures and helpers

**Key Files**:
- `tests/integration/*.rs`
- `docker-compose.yml` for test environment

### 7.2 Examples and Documentation
**Goal**: Create examples and port documentation

**Tasks**:
1. Create example workflows:
   - Hello world workflow
   - Activity workflow
   - Child workflow
   - Signal handling
   - Query handling
   - Cancellation

2. Write documentation:
   - API documentation (rustdoc)
   - Migration guide from Go
   - README with quick start
   - Architecture documentation

**Key Files**:
- `examples/*.rs`
- `README.md`
- `MIGRATION.md`
- `ARCHITECTURE.md`

## Dependencies Mapping

### Go to Rust Dependencies

| Go Dependency | Rust Equivalent | Purpose |
|--------------|-----------------|---------|
| `thrift` | `thrift` crate | Thrift protocol |
| `yarpc` | Custom implementation | RPC framework |
| `tchannel-go` | `tokio` + custom | Network transport |
| `zap` | `tracing`, `log` | Logging |
| `tally` | `metrics`, `prometheus` | Metrics |
| `opentracing` | `opentelemetry` | Tracing |
| `jaeger-client` | `opentelemetry-jaeger` | Tracing exporter |
| `jwt/v5` | `jsonwebtoken` | JWT auth |
| `oauth2` | `oauth2` crate | OAuth auth |
| `robfig/cron` | `cron` crate | Cron scheduling |
| `pborman/uuid` | `uuid` crate | UUID generation |
| `facebookgo/clock` | `tokio::time` | Clock control |
| `marusama/semaphore` | `tokio::sync::Semaphore` | Concurrency control |

### Core Rust Dependencies

```toml
[dependencies]
# Async runtime
tokio = { version = "1", features = ["full"] }
futures = "0.3"

# Serialization
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# Protocol
thrift = "0.17"
# or
prost = "0.12"
tonic = "0.10"

# Observability
tracing = "0.1"
log = "0.4"
opentelemetry = "0.21"

# Utilities
uuid = { version = "1.0", features = ["v4", "serde"] }
chrono = { version = "0.4", features = ["serde"] }
thiserror = "1.0"
anyhow = "1.0"
once_cell = "1.19"
parking_lot = "0.12"
dashmap = "5.5"

# Auth
jsonwebtoken = "9"
oauth2 = "4"

# Testing
mockall = "0.12"
tempfile = "3.0"
```

## Implementation Order

1. **Week 1-2**: Project setup, protocol layer, core types
2. **Week 3-4**: Client implementation (workflow client, domain client)
3. **Week 5-6**: Worker implementation (registry, pollers, basic handlers)
4. **Week 7-8**: Workflow SDK (context, futures, determinism)
5. **Week 9-10**: Activity SDK and workflow state machine
6. **Week 11-12**: Testing framework (test suite, replayer)
7. **Week 13-14**: Advanced features (sessions, interceptors, auth)
8. **Week 15-16**: Integration tests, examples, documentation

## Key Design Decisions

### 1. Async/Await
- Use `async`/`await` throughout for consistency with Rust ecosystem
- Workflows return `impl Future` or specific future types
- Activities are `async fn`

### 2. Type Safety
- Use strong typing for workflow/activity arguments
- Avoid `interface{}` (Go) - use generics or trait objects appropriately
- Compile-time workflow registration where possible

### 3. Error Handling
- Use `thiserror` for error types
- Structured error handling with `Result`
- Preserve error details from Go client

### 4. Serialization
- Default to JSON for compatibility
- Support custom serializers via traits
- Type-safe serialization with `serde`

### 5. Context Propagation
- Use `Context` types for cancellation and metadata
- Tokio's cancellation tokens for workflow cancellation
- Propagate trace IDs and baggage

## Verification Strategy

### Testing Approach

1. **Unit Tests**: Each module has comprehensive unit tests
2. **Integration Tests**: Test against real Cadence server
3. **Compatibility Tests**: Test against Go client histories
4. **Replay Tests**: Ensure workflow replay works correctly

### Key Verification Steps

1. Start with protocol layer - ensure can communicate with Cadence server
2. Implement simple workflow that calls single activity
3. Verify workflow history matches Go client output
4. Test workflow replay with generated history
5. Port integration tests from Go client
6. Verify backwards compatibility with existing workflows

### Success Criteria

- All major Go client features implemented
- Integration tests pass against Cadence server
- Can replay workflows created by Go client
- Examples compile and run
- Documentation complete
- API is idiomatic Rust (follows Rust naming conventions and patterns)

## Risks and Mitigation

| Risk | Impact | Mitigation |
|------|--------|------------|
| Thrift code generation issues | High | Use established thrift crate, test early |
| Determinism differences from Go | High | Extensive replay testing, reference Go implementation |
| Performance differences | Medium | Benchmark against Go client, optimize hot paths |
| Different async model | Medium | Careful design of workflow state machine |
| Missing IDL files | High | Use uber/cadence-idl repository |

## Notes

- The Go client uses reflection heavily for workflow/activity registration. In Rust, we may need macro-based registration or explicit trait implementations.
- Go's goroutines map to Tokio tasks in Rust.
- Go's `interface{}` for arguments requires careful design in Rust - likely using `serde_json::Value` or generics.
- The sticky workflow cache implementation will differ due to different memory models.
- Thread-local storage in Go needs to be replaced with task-local or context-passing in Rust.